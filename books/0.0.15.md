> 2023.03.09 - 2023.03.15 更新收集面试问题（45道题）
获取更多面试问题可以访问
github 地址: https://github.com/pro-collection/interview-question/issues
gitee 地址: https://gitee.com/yanleweb/interview-question/issues



目录：
- 初级开发者相关问题【共计 1 道题】
  - 61.浏览器的主要组成部分是什么？【浏览器】


- 中级开发者相关问题【共计 19 道题】
  - 53.手写实现函数节流【JavaScript】
  - 54.请设计一个算法, 将两个有序数组合并为一个数组, 请不要使用concat以及sort方法【JavaScript】
  - 55.常见清除浮动的解决方案有哪些【CSS】
  - 56.[ES6]模块与[CommonJS]模块的差异有哪些？【JavaScript】
  - 58.`display: none;`与`visibility: hidden;`的区别是啥【CSS】
  - 59.`display: block;`和`display: inline;`的区别【CSS】
  - 60.海量数据的处理问题: 如何从10亿个数中找出最大的10000个数？【JavaScript】
  - 63.浏览器是如何渲染UI的？【浏览器】
  - 64.浏览器 DOM Tree是如何构建的？【浏览器】
  - 65.常见的浏览器内核有哪些，有啥区别？【浏览器】
  - 66.重绘与重排的区别？【浏览器】
  - 73.express middleware 工作原理是什么？？【Nodejs】
  - 75.[vue]: 手写 vue 双向绑定？【web框架】
  - 95.实现：setObjectValue(obj: object, keys: string[], value: any) 方法， 支持安全设置对象的值【JavaScript】
  - 96.一个 tcp 连接能发几个 http 请求？【网络】
  - 97.JS 中 this 有哪些使用场景？【JavaScript】
  - 98.HTTP 1.0 和 HTTP 1.1 有以下区别？【网络】
  - 99.了解 BFC 吗？【CSS】
  - 103.箭头函数和普通函数的区别？【JavaScript】


- 高级开发者相关问题【共计 16 道题】
  - 57.手写 Promise , 并描述其原理与实现【JavaScript】
  - 62.浏览器如何解析css选择器？【浏览器】
  - 68.如何避免重绘或者重排？【JavaScript】
  - 69.前端如何实现即时通讯？【JavaScript】
  - 70.前端做错误监控？【JavaScript】
  - 72.TCP 和 UDP的区别？【网络】
  - 77.虚拟 dom 原理是啥，手写一个简答的虚拟 dom 实现？【JavaScript】
  - 84.手写实现 call、apply、bind？【JavaScript】
  - 85.知道 JS 中的尾调用吗，如何做尾调优化？【JavaScript】
  - 88.从浏览器地址栏输入url到显示页面所经历的流程有哪些(以HTTP为例)？【浏览器】
  - 89.从哪些方面可以对网站性能优化？【浏览器】
  - 90.redux-thunk 和 redux 是什么关系？【web框架】
  - 91.Iterator 和 for...of 了解多少？【JavaScript】
  - 94.纯 TS 项目工程中, 如何使用 alias path?【JavaScript】
  - 100.flex 布局了解多少？【CSS】
  - 102.map 和 weakMap 的区别 ?【JavaScript】


- 资深开发者相关问题【共计 9 道题】
  - 76.JS 内存泄露问题该如何排查？【JavaScript】
  - 78.[vue]: vue2.x 虚拟 dom 是怎么实现的？【web框架】
  - 79.[vue]: 是如何实现 MVVM 的？【web框架】
  - 80.[Redux]: 看过 Redux 源码吗， 对 Redux 了解多少？【web框架】
  - 83.react和vue的区别？【web框架】
  - 86.V8 引擎了解多少？【Nodejs、网络】
  - 87.如何进行 node 内存优化？【Nodejs】
  - 92.如何给自己团队的大型前端项目设计单元测试？【JavaScript】
  - 93.如何做一个前端项目工程的自动化部署， 有哪些规范和流程设计？【JavaScript】




    
# 初级开发者相关问题【共计 1 道题】

## 61.浏览器的主要组成部分是什么？【浏览器】
**回答:**      
浏览器的主要组成部分是什么

- **用户界面** - 包括地址栏、前进/后退按钮、书签菜单等。除了浏览器主窗口显示的您请求的页面外，其他显示的各个部分都属于用户界面。
- **浏览器引擎** - 在用户界面和呈现引擎之间传送指令。
- **呈现引擎** - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。
- **网络** - 用于网络调用，比如 HTTP 请求。其接口与平台无关，并为所有平台提供底层实现。
- **用户界面后端** - 用于绘制基本的窗口小部件，比如组合框和窗口。其公开了与平台无关的通用接口，而在底层使用操作系统的用户界面方法。
- **JavaScript 解释器** - 用于解析和执行 JavaScript 代码。
- **数据存储。这是持久层** - 浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“网络数据库”，这是一个完整（但是轻便）的浏览器内数据库。                  

           



# 中级开发者相关问题【共计 19 道题】

## 53.手写实现函数节流【JavaScript】
**回答:**      
## 实现函数节流

[https://blog.csdn.net/beijiyang999/article/details/79836463](https://blog.csdn.net/beijiyang999/article/details/79836463)

### 函数节流是什么
**对于持续触发的事件，规定一个间隔时间（n秒），每隔一段只能执行一次。**                      
函数防抖（debounce）与本篇说的函数节流（throttle）相似又不同。                     
函数防抖一般是指对于**在事件被触发n秒后再执行的回调，如果在这n秒内又重新被触发，则重新开始计时。**                        
二者都能防止函数过于频繁的调用。                        
区别在于，当事件持续被触发，如果触发时间间隔短于规定的等待时间（n秒），那么                      
- 函数防抖的情况下，函数将一直推迟执行，造成不会被执行的效果；
- 函数节流的情况下，函数将每个 n 秒执行一次。


### 函数节流的实现
函数节流的实现有不同的思路，可以通过**时间戳实现**，也可以通过**定时器实现**。

### 时间戳
#### 思路
只要触发，就用 Date 获取现在的时间，与上一次的时间比较。                     
如果时间差大于了规定的等待时间，就可以执行一次；                        
目标函数执行以后，就更新 previous 值，确保它是“上一次”的时间。                       
否则就等下一次触发时继续比较。                     

#### 代码如下
```javascript
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = +new Date();
        let context = this;
        if (now - previous >= wait) {
            func.apply(context, arguments);
            previous = now; // 执行后更新 previous 值
        }
    }
}
container.onmousemove = throttle(doSomething, 1000);
```

### 定时器
#### 思路
用定时器实现时间间隔。                             
当定时器不存在，说明可以执行函数，于是定义一个定时器来向任务队列注册目标函数                              
目标函数执行后设置保存定时器ID变量为空                                
当定时器已经被定义，说明已经在等待过程中。则等待下次触发事件时再进行查看。                               

#### 代码
```javascript
function throttle(func, wait) {
    let time, context;
    return function(){
        context = this;
        if(!time){
            time = setTimeout(function(){
                func.apply(context, arguments);
                time = null
            }, wait)
        }
    }
}
```


### 效果差异
一个周期内：                      
时间戳实现的：先执行目标函数，后等待规定的时间段；                       
计时器实现的：先等待够规定时间，再执行。 即停止触发后，若定时器已经在任务队列里注册了目标函数，它也会执行最后一次。                      

### 优化：二者结合
结合二者，实现一次触发，两次执行（先立即执行，结尾也有执行）                  
```javascript
function throttle (func, wait) {
    let previous = 0;
    let context, args, time;
    return function(){
        let now = +new Date();
        context = this;
        args = arguments;
        if(now - previous >= wait){ //当距上一次执行的间隔大于规定，可以直接执行
            func.apply(context, args);
            previous = now
        } else { // 否则继续等待，结尾执行一次
            if(time) clearTimeout(time);
            time = setTimeout(
                () => {
                        func.apply(context, args);
                        time = null
                      }
            , wait)
        }
    }
}
```

#### 问题
已经实现了一次触发，两次执行，有头有尾的效果。             
问题是，上一个周期的“尾”和下一个周期的“头”之间，失去了对时间间隔的控制。              

#### 修复
仔细查看，发现问题出在了 previous 的设置上。                                 
仅仅在“可直接执行”的情况下更新了 previous 值，在通过计时器注册入任务队列后执行的情况下，忽略了 previous 的更新。
导致了 previous 的值不再是“上一次执行”时的时间，而是“上一次直接可执行情况下执行”的时间。                                  
同时，引入变量 remaining 表示还需要等待的时间，来让尾部那一次的执行也符合时间间隔。

#### 完善后代码：
```javascript
function throttle(func, wait) {
    let previous = 0;
    let context, args, time, remaining;

    return function() {
        let now = +new Date();
        context = this;
        args = arguments;
        remaining = wait - (now - previous);    // 剩余的还需要等待的时间
        if (remaining <= 0) {
            func.apply(context, args);
            previous = now // 重置“上一次执行”的时间
        } else {
            if (time) {
                clearTimeout(time);
            }
            time = setTimeout(() => {
                func.apply(context, args);
                time = null;
                previous = +new Date() // 重置“上一次执行”的时间
            }, remaining) //等待还需等待的时间
        }
    };
}
```


#### 更进一步的优化
参考 underscore 与 mqyqingfeng ，实现是否启用第一次 / 尾部最后一次计时回调的执行。             
设置 options 作为第三个参数，然后根据传的值判断到底哪种效果，约定:              
- leading：false 表示禁用第一次执行
- trailing: false 表示禁用停止触发的回调
```javascript
function throttle(func, wait, options) {
    let time, context, args, result;
    let previous = 0;
    if (!options) options = {};

    let later = function () {
        previous = options.leading === false ? 0 : new Date().getTime();
        time = null;
        func.apply(context, args);
        if (!time) context = args = null;
    };

    let throttled = function () {
        let now = new Date().getTime();
        if (!previous && options.leading === false) previous = now;
        let remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
            if (time) {
                clearTimeout(time);
                time = null;
            }
            previous = now;
            func.apply(context, args);
            if (!time) context = args = null;
        } else if (!time && options.trailing !== false) {
            time = setTimeout(later, remaining);
        }
    };
    return throttled;
}
```

如果想添加一个取消功能：
```javascript
throttled.cancel = function() {
    clearTimeout(time);
    time = null;
    previous = 0;
}
```

           

## 54.请设计一个算法, 将两个有序数组合并为一个数组, 请不要使用concat以及sort方法【JavaScript】
**回答:**      
```javascript
let merge = function (left, right) {
  let leftIndex = 0, rightIndex = 0;
  let result = [];
  let leftLen = left.length;
  let rightLen  = right.length;
  let diffIndex = leftLen - rightLen;
  let connectList;
  if(diffIndex > 0) {
    connectList = left.slice(rightLen);
  } else {
    connectList = right.slice(leftLen);
  }
  while (leftIndex < left.length && rightIndex < right.length) {
    if (left[leftIndex] < right[rightIndex]) {
      result.push(left[leftIndex++])
    } else {
      result.push(right[rightIndex++])
    }
  }
  // console.log(result);
  result = result.concat(connectList);
  return result;
};

let left = [1, 4, 7, 8, 9, 10];
let right = [2, 5];
console.log(merge(left, right));
```

           

## 55.常见清除浮动的解决方案有哪些【CSS】
**回答:**      
## 清除浮动的解决方案 （以下提供了八种解决方式）

### 1、利用div定义height
```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red; /*解决代码*/
        height: 200px;
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px;
        margin-top: 10px
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }
</style>
<div class="div1">
    <div class="left">Left</div>
    <div class="right">Right</div>
</div>
<div class="div2">
    div2
</div>
```
原理：父级div手动定义height，就解决了父级div无法自动获取到高度的问题。

优点：简单、代码少、容易掌握

缺点：只适合高度固定的布局，要给出精确的高度，如果高度和父级div不一样时，会产生问题

**建议：不推荐使用，只建议高度固定的布局时使用**

### 2、结尾处加空div标签 clear:both
```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px;
        margin-top: 10px
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }

    /*清除浮动代码*/
    .clearfloat {
        clear: both
    }
</style>
<div class="div1">
    <div class="left">Left</div>
    <div class="right">Right</div>
    <div class="clearfloat"></div>
</div>
<div class="div2">
    div2
</div>
```
原理：添加一个空div，利用css提高的clear:both清除浮动，让父级div能自动获取到高度

优点：简单、代码少、浏览器支持好、不容易出现怪问题

缺点：不少初学者不理解原理；如果页面浮动布局多，就要增加很多空div，让人感觉很不好

**建议：不推荐使用，但此方法是以前主要使用的一种清除浮动方法**

### 3、父级div定义 伪类:after 和 zoom
```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red;
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px;
        margin-top: 10px
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }

    /*清除浮动代码*/
    .clearfloat:after {
        display: block;
        clear: both;
        content: "";
        visibility: hidden;
        height: 0
    }

    .clearfloat {
        zoom: 1
    }
</style>
<div class="div1 clearfloat">
    <div class="left">Left</div>
    <div class="right">Right</div>
</div>
<div class="div2">
    div2
</div>
```
原理：IE8以上和非IE浏览器才支持:after，原理和方法2有点类似，zoom(IE转有属性)可解决ie6,ie7浮动问题

优点：浏览器支持好、不容易出现怪问题（目前：大型网站都有使用，如：腾迅，网易，新浪等等）

缺点：代码多、不少初学者不理解原理，要两句代码结合使用才能让主流浏览器都支持。

**建议：推荐使用，建议定义公共类，以减少CSS代码。**

### 4、父级div定义 overflow:hidden
```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red; /*解决代码*/
        width: 98%;
        overflow: hidden
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px;
        margin-top: 10px;
        width: 98%
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }
</style>
<div class="div1">
    <div class="left">Left</div>
    <div class="right">Right</div>
</div>
<div class="div2">
    div2
</div>
```
原理：必须定义width或zoom:1，同时不能定义height，使用overflow:hidden时，浏览器会自动检查浮动区域的高度

优点：简单、代码少、浏览器支持好

缺点：不能和position配合使用，因为超出的尺寸的会被隐藏。

**建议：只推荐没有使用position或对overflow:hidden理解比较深的朋友使用。**

### 5、父级div定义 overflow:auto
```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red; /*解决代码*/
        width: 98%;
        overflow: auto
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px;
        margin-top: 10px;
        width: 98%
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }
</style>
<div class="div1">
    <div class="left">Left</div>
    <div class="right">Right</div>
</div>
<div class="div2">
    div2
</div>
```
原理：必须定义width或zoom:1，同时不能定义height，使用overflow:auto时，浏览器会自动检查浮动区域的高度

优点：简单、代码少、浏览器支持好

缺点：内部宽高超过父级div时，会出现滚动条。

**建议：不推荐使用，如果你需要出现滚动条或者确保你的代码不会出现滚动条就使用吧。**

### 6、父级div 也一起浮动
```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red; /*解决代码*/
        width: 98%;
        margin-bottom: 10px;
        float: left
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px;
        width: 98%; /*解决代码*/
        clear: both
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }
</style>
<div class="div1">
    <div class="left">Left</div>
    <div class="right">Right</div>
</div>
<div class="div2">
    div2
</div>
```
原理：所有代码一起浮动，就变成了一个整体

优点：没有优点

缺点：会产生新的浮动问题。

**建议：不推荐使用，只作了解。**

### 7、父级div定义 display:table
```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red; /*解决代码*/
        width: 98%;
        display: table;
        margin-bottom: 10px;
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px;
        width: 98%;
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }
</style>
<div class="div1">
    <div class="left">Left</div>
    <div class="right">Right</div>
</div>
<div class="div2">
    div2
</div>
```
原理：将div属性变成表格

优点：没有优点

缺点：会产生新的未知问题。

**建议：不推荐使用，只作了解。**

### 8、结尾处加 br标签 clear:both

```html
<style type="text/css">
    .div1 {
        background: #000080;
        border: 1px solid red;
        margin-bottom: 10px;
        zoom: 1
    }

    .div2 {
        background: #800080;
        border: 1px solid red;
        height: 100px
    }

    .left {
        float: left;
        width: 20%;
        height: 200px;
        background: #DDD
    }

    .right {
        float: right;
        width: 30%;
        height: 80px;
        background: #DDD
    }

    .clearfloat {
        clear: both
    }
</style>
<div class="div1">
    <div class="left">Left</div>
    <div class="right">Right</div>
    <br class="clearfloat"/>
</div>
<div class="div2">
    div2
</div>
```
原理：父级div定义zoom:1来解决IE浮动问题，结尾处加 br标签 clear:both

**建议：不推荐使用，只作了解。**

           

## 56.[ES6]模块与[CommonJS]模块的差异有哪些？【JavaScript】
**回答:**      
差异主要有如下几点：
- CommonJS 输出是值的拷贝，即原来模块中的值改变不会影响已经加载的该值，ES6静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- CommonJS 加载的是整个模块，即将所有的接口全部加载进来，ES6 可以单独加载其中的某个接口（方法），
- CommonJS this 指向当前模块，ES6 this 指向undefined

CommonJS 模块输出的是值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。
ES6 模块的运行机制与 CommonJS 不一样。
JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。
等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。
ES6 模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。 

           

## 58.`display: none;`与`visibility: hidden;`的区别是啥【CSS】
**回答:**      
联系：它们都能让元素不可见

区别：

1. display:none;会让元素完全从渲染树中消失，渲染的时候不占据任何空间；
   visibility: hidden;不会让元素从渲染树消失，渲染师元素继续占据空间，只是内容不可见
2. display: none;是非继承属性，子孙节点消失由于元素从渲染树消失造成，通过修改子孙节点属性无法显示；
   visibility: hidden;是继承属性，子孙节点消失由于继承了hidden，通过设置visibility: visible;可以让子孙节点显式
3. 修改常规流中元素的display通常会造成文档重排。修改visibility属性只会造成本元素的重绘。
4. 读屏器不会读取display: none;元素内容；会读取visibility: hidden;元素内容

           

## 59.`display: block;`和`display: inline;`的区别【CSS】
**回答:**      
``block``元素特点：

1.处于常规流中时，如果``width``没有设置，会自动填充满父容器
2.可以应用``margin/padding``
3.在没有设置高度的情况下会扩展高度以包含常规流中的子元素
4.处于常规流中时布局时在前后元素位置之间（独占一个水平空间）
5.忽略``vertical-align``

``inline``元素特点

1.水平方向上根据``direction``依次布局
2.不会在元素前后进行换行
3.受``white-space``控制
4.``margin/padding``在竖直方向上无效，水平方向上有效
5.``width/height``属性对非替换行内元素无效，宽度由元素内容决定
6.非替换行内元素的行框高由``line-height``确定，替换行内元素的行框高由``height``,``margin``,``padding``,``border``决定
6.浮动或绝对定位时会转换为``block``
7.``vertical-align``属性生效

           

## 60.海量数据的处理问题: 如何从10亿个数中找出最大的10000个数？【JavaScript】
**回答:**      
从10亿个数中找出最大的10000个数是一项非常具有挑战性的任务，需要使用高效的算法和数据结构来处理。

以下是一种基于分治思想的常见方法：

将10亿个数分成1000个小文件，每个文件包含100万个数。
对每个小文件进行排序，选出每个文件中最大的1000个数，并将它们放入一个临时文件中。
将1000个临时文件合并成一个大文件，并再次对其进行排序。
选出最大的10000个数。

这种方法的时间复杂度为O(N*log(N/K))，其中N是所有数据的数量，K是每个小文件中的数据量。由于K相对较小，因此这种方法非常高效。

           

## 63.浏览器是如何渲染UI的？【浏览器】
**回答:**      
浏览器渲染UI的过程通常被称为渲染流水线（rendering pipeline），它可以分为以下几个步骤：

1. 解析HTML：浏览器首先解析HTML代码，创建DOM（文档对象模型）树。DOM树是由节点和对象组成的层次结构，它表示了文档的内容和结构。

2. 解析CSS：浏览器接着解析CSS代码，创建CSSOM（CSS对象模型）树。CSSOM树是由CSS规则和对应的元素组成的层次结构，它表示了文档中的元素的样式信息。

3. 创建渲染树：浏览器将DOM树和CSSOM树结合起来，生成渲染树。渲染树只包含需要显示的元素，它是一种按照渲染顺序排列的树形结构。

4. 布局：浏览器对渲染树进行布局（layout），计算每个元素在屏幕上的位置和大小。

5. 绘制：浏览器将渲染树中的每个元素绘制到屏幕上。

6. 合成：如果有多个层叠的元素，浏览器将它们合成一个图层，以提高性能。

这些步骤通常是逐步完成的，而且它们是相互依赖的。例如，布局必须在绘制之前完成，因为绘制需要知道每个元素的位置和大小。为了提高性能，浏览器通常会对这些步骤进行优化，例如使用异步布局和延迟合成等技术。




           

## 64.浏览器 DOM Tree是如何构建的？【浏览器】
**回答:**      
浏览器构建DOM树的过程包括以下几个步骤：

1. 解析HTML代码：浏览器会将HTML代码解析成一个DOM树的结构。

2. 创建根节点：DOM树的根节点通常是HTML元素。

3. 创建子节点：根据HTML标记的嵌套关系，浏览器会在DOM树中创建相应的子节点，每个节点表示一个HTML元素。

4. 创建属性节点：HTML元素可能有一些属性，例如id、class、src等，浏览器会将这些属性创建为节点的属性节点。

5. 创建文本节点：如果HTML元素中包含文本内容，浏览器会将这些文本内容创建为文本节点，并将它们作为元素的子节点插入到DOM树中。

6. 创建注释节点：HTML代码中可能包含注释，浏览器会将注释创建为注释节点，并将它们插入到DOM树中。

7. 构建完整的DOM树：经过以上步骤，浏览器会将所有HTML代码解析成一个完整的DOM树。

需要注意的是，浏览器构建DOM树是一个逐步进行的过程，解析器会逐个读取HTML标记，并创建相应的节点，直到解析完整个HTML代码。在这个过程中，如果遇到错误的HTML标记，浏览器也会尽可能地将其解析成一个节点，以保证DOM树的完整性。

           

## 65.常见的浏览器内核有哪些，有啥区别？【浏览器】
**回答:**      
常见的浏览器内核包括：

- **Trident内核**：由Microsoft开发，主要用于Internet Explorer浏览器，也是Windows系统自带的默认浏览器内核。该内核在HTML和CSS的解释、渲染方面存在一些问题，但在JavaScript引擎的处理上表现较为出色。

- **Gecko内核**：由Mozilla开发，主要用于Firefox浏览器。该内核在HTML和CSS的解释、渲染方面表现较好，同时也有较强的JavaScript引擎。

- **WebKit内核**：由苹果公司开发，最初是为Safari浏览器所用。该内核在HTML、CSS和JavaScript处理方面都表现出色，支持的CSS特性较多。

- **Blink内核**：由Google和Opera Software共同开发，用于Chrome浏览器和Opera浏览器。该内核是Webkit内核的一个分支，对Web标准的支持也非常好。

这些浏览器内核之间的主要区别在于对Web标准的支持程度、渲染引擎的处理能力、JavaScript引擎的性能、浏览器的兼容性等方面。此外，不同的浏览器内核也会有一些独特的特性和优化，以满足不同用户的需求。


## 下面是一个简单的表格对比
<table>
  <thead>
  <tr>
    <th>浏览器内核</th>
    <th>开发公司</th>
    <th>代表浏览器</th>
    <th>支持程度</th>
    <th>渲染引擎</th>
    <th>JavaScript引擎</th>
    <th>浏览器兼容性</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td>Trident</td>
    <td>Microsoft</td>
    <td>Internet Explorer</td>
    <td>一般</td>
    <td>一般</td>
    <td>出色</td>
    <td>差</td>
  </tr>
  <tr>
    <td>Gecko</td>
    <td>Mozilla</td>
    <td>Firefox</td>
    <td>较好</td>
    <td>较好</td>
    <td>出色</td>
    <td>好</td>
  </tr>
  <tr>
    <td>WebKit</td>
    <td>Apple</td>
    <td>Safari</td>
    <td>出色</td>
    <td>出色</td>
    <td>出色</td>
    <td>好</td>
  </tr>
  <tr>
    <td>Blink</td>
    <td>Google and Opera Software</td>
    <td>Chrome and Opera</td>
    <td>出色</td>
    <td>出色</td>
    <td>出色</td>
    <td>好</td>
  </tr>
  </tbody>
</table>

           

## 66.重绘与重排的区别？【浏览器】
**回答:**      
浏览器重绘（Repaint）和重排（Reflow）是Web页面中常见的两种渲染方式，它们的区别如下：

1.  重排（Reflow）：当DOM元素的结构或者布局发生变化时，浏览器需要重新计算元素的几何属性（比如位置、大小等），然后重新构建渲染树，这个过程叫做重排。重排的代价比较高，因为需要浏览器重新计算和布局，会消耗较多的CPU资源和时间。

2.  重绘（Repaint）：当元素的样式（如背景颜色、字体颜色、边框颜色等）发生变化时，浏览器会重新绘制元素的样式，这个过程叫做重绘。重绘的代价比较低，因为不需要重新计算元素的位置和大小，只需要重新绘制元素的样式即可。

因此，重排会触发重绘，但是重绘不一定会触发重排。在Web开发中，我们应该尽量避免频繁的重排和重绘，以提高页面的性能。一些常见的优化方式包括：减少DOM操作、使用CSS3动画代替JavaScript动画、避免使用table布局等。

           

## 73.express middleware 工作原理是什么？？【Nodejs】
**回答:**      
## express middleware 工作原理是什么？

Express middleware 的工作原理是通过拦截 HTTP 请求，对请求进行处理，然后将请求传递给下一个中间件或应用程序的路由处理。在 Express 中，中间件可以是一个或多个函数，每个函数都可以对请求进行操作或响应，从而实现对请求的处理和过滤。

当 Express 应用程序接收到一个 HTTP 请求时，请求将首先被传递给第一个注册的中间件函数。这个中间件函数可以对请求进行操作，例如修改请求的头信息、检查请求是否包含有效的身份验证令牌等等。当这个中间件函数完成操作后，它可以选择将请求传递给下一个中间件函数，或者直接将响应返回给客户端。

如果中间件函数选择将请求传递给下一个中间件函数，它可以调用 next() 函数来将控制权传递给下一个中间件。这个过程可以一直持续到所有中间件函数都被执行完毕，最后将请求传递给应用程序的路由处理函数。

通过使用中间件，开发人员可以将应用程序的功能模块化，从而实现更好的代码组织和可维护性。同时，中间件还可以实现各种功能，例如身份验证、日志记录、错误处理等等，从而为应用程序提供更丰富的功能和更好的用户体验。

## 它的设计模式是啥？写一个简单的示例呢

Express middleware 的设计模式是基于责任链模式。在责任链模式中，每个对象都有机会处理请求，并将其传递给下一个对象，直到请求被完全处理为止。在 Express 中，每个中间件函数都有机会对请求进行处理，并可以选择将请求传递给下一个中间件函数或应用程序的路由处理函数。

以下是一个简单的示例，演示如何使用 Express middleware 实现身份验证：

```javascript
const express = require('express');
const app = express();

// 定义一个中间件函数，用于验证用户身份
function authenticate(req, res, next) {
  const token = req.headers.authorization;
  if (token === 'secret-token') {
    // 如果令牌有效，则将控制权传递给下一个中间件函数
    next();
  } else {
    // 否则，返回 401 错误
    res.status(401).send('Unauthorized');
  }
}

// 注册中间件函数，用于验证用户身份
app.use(authenticate);

// 定义一个路由处理函数，用于返回受保护的资源
app.get('/protected', (req, res) => {
  res.send('Protected resource');
});

// 启动应用程序
app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

在上面的示例中，我们定义了一个名为 authenticate 的中间件函数，它用于验证用户的身份。在这个函数中，我们检查请求头中是否包含有效的身份验证令牌。如果令牌有效，则将控制权传递给下一个中间件函数或路由处理函数。否则，返回 401 错误。

然后，我们通过调用 app.use() 方法来注册这个中间件函数，以便在每个请求中都进行身份验证。最后，我们定义一个名为 /protected 的路由处理函数，它表示受保护的资源。只有在身份验证通过后，才能访问这个路由处理函数。

通过这个简单的示例，我们可以看到如何使用 Express middleware 实现基本的身份验证功能。中间件函数充当责任链中的一个环节，通过对请求进行处理和过滤，为应用程序提供更好的安全性和用户体验。
           

## 75.[vue]: 手写 vue 双向绑定？【web框架】
**回答:**      
## 双向绑定核心知识点

如果一个对象中有属性有方法，那么调用属性可以直接. 就可以调用，但是如果是调用方法的时候，是通过入参来决定key的值来调用的话，请用[]来表示：  
```html
<!DOCTYPE html>
<html lang="en" xmlns:v-on="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="UTF-8">
      <title>MVVM 双项绑定</title>
      <style>
        #app {
        text-align: center;
        margin-top: 100px;
        color: #888;
      }

        h1 {
        color: #aaa;
      }

        input {
        padding: 0 10px;
        width: 600px;
        line-height: 2.5;
        border: 1px solid #ccc;
        border-radius: 2px;
      }

        .bind {
        color: #766;
      }

        strong {
        color: #05BC00;
      }

        button {
        padding: 5px 10px;
        border: 1px solid #777777;
        border-radius: 5px;
        background: #ffffff;
        color: #777777;
        cursor: pointer;

      }
      </style>
  </head>
  <body>
    <div id="app">
      <h1>Hi，MVVM</h1>
      <input v-model="name" placeholder="请输入内容" type="text">
        <h1 class="bind">{{name}} 's age is <strong>{{age}}</strong></h1>
        <button v-on:click="sayHi">点击欢迎您</button>
    </div>
    <script>
      function observe(data) {
      //如果不是一个对象，直接终止程序
      if (!data || typeof data !== 'object') {
      return false;
    }
      for (let key in data) {
      let val = data[key];
      let subject = new Subject();
      Object.defineProperty(data, key, {
      enumerable: true,
      configurable: true,
      get: function () {
      if (currentObserver) {
      currentObserver.subscribeTo(subject)
    }
      return val
    },
      set: function (newVal) {
      val = newVal;
      subject.notify()
    }
    });
      if (typeof val === 'object') {
      observe(val)
    }
    }
    }

      let id = 0;
      let currentObserver = null;

      /**
      * 订阅者对象
      */
      class Subject {
      constructor() {
      this.id = id++;
      this.observers = []
    }

      addObserver(observer) {
      this.observers.push(observer)
    }

      removeObserver(observer) {
      let index = this.observers.indexOf(observer)
      if (index > -1) {
      this.observers.splice(index, 1)
    }
    }

      notify() {
      this.observers.forEach(observer => {
      observer.update()
    })
    }
    }

      /**
      * 观察者对象
      */
      class Observer {
      constructor(vm, key, cb) {
      this.subjects = {};
      this.vm = vm;
      this.key = key;
      this.cb = cb;
      this.value = this.getValue()
    }

      //如果新旧数据不相同，就直接调用cb方法
      update() {
      let oldVal = this.value;
      let value = this.getValue();
      if (value !== oldVal) {
      this.value = value;
      this.cb.bind(this.vm)(value, oldVal)
    }
    }

      //添加观察者
      subscribeTo(subject) {
      if (!this.subjects[subject.id]) {       //如果当前换擦着中不存在这个当前id的一个对象，那么吧这个对象添加为观察者
      subject.addObserver(this);
      this.subjects[subject.id] = subject     //放在观察者对象中，根据自增id来区分
    }
    }

      getValue() {
      currentObserver = this;
      let value = this.vm.$data[this.key];    //获取vm实例兑现中的data数据
      currentObserver = null;
      return value
    }
    }

      /**
      * 编译对象
      */
      class Compile {
      constructor(vm) {
      this.vm = vm; //vm对象
      this.node = vm.$el; //获取挂载的元素dom
      this.compile();//执行核心功能
    }

      compile() {
      this.traverse(this.node);//传入的参数是挂载元素dom
    }

      traverse(node) {
      if (node.nodeType === 1) {      //节点类型1：element元素
      this.compileNode(node);     //触发节点事件 双向绑定和事件触发
      node.childNodes.forEach(childNode => {
      this.traverse(childNode);       // 递归调用，如果是有子节点，重新递归
    })
    } else if (node.nodeType === 3) {       // 节点类型3： 文本元素
      this.compileText(node);     // 处理文本元素的编译
    }
    }

      // 文本编译入口
      compileText(node) {
      let reg = /{{(.+?)}}/g;
      let match;
      while (match = reg.exec(node.nodeValue)) {      //获取到文本内容
      let raw = match[0]
      let key = match[1].trim()
      node.nodeValue = node.nodeValue.replace(raw, this.vm.$data[key]);
      new Observer(this.vm, key, function (val, oldVal) {     // 订阅者核心方法
      node.nodeValue = node.nodeValue.replace(oldVal, val)
    })
    }
    }

      // 节点编译入口
      compileNode(node) {
      let attrs = [...node.attributes];//获取标签属性
      attrs.forEach(attr => {
      if (this.isModelDirective(attr.name)) { //截取是绑定数据的情况
      this.bindModel(node, attr); //绑定数据
    } else if (this.isEventDirective(attr.name)) { //截取是绑定事件的情况
      this.bindEventHander(node, attr); //触发事件
    }
    })
    }

      /**
       * 双向绑定数据
       * @param node  标签节点
       * @param attr  标签节点的属性名
       */
      bindModel(node, attr) {
      let key = attr.value;// 获取到传递过来的属性的key的值
      node.value = this.vm.$data[key]; //给节点绑定值，对应的值就是vm实例里面data对应key的值
      new Observer(this.vm, key, function (newVal) {
      node.value = newVal
    });
      node.oninput = (e) => { //监听节点的input事件
      this.vm.$data[key] = e.target.value //过去输入框中输入的value值，把这个值放入到vm的data实例中去
    }
    }

      /**
       *
       * @param node
       * @param attr
       */
      bindEventHander(node, attr) {
      let eventType = attr.name.substr(5); //获取节点属性,从第五个下标开始截取后面的字符串作为：key(事件类型)
      let methodName = attr.value; //获取节点的属性的value
      node.addEventListener(eventType, this.vm.$methods[methodName]);//通过事件类型，来触发事件，事件就是vm实例中方法
    }

      //赛选出传入的node属性是v-model的情况
      isModelDirective(attrName) {
      return attrName === 'v-model'
    }

      //赛选出传入的node属性是 v-on的情况
      isEventDirective(attrName) {
      return attrName.indexOf('v-on') === 0
    }
    }

      class mvvm {
      constructor(opts) {     //这里面的函数是实例化的时候执行的
      this.init(opts);
      observe(this.$data);
      new Compile(this);      //变异当前对象
    }

      init(opts) {
      if (opts.el.nodeType === 1) {
      this.$el = opts.el
    } else {
      this.$el = document.querySelector(opts.el)
    }

      this.$data = opts.data || {};
      this.$methods = opts.methods || {};
      //把$data 中的数据直接代理到当前 vm 对象
      for (let key in this.$data) {
      Object.defineProperty(this, key, {
      enumerable: true,
      configurable: true,
      get: () => {
      return this.$data[key]
    },
      set: newVal => {
      this.$data[key] = newVal
    }
    })
    }
      //让 this.$methods 里面的函数中的 this，都指向当前的 this，也就是 vm对象实例
      for (let key in this.$methods) {
      this.$methods[key] = this.$methods[key].bind(this);
    }
    }
    }


      /**
      * 实例化MVVM对象， 主入口
      * @type {mvvm}
      */
      let vm = new mvvm({
      el: '#app',
      data: {
      name: 'YanLe',
      age: 3
    },
      methods: {
      sayHi: function () {
      alert(`hi ${this.name}`)
    }
    }
    });

      let clock = setInterval(function () {
      vm.age++;  //等同于 vm.$data.age

      if (vm.age === 10) clearInterval(clock)
    }, 1000)
    </script>
  </body>
</html>
```


           

## 95.实现：setObjectValue(obj: object, keys: string[], value: any) 方法， 支持安全设置对象的值【JavaScript】
**回答:**      
可以使用递归实现安全设置对象的值。以下是一个实现setObjectValue方法的例子：

```typescript
typescriptCopy codefunction setObjectValue(obj: object, keys: string[], value: any) {
  const key = keys.shift();
  if (!key) {
    return;
  }

  if (keys.length === 0) {
    obj[key] = value;
    return;
  }

  if (!obj[key]) {
    obj[key] = {};
  }

  setObjectValue(obj[key], keys, value);
}
```

这个方法接受三个参数：要设置值的对象，一个字符串数组表示对象的键的路径，和要设置的值。例如，如果要设置对象`user`的`address`字段的`city`属性为`"New York"`，可以调用方法：

```typescript
typescriptCopy codeconst user = {};
setObjectValue(user, ['address', 'city'], 'New York');
```

在这个例子中，`keys`数组的第一个元素是`"address"`，所以我们检查`user`对象是否有一个名为`"address"`的属性。如果没有，我们创建一个新对象并将其分配给`user.address`属性。然后我们继续递归地调用`setObjectValue`方法，将新对象作为第一个参数传递，将`keys`数组的剩余部分作为第二个参数传递，将最终的值作为第三个参数传递。最终，我们将`"New York"`分配给`user.address.city`属性。

这个方法确保在设置对象值时不会引发`TypeError`异常，即使对象的某些部分尚未定义。
           

## 96.一个 tcp 连接能发几个 http 请求？【网络】
**回答:**      
如果是 HTTP 1.0 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP 连接即会断开，因此一个 TCP 发送一个 HTTP 请求，但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 Connection 和 Keep-Alive 首部，在请求头带上 Connection: Keep-Alive，并且可以通过 Keep-Alive 通用首部中指定的，用逗号分隔的选项调节 keep-alive 的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注《HTTP 权威指南》4.5.5 节对于 Keep-Alive 连接的限制和规则。

而如果是 HTTP 1.1 版本协议，支持了长连接，因此只要 TCP 连接不断开，便可以一直发送 HTTP 请求，持续不断，没有上限； 同样，如果是 HTTP 2.0 版本协议，支持多用复用，一个 TCP 连接是可以并发多个 HTTP 请求的，同样也是支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送

           

## 97.JS 中 this 有哪些使用场景？【JavaScript】
**回答:**      
this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。

- 第一种是`函数调用模式`，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。
  
- 第二种是`方法调用模式`，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。
  
- 第三种是`构造器调用模式`，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。
  
- 第四种是 `apply 、 call 和 bind 调用模式`，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。

这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。

           

## 98.HTTP 1.0 和 HTTP 1.1 有以下区别？【网络】
**回答:**      
- **连接方面**，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
  
- **资源请求方面**，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
  
- **缓存方面**，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
  
- http1.1 中新**增了 host 字段**，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
  
- http1.1 相对于 http1.0 还新**增了很多请求方法**，如 PUT、HEAD、OPTIONS 等。

           

## 99.了解 BFC 吗？【CSS】
**回答:**      
> 小提示：先聊一聊BFC是什么；
然后再说说触发BFC的条件；
再说一说BFC的一些作用

BFC是块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。(俗称：**脱离文档流**)

**触发条件**

- position: absolute/fixed：绝对定位
- display: inline-block / table / flex
- float 设置除none以外的值；（只要设置了浮动，当前元素就创建了BFC）
- ovevflow !== visible (可为：hidden、auto、scroll)

**特性和应用**

- 阻止margin重叠：同一个 BFC 下外边距（margin）会发生折叠
- 清除浮动 ：清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中)
- 自适应两栏布局：左float+右BFC，是利用了BFC 的区域不会与 float 的元素区域重叠的机制


           

## 103.箭头函数和普通函数的区别？【JavaScript】
**回答:**      
箭头函数和普通函数是 JavaScript 中两种不同的函数定义方式，它们有以下的区别：

- **语法不同**：箭头函数使用箭头 => 来定义函数，而普通函数使用 function 关键字来定义函数。

- **箭头函数没有自己的 this**，它会继承其所在作用域的 this 值。而普通函数的 this 则由函数调用时的上下文所决定，可以通过 call、apply、bind 方法来改变。

- **箭头函数没有自己的 arguments 对象**，它可以通过 rest 参数语法来接收不定数量的参数。而普通函数则有自己的 arguments 对象，它可以接收任意数量的参数。

- **箭头函数不能作为构造函数使用**，不能使用 new 来实例化，因为它没有自己的 this，而普通函数可以用 new 来创建新的对象。

- **箭头函数不能使用 yield 关键字**来定义生成器函数，而普通函数可以。



           



# 高级开发者相关问题【共计 16 道题】

## 57.手写 Promise , 并描述其原理与实现【JavaScript】
**回答:**      
## Primise原理与实现

目录

<!-- toc -->

- [Promise 核心](#promise-%E6%A0%B8%E5%BF%83)
- [ES6 Promise细节](#es6-promise%E7%BB%86%E8%8A%82)
- [动手实现](#%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0)
  * [内部属性](#%E5%86%85%E9%83%A8%E5%B1%9E%E6%80%A7)
  * [执行器](#%E6%89%A7%E8%A1%8C%E5%99%A8)
  * [then方法](#then%E6%96%B9%E6%B3%95)
    + [异步实现](#%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0)
    + [then 返回值](#then-%E8%BF%94%E5%9B%9E%E5%80%BC)
    + [具体代码](#%E5%85%B7%E4%BD%93%E4%BB%A3%E7%A0%81)
- [七段经典的Promise](#%E4%B8%83%E6%AE%B5%E7%BB%8F%E5%85%B8%E7%9A%84promise)
  * [demo1](#demo1)
  * [demo2](#demo2)
  * [demo3](#demo3)
  * [demo4](#demo4)
  * [demo5](#demo5)
  * [demo6](#demo6)
  * [demo7](#demo7)
- [参考文章](#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0)

<!-- tocstop -->

### Promise 核心
- Promise 概括来说是对异步的执行结果的描述对象。（这句话的理解很重要）
- Promise 规范中规定了，promise 的状态只有3种：
    - pending
    - fulfilled
    - rejected                          
    Promise 的状态一旦改变则不会再改变。
- Promise 规范中还规定了 Promise 中必须有 then 方法，这个方法也是实现异步的链式操作的基本。

## ES6 Promise细节
- Promise 构造器中必须传入函数，否则会抛出错误。(没有执行器还怎么做异步操作。。。)
- Promise.prototype上的 catch(onrejected) 方法是 then(null,onrejected) 的别名,并且会处理链之前的任何的reject。
- Promise.prototype 上的 then和 catch 方法总会返回一个全新的 Promise 对象。
- 如果传入构造器的函数中抛出了错误,该 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。
- then 中的回调如果抛出错误，返回的 promise 对象的[[PromiseStatus]]会赋值为 rejected，并且[[PromiseValue]]赋值为 Error 对象。
- then 中的回调返回值会影响 then 返回的 promise 对象。(下文会具体分析)

## 动手实现                         
做了上面的铺垫，实现一个 Promise 的思路就清晰很多了，本文使用 ES6 来进行实现，
暂且把这个类取名为 GPromise吧(不覆盖原生的，便于和原生进行对比测试)。
下文中 GPromise 代指将要实现的类，Promise 代指 ES6中的 Promise 类。

### 内部属性
在浏览器中打印出一个 Promise 实例会发现其中会包括两用”[[ ]]”包裹起来的属性，这是系统内部属性，只有JS 引擎能够访问。
```
[[PromiseStatus]]
[[PromiseValue]]
```
以上两个属性分别是 Promise 对象的状态和最终值。                

我们自己不能实现内部属性，JS中私有属性特性(#修饰符现在还是提案)暂时也没有支持，
所以暂且用”_”前缀规定私有属性，这样就模拟了Promise 中的两个内部属性。
```js
class GPromise {
        constructor(executor) {
            this._promiseStatus = GPromise.PENDING;
            this._promiseValue;
            this.execute(executor);
        }

        execute(executor){
            //...
        }

        then(onfulfilled, onrejected){
            //...
        }
    }

GPromise.PENDING = 'pedding';
GPromise.FULFILLED = 'resolved';
GPromise.REJECTED = 'rejected';
```

### 执行器
- 传入构造器的executor为函数，并且在构造时就会执行。
- 我们给 executor 中传入 resolve 和 reject 参数，这两个参数都是函数，用于改变改变 _promiseStatus和 _promiseValue 的值。
- 并且内部做了捕获异常的操作，一旦传入的executor 函数执行抛出错误，GPromise 实例会变成 rejected状态，
    即 _promiseStatus赋值为’rejected’，并且 _promiseValue赋值为Error对象。
    
```js
execute(executor) {
    if (typeof executor != 'function') {
        throw new Error(` GPromise resolver ${executor} is not a function`);
    }
    //捕获错误
    try {
        executor(data => {
            this.promiseStatus = GPromise.FULFILLED;
            this.promiseValue = data;
        }, data => {
            this.promiseStatus = GPromise.REJECTED;
            this.promiseValue = data; 
        });
    } catch (e) {
        this.promiseStatus = GPromise.REJECTED;
        this.promiseValue = e;
    }
}
```

### then方法
#### 异步实现
then 方法内部逻辑稍微复杂点，并且有一点一定一定一定要注意到: then 方法中的回调是异步执行的，思考下下段代码:
```js
console.log(1);
new Promise((resolve,reject)=>{
    console.log(2);
    resolve();
})
.then(()=>console.log(3));
console.log(4);
```
执行结果是什么呢？答案其实是:1 2 4 3。                         

then 方法中的难点就是处理异步,其中一个方案是通过 setInterval来监听GPromise 对象的状态改变，
一旦改变则执行相应then 中相应的回调函数(onfulfilled和onrejected),这样回调函数就能够插入事件队列末尾，
异步执行，实验证明可行，这种方案是最直观也最容易理解的。

#### then 返回值                                
then 方法的返回值是一个新的 GPromise 对象，并且这个对象的状态和 then 中的回调返回值相关，回调指代传入的 onfulfilled 和 rejected。 
1. 如果 then 中的回调抛出了错误，返回的 GPromise 的 _promiseStatus 赋值为’rejected’， _promiseValue赋值为抛出的错误对象。 
2. 如果回调返回了一个非 GPromise 对象， then返回的 GPromise 的 _promiseStatus 赋值为’resolved’， _promiseValue赋值为回调的返回值。 
3. 如果回调返回了一个 GPromise 对象，then返回的GPromise对象 的_promiseStatus和 _promiseValue 和其保持同步。也就是 then 返回的GPromise记录了回调返回的状态和值，不是直接返回回调的返回值。

#### 具体代码
```js
then(onfulfilled, onrejected) {
        let _ref = null,
            timer = null,
            result = new GPromise(() => {});

        //因为 promise 的 executor 是异步操作,需要监听 promise 对象状态变化，并且不能阻塞线程
        timer = setInterval(() => {
            if ((typeof onfulfilled == 'function' && this._promiseStatus == GPromise.FULFILLED) ||
                (typeof onrejected == 'function' && this._promiseStatus == GPromise.REJECTED)) {
                //状态发生变化，取消监听
                clearInterval(timer);
                //捕获传入 then 中的回调的错误，交给 then 返回的 promise 处理
                try {
                    if (this._promiseStatus == GPromise.FULFILLED) {
                        _ref = onfulfilled(this._promiseValue);
                    } else {
                        _ref = onrejected(this._promiseValue);
                    }

                    //根据回调的返回值来决定 then 返回的 GPromise 实例的状态
                    if (_ref instanceof GPromise) {
                        //如果回调函数中返回的是 GPromise 实例，那么需要监听其状态变化，返回新实例的状态是根据其变化相应的
                        timer = setInterval(()=>{
                            if (_ref._promiseStatus == GPromise.FULFILLED ||
                                _ref._promiseStatus == GPromise.REJECTED) {
                                clearInterval(timer);
                                result._promiseValue = _ref._promiseValue;
                                result._promiseStatus = _ref._promiseStatus;
                            }
                        },0);

                    } else {
                        //如果返回的是非 GPromise 实例
                        result._promiseValue = _ref;
                        result._promiseStatus = GPromise.FULFILLED;
                    }
                } catch (e) {
                    //回调中抛出错误的情况
                    result._promiseStatus = GPromise.REJECTED;
                    result._promiseValue = e;
                }
            }
        }, 0);
        //promise 之所以能够链式操作，因为返回了GPromise对象
        return result;
    }
```

## 七段经典的Promise
Promise 的 then 的 注册微任务队列 和 执行 是分离的。                         
注册 : 是完全遵循 JS 和 Promise 的代码的执行过程。                       
执行 : 先 同步，再 微任务 ，再 宏观任务。                            

### demo1
```js
/**
 * promise 是可连续执行的？
 * 是可以的！
 */

new Promise((resolve, reject) => {
  console.log(1);
  // return reject();
  return resolve();
})
    .then(() => {
      console.log(2);
    })
    .then(()=> {
      console.log(3);
    })
    .then(()=> {
      console.log(4);
    })
    .catch(()=> {
      console.log('catch');
    })
    .finally(()=> {
      console.log('finally');
    });
```

### demo2
```js
new Promise((resolve, reject) => {
  console.log(1);
  return resolve()
}).then(() => {
  console.log(2);
  // 外部第一个 then 方法里面 return 一个 Promise，这个 return ，代表 外部的第二个 then 的执行需要等待 return 之后的结果。
  return new Promise((resolve) => {
    console.log(3);

    return resolve()
  })
      .then(() => {
        console.log(4);
      })
      .then(() => {
        console.log(5);
      })
}).then(() => {
  console.log(6);
}).then(() => {
  console.log(7);
});
```


### demo3
```js
// 我们核心要看 then 的回调函数是啥时候注册的，我们知道，事件机制是 “先注册先执行”，
// 即数据结构中的 “栈” 的模式，first in first out。那么重点我们来看下他们谁先注册的。

// 外部的第二个 then 的注册，需要等待 外部的第一个 then 的同步代码执行完成。
// 当执行内部的 new Promise 的时候，然后碰到 resolve，resolve 执行完成，
// 代表此时的该 Promise 状态已经扭转，之后开始内部的第一个 .then 的微任务的注册，此时同步执行完成。
new Promise((resolve) => {
  console.log(1);
  return resolve()
}).then(() => {
  console.log(2);
  // 内部的 resolve 之后，当然是先执行内部的 new Promise 的第一个 then 的注册，这个 new Promise 执行完成，立即同步执行了后面的 .then 的注册。
  new Promise((resolve) => {
    console.log(3);
    return resolve()
  })
      .then(() => {
        console.log(4);
      })
      // 然而这个内部的第二个 then 是需要第一个 then 的的执行完成来决定的，而第一个 then 的回调是没有执行，仅仅只是执行了同步的 .then 方法的注册，所以会进入等待状态。
      .then(() => {
        console.log(5);
      })
      .then(()=> {
        console.log(6);
      })
}).then(() => {
  // 外部的第一个 then 的同步操作已经完成了，
  // 然后开始注册外部的第二个 then，此时外部的同步任务也都完成了。
  // 外部第二个 then 完成之后， 进入等待， 内部的第二个 then 注册之后在执行
  console.log(7);
}).then(() => {
  console.log(8);
}).then(()=> {
  console.log(9);
});
```


### demo4
```js
/**
 * 链式调用的注册是前后依赖的 比如上面的外部的第二个 then 的注册，是需要外部的第一个的 then 的执行完成。
 *
 * 变量定义的方式，注册都是同步的 比如这里的 p.then 和 var p = new Promise 都是同步执行的。
 */
new Promise(resolve=> {
  console.log('1');
  resolve();
})
  .then(()=> {
    console.log(2);
    const p = new Promise(resove=> {
      console.log(3);
      resove();
    });

    p.then(()=> {
      console.log(4);
    });

    p.then(()=> {
      console.log(5);
    });
  })
  .then(()=> {
    console.log(6)
  })
  .then(()=> {
    console.log(7)
  });
```

### demo5
```js
/**
 * 这段代码中，外部的注册采用了非链式调用的写法，根据上面的讲解，
 * 我们知道了外部代码的 p.then 是并列同步注册的。
 * 所以代码在内部的 new Promise 执行完，p.then 就都同步注册完了。
 *
 * 内部的第一个 then 注册之后，
 * 就开始执行外部的第二个 then 了（外部的第二个 then 和 外部的第一个 then 都是同步注册完了）。
 * 然后再依次执行内部的第一个 then ,内部的第二个 then。
 * @type {Promise}
 */
const p = new Promise(resolve => {
  console.log(1);
  resolve()
});

p.then(() => {
  console.log(2);
  new Promise(resolve => {
    console.log(3);
    resolve();
  })
    .then(() => {
      console.log(4);
    })
    .then(() => {
      console.log(5);
    })
});

p.then(() => {
  console.log(6);
});

p.then(() => {
  console.log(7)
});
```

### demo6
```js
new Promise(resolve => {
  console.log(1);
  resolve();
})
  .then(() => {
    console.log(2);
    new Promise(resolve => {
      console.log(3);
      resolve();
    })
      .then(() => {
        console.log(4);
      })
      .then(() => {
        console.log(5);
      });

    return new Promise(resolve => {
      console.log(6);
      resolve();
    })
      .then(() => {
        console.log(7);
      })
      .then(() => {
        console.log(8);
      })
  })
  .then(() => {
    console.log(9);
  })
  .then(() => {
    console.log(10);
  });
```
 
### demo7
```js
new Promise((resolve, reject) => {
  console.log('外部promise');
  resolve();
})
  .then(() => {
    console.log('外部第一个then');
    new Promise((resolve, reject) => {
      console.log('内部promise');
      resolve();
    })
      .then(() => {
        console.log('内部第一个then');
        return Promise.resolve();
      })
      .then(() => {
        console.log('内部第二个then');
      })
  })
  .then(() => {
    console.log('外部第二个then');
  })
  .then(() => {
    console.log('外部第三个then');
  })
```




## 参考文章
- [解析 Promise 原理，实现一个Promise](https://blog.csdn.net/u014775861/article/details/78030508)
- [深度揭秘 Promise 微任务注册和执行过程](https://juejin.im/post/5dc028dcf265da4d4b5fe94f)
- [Promise 执行过程的正确理解姿势](https://juejin.im/post/5dad3405f265da5bb252ff32)

           

## 62.浏览器如何解析css选择器？【浏览器】
**回答:**      
浏览器会『从右往左』解析CSS选择器。

#### CSS选择器的解析顺序
相信很多人在一开始接触CSS的时候都会看到一条规则就是尽量少使用层级关系，比如尽量不要写成：
```css
#div P.class {
    color: red;
}
```

而是写成：
```css
.class {
    color: red;
}
```
之所以需要这么写，给的解释是这样可以减少选择器匹配的次数。
初看觉得哦，有点道理啊，但是往细了再想想：
如果我把层级定的足够的清晰分明，那不是可以直接去掉很多不对应的CSS选择器的索引路径的么？为什么都是建议少使用层级关系呢？

原因其实很简单，我们犯了一个经验主义错误，默认CSS选择器是从左往右进行解析的，实际上恰恰相反，CSS选择器是从右往左解析的。

#### CSS选择器进行优化的必要性

再次看下图：                          
![img](https://img-blog.csdn.net/20160805094241153)

在图中我们可以看到HTML解析出了一颗DOM tree，与此同时样式脚本则解析生成了一个style rules，也可以说是一个CSS tree。
最后，DOM tree同style rules一同结合解析出一颗Render Tree，
而Render Tree就是包含了一个dom对象以及为其计算好的样式规则，提供了布局以及显示方法。

因为不清楚一个DOM对象上究竟对应着哪些样式规则，所以只能选择一个最笨的办法，
即每一个DOM对象都遍历一遍style rules，DOM对象的数量相信大家也都清楚，
如果每次遍历style rules都是像一个晒太阳的老大爷一样的悠哉游哉，因此对CSS选择器进行优化就是一个必须的事情了。

#### 从右往左解析到底好在哪里
假如有如下的一段HTML：
```html
<div id="div1">
    <div class="a">
        <div class="b">
            ...
        </div>
        <div class="c">
            <div class="d">
                ...
            </div>
            <div class="e">
                ...
            </div>
        </div>
    </div>
    <div class="f">
        <div class="c">
            <div class="d">
                ...
            </div>
        </div>
    </div>
</div>
```

和如下的CSS：
```css
#div1 .c .d {}
.f .c .d {}
.a .c .e {}
#div1 .f {}
.c .d{}
```

假如我们的CSS解析器是从左往右进行匹配的，那么会生成如下的style rules：
![01_47_03](https://user-images.githubusercontent.com/22188674/224469670-1156d32e-ea84-4a5a-9323-308d2db320b3.jpg)


首先，#div1 .c .d ｛｝ .f .c .d ｛｝.c .d｛｝这三个选择器里面都含有 **.c .d｛｝这么一个公用样式，**
所以哪怕是我们的DOM节点明确了是在#div1下面都必须对style rules进行全部的匹配查找，
这样一来基本上可以说是**每一个DOM节点都必须完全遍历一遍style rules**，
不然搞不好就会漏掉一些公用样式之类的，所以想着将层级写的更加详细就能去掉很多不对应的CSS选择器的索引路径的就不要想了，
不管你写的多细，你总是需要把整个style rules都遍历一遍，不然万一漏掉了某个公用样式不就思密达了？

那么如果我们换成从右向左进行解析就能够避免这种情况了么？请看下面这个style rules：                       
![01_47_04](https://user-images.githubusercontent.com/22188674/224469699-0dc5d98b-3995-4cb9-b4ae-375441dcc995.jpeg)

别的先不提，**最少这个节点就少了很多**嘛，哪怕我这里同样是需要全部遍历一遍就冲着减少了这么多个节点也要从右往左进行解析啊！                         
更重要的是，只要有公用样式，那么选择器最右边的那个类型选择器一定是相同的，如此公共样式就很自然的都集中到一个分支上，
这个时候我们**完全可以将其他不匹配的路径全部去掉而不用担心会漏掉某些个公用样式了**。
虽然当这颗CSS树在遍历的时候还有有部分节点会遍历到最后才能确定到底是不是匹配的，
但总的来说从**右往左进行解析还是会比从左往右解析要少很多次的匹配**，这样带来的效率提升是显而易见的！

同时，这也是不建议使用*通配符来进行样式匹配的原因：浏览器专门建立了一个反常规思维的从右往左的匹配规则就是为了避免对所有元素进行遍历。

最后，从右往左进行解析还有一个好处那就是从右往左进行匹配的时候，匹配的全部是DOM元素的父节点，
而从左往右进行匹配的时候时候，匹配的全部是DOM元素的子节点，这样就**避免了HTML与CSS没有下载完需要进行等待的情形**。

           

## 68.如何避免重绘或者重排？【JavaScript】
**回答:**      
## 如何触发重排和重绘
任何改变用来构建渲染树的信息都会导致一次重排或重绘：

- 添加、删除、更新DOM节点
- 通过display: none隐藏一个DOM节点-触发重排和重绘
- 通过visibility: hidden隐藏一个DOM节点-只触发重绘，因为没有几何变化
- 移动或者给页面中的DOM节点添加动画
- 添加一个样式表，调整样式属性
- 用户行为，例如调整窗口大小，改变字号，或者滚动。

## 如何避免重绘或者重排

### 集中改变样式
我们往往通过改变class的方式来集中改变样式
```js
// 判断是否是黑色系样式
const theme = isDark ? 'dark' : 'light';

// 根据判断来设置不同的class
ele.setAttribute('className', theme);
```

### 使用DocumentFragment
我们可以通过createDocumentFragment创建一个游离于DOM树之外的节点，然后在此节点上批量操作，最后插入DOM树中，因此只触发一次重排
```js
var fragment = document.createDocumentFragment();

for (let i = 0;i<10;i++){
  let node = document.createElement("p");
  node.innerHTML = i;
  fragment.appendChild(node);
}

document.body.appendChild(fragment);
```

### 提升为合成层
元素提升为合成层有以下优点：

- 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
- 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
- 对于 transform 和 opacity 效果，不会触发 layout 和 paint

提升合成层的最好方式是使用 CSS 的 will-change 属性：
```css
#target {
  will-change: transform;
}
```

           

## 69.前端如何实现即时通讯？【JavaScript】
**回答:**      
## 前端如何实现即时通讯
### 短轮询
短轮询的原理很简单，每隔一段时间客户端就发出一个请求，去获取服务器最新的数据，一定程度上模拟实现了即时通讯。

- 优点：兼容性强，实现非常简单
- 缺点：延迟性高，非常消耗请求资源，影响性能

### comet
comet有两种主要实现手段，
一种是基于 AJAX 的长轮询（long-polling）方式，
另一种是基于 Iframe 及 htmlfile 的流（streaming）方式，通常被叫做长连接。

具体两种手段的操作方法请移步 [Comet技术详解：基于HTTP长连接的Web端实时通信技术](http://www.52im.net/thread-334-1-1.html)

- 长轮询优缺点：
    - 优点：兼容性好，资源浪费较小
    - 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护

- 长连接优缺点：
    - 优点：兼容性好，消息即时到达，不发无用请求
    - 缺点：服务器维护长连接消耗资源


### SSE
SSE（Server-Sent Event，服务端推送事件）是一种允许服务端向客户端推送新数据的HTML5技术。
- 优点：基于HTTP而生，因此不需要太多改造就能使用，使用方便，而websocket非常复杂，必须借助成熟的库或框架
- 缺点：基于文本传输效率没有websocket高，不是严格的双向通信，客户端向服务端发送请求无法复用之前的连接，需要重新发出独立的请求


### Websocket
Websocket是一个全新的、独立的协议，基于TCP协议，与http协议兼容、却不会融入http协议，仅仅作为html5的一部分，其作用就是在服务器和客户端之间建立实时的双向通信。

- 优点：真正意义上的实时双向通信，性能好，低延迟
- 缺点：独立与http的协议，因此需要额外的项目改造，使用复杂度高，必须引入成熟的库，无法兼容低版本浏览器

### Web Worker
Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行

### Service workers
Service workers 本质上充当Web应用程序与浏览器之间的代理服务器，也可以在网络可用时作为浏览器和网络间的代理，创建有效的离线体验。

           

## 70.前端做错误监控？【JavaScript】
**回答:**      
## 错误监控

**错误分类**：即时运行错误（代码错误）、资源加载错误

### 错误的捕获方式：
**即时运行错误:**
try...catch                     	
window.onerror

**资源加载错误:**                                   
1)、object.onerror	                
2)、performance.getEntries()                     
3)、Error事件捕获                    
performance.getEntries()这个是可以获取到所有的家已经加载的资源

Error事件捕获使用方式:
```javascript
window.addEventListener('error',function(e){
    console.log('捕获',e)
},true)
```

跨域是可以捕获的:                            
1）、在script标签添加crossorigin属性                              
2)、在js响应头添加Access-Control-Allow-Origin:*;


上报错误：ajax通信方式上报、通过Image对象上报,非常简单                    
(new Image()).src='http://baidu.com/test/sdflijsd?=sdlfkj';                         



           

## 72.TCP 和 UDP的区别？【网络】
**回答:**      
## TCP和UDP的区别
### TCP、UDP和HTTP关系
1、TCP/IP是个协议组，可分为三个层次：网络层、传输层和应用层。

在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。                          
在传输层中有TCP协议与UDP协议。                          
在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。                           
因此，HTTP本身就是一个协议，是从Web服务器传输超文本到本地浏览器的传送协议。

TCP 是基于 TCP 协议实现的网络文本协议,属于传输层。                              
UDP 是和TCP 对等的，属于传输层，UDP 和 TCP 有重要的区别。

2、HTTP协议是建立在请求/响应模型上的。

首先由客户建立一条与服务器的TCP链接，并发送一个请求到服务器，请求中包含请求方法、URI、协议版本以及相关的MIME样式的消息。
服务器响应一个状态行，包含消息的协议版本、一个成功和失败码以及相关的MIME式样的消息。                                
HTTP/1.0为每一次HTTP的请求/响应建立一条新的TCP链接，因此一个包含HTML内容和图片的页面将需要建立多次的短期的TCP链接。一次TCP链接的建立将需要3次握手。                         
另外，为了获得适当的传输速度，则需要TCP花费额外的回路链接时间（RTT）。
每一次链接的建立需要这种经常性的开销，而其并不带有实际有用的数据，只是保证链接的可靠性，
因此HTTP/1.1提出了可持续链接的实现方法。HTTP/1.1将只建立一次TCP的链接而重复地使用它传输一系列的请求/响应消息，因此减少了链接建立的次数和经常性的链接开销。

三次握手的过程:                        
第一次握手：建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）。                                
第二次握手：服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；ACK:确认字符(Acknowledgement)                              
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1），此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。

3、结论：虽然HTTP本身是一个协议，但其最终还是基于TCP的。

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

![02-05-01](https://user-images.githubusercontent.com/22188674/224473152-067c338d-86d5-48ff-8197-85396a77b3c8.jpg)



HTTPS：（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。
即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

优点：**协议较成熟，应用广泛、基于TCP/IP，拥有TCP优点、研发成本很低，开发快速、开源软件较多**，nginx,apache,tomact等
缺点：**无状态、无连接**、只有PULL模式，不支持PUSH、数据报文较大
特性：**基于TCP/IP应用层协议、无状态，无连接**、支持C/S模式、适用于文本传输

### TCP

TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。
一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。
我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，
这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；
主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。
三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。

TCP：（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。
一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂。
建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。

优点：**可靠性 、全双工协议、开源支持多、应用较广泛、面向连接**、研发成本低、报文内容不限制（IP层自动分包，重传，不大于1452bytes）                      
缺点：操作系统：较耗内存，支持连接数有限、设计：协议较复杂，自定义应用层协议、网络：网络差情况下延迟较高、传输：效率低于UDP协议特性： 面向连接、可靠性、全双工协议、基于IP层、OSI参考模型位于传输层、适用于二进制传输

**三次握手 与 四次挥手**
当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。              
1.第一次挥手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了;                    
2.第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了;               
3.第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态;                 
4.第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。                 
至此，TCP的四次挥手就这么愉快的完成了。


### UDP
UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。
比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，
然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。
例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，
收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，
没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。
QQ就使用UDP发消息，因此有时会出现收不到消息的情况。

UDP：UDP是一个无连接协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，
并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；
在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。                               
优点：操作系统：并发高，内存消耗较低、传输：效率高，网络延迟低、传输模型简单，研发成本低                           
缺点：协议不可靠、单向协议、开源支持少、报文内容有限，不能大于1464bytes、设计：协议设计较复杂、网络：网络差，而且丢数据报文                             
特性：无连接，不可靠，基于IP协议层，OSI参考模型位于传输层，最大努力交付，适用于二进制传输


### 对比

场景  |    TCP   |    UDP
:- | :- |:-
是否连接   |  面向连接  | 面向非连接
传输可靠性 |    可靠   |   不可靠
应用场合   | 传输大量数据  |少量数据
速度      |    慢      |    快

           

## 77.虚拟 dom 原理是啥，手写一个简答的虚拟 dom 实现？【JavaScript】
**回答:**      


## vdom 概念
用JS模拟DOM结构。             
DOM变化的对比，放在JS层来做。               
提升重绘性能。

比如有abc 三个dom， 如果我们要删除b dom, 以前浏览器的做法是 全部删除abc dom ， 然后 在添加b dom 。这样做的成本会非常高。

## 用JS模拟 dom
例如下面的一个dom 结构：
```html
<ul id="list">
    <li class="item">item1</li>
    <li class="item">item2</li>
</ul>
```

这样的dom 结构，可以模拟为下面的JS :
```javascript
let dom = {
    tag: 'ul',
    attrs: {
        id: 'list'
    },
    children: [
        {
            tag: 'li',
            attrs: {className: 'item'},
            children: ['item1']
        },
        {
            tag: 'li',
            attrs: {className: 'item'},
            children: ['item2']
        }
    ]
}
```
浏览器操作dom 是花销非常大的。执行JS花销要小非常多，所以这就是为什么虚拟dom 出现的一个根本原因。

## jquery实现virtual-dom

### 一个需求场景
1、数据生成表格。 2、随便修改一个信息，表格也会跟着修改。
```html
<body>
<div id="container"></div>
<br>
<button id="btn-change">change</button>
<script>
    let data = [
        {
            name: 'yanle',
            age: '20',
            address: '重庆'
        },
        {
            name: 'yanle2',
            age: '25',
            address: '成都'
        },
        {
            name: 'yanle3',
            age: '27',
            address: '深圳'
        }
    ];

    // 渲染函数
    function render(data) {
        let $container = document.getElementById('container');
        $container.innerHTML = '';

        let $table = document.createElement('table');
        $table.setAttribute('border', true);
        $table.insertAdjacentHTML('beforeEnd', `<tr>
                                    <td>name</td>
                                    <td>age</td>
                                    <td>address</td>
                                    </tr>`);

        data.forEach(function (item) {
            $table.insertAdjacentHTML('beforeEnd',
                `<tr>
                    <td>${item.name}</td>
                    <td>${item.age}</td>
                    <td>${item.address}</td>
                </tr>`
            )
        });

        $container.appendChild($table);
    }

    // 修改信息
    let button = document.getElementById('btn-change');
    button.addEventListener('click', function () {
        data[1].name = '徐老毕';
        data[1].age = 30;
        data[1].address  = '深圳';
        render(data);
    });
    render(data);
</script>
</body>
```
实际上上面的这段代码也是不符合预期的，因为每次使用render 方法，都会全部渲染整个table, 但是并未没有只渲染我们想要的第二行。

**遇到的问题**：                  
DOM 操作是非常 "昂贵" 的， JS 运行效率高。虚拟dom 的核心就是diff算法，对比出不同的dom数据，定点渲染不同的数据。

           

## 84.手写实现 call、apply、bind？【JavaScript】
**回答:**      
## 深入 call、apply、bind实现原理
[https://www.jianshu.com/p/6a1bc149b598](https://www.jianshu.com/p/6a1bc149b598)

简单粗暴地来说，call，apply，bind是用于绑定this指向的。

## 什么是call和apply方法
我们单独看看ECMAScript规范对apply的定义，看个大概就行：                 

通过定义简单说一下call和apply方法，他们就是参数不同，作用基本相同。                      

1、每个函数都包含两个非继承而来的方法：apply()和call()。                     
2、他们的用途相同，都是在特定的作用域中调用函数。                       
3、接收参数方面不同，apply()接收两个参数，一个是函数运行的作用域(this)，另一个是参数数组。                        
4、call()方法第一个参数与apply()方法相同，但传递给函数的参数必须列举出来。                        


一个简单的demo:              
```javascript
let yanle = {
    name: 'yanle',
    sayHello: function (age) {
        console.log(`hello, i am ${this.name} and ${age} years old`);
    }
};
let lele = {
    name: 'lele'
};
yanle.sayHello(26);          // hello, i am yanle and 26 years old

yanle.sayHello.call(lele, 20);          // hello, i am lele and 20 years old
yanle.sayHello.apply(lele, [21]);       // hello, i am lele and 21 years old
```

结果都相同。从写法上我们就能看出二者之间的异同。
相同之处在于，第一个参数都是要绑定的上下文，后面的参数是要传递给调用该方法的函数的。
不同之处在于，call方法传递给调用函数的参数是逐个列出的，而apply则是要写在数组中。

总结一句话介绍call和apply                           
call()方法在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法。                           
apply()方法在使用一个指定的this值和参数值必须是数组类型的前提下调用某个函数或方法  


## 分析call和apply的原理
上面代码，我们注意到了两点：                  
1、call和apply改变了this的指向，指向到lulin                 
2、sayHello函数执行了                 

这里默认大家都对this有一个基本的了解，知道什么时候this该指向谁，
我们结合这两句话来分析这个通用函数：f.apply(o),我们直接看一本书对其中原理的解读，
具体什么书，我也不知道，参数我们先不管，先了解其中的大致原理。

![01](./img/img01.png)                          

知道了这个基本原来我们再来看看刚才jawil.sayHello.call(lulin, 24)执行的过程：                       
```javascript
// 第一步
lulin.fn = jawil.sayHello
// 第二步
lulin.fn()
// 第三步
delete lulin.fn
```

上面的说的是原理，可能你看的还有点抽象，下面我们用代码模拟实现apply一下。

## 实现aplly方法

### 模拟实现第一步
根据这个思路，我们可以尝试着去写第一版的 applyOne 函数：
```javascript
Function.prototype.applyOne = function (context) {
    context.fn = this;
    context.fn();
    delete context.fn;
};
let yanle = {
    name: 'yanle',
    sayHello: function (age) {
        console.log(`hello, i am ${this.name} and ${age} years old`);
    }
};
let lele = {
    name: 'lele'
};
yanle.sayHello.applyOne(lele);              // hello, i am lele and undefined years old
```
正好可以打印lulin而不是之前的jawil了。


### 模拟实现第二步
最一开始也讲了，apply函数还能给定参数执行函数。                  
注意：传入的参数就是一个数组，很简单，我们可以从Arguments对象中取值，
Arguments不知道是何物，赶紧补习，此文也不太适合初学者，第二个参数就是数组对象，
但是执行的时候要把数组数值传递给函数当参数，然后执行，这就需要一点小技巧。

参数问题其实很简单，我们先偷个懒，我们接着要把这个参数数组放到要执行的函数的参数里面去。
```javascript
Function.prototype.applyTwo = function(context) {
    context.fn = this;
    let args = arguments[1];
    context.fn(args.join(','));
    delete context.fn;
}
```
很简单是不是，那你就错了，数组join方法返回的是啥？                 
`typeof [1,2,3,4].join(',')//string`                        
最后是一个 "1,2,3,4" 的字符串，其实就是一个参数，肯定不行啦。

也许有人会想到用ES6的一些奇淫方法，不过apply是ES3的方法，
我们为了模拟实现一个ES3的方法，要用到ES6的方法，反正面试官也没说不准这样。
但是我们这次用eval方法拼成一个函数，类似于这样：
`eval('context.fn(' + args +')')`                   

先简单了解一下eval函数吧
定义和用法:                          
eval() 函数可计算某个字符串，并执行其中的的 JavaScript 代码。                        

语法：`eval(string)`                       
string必需。要计算的字符串，其中含有要计算的 JavaScript 表达式或要执行的语句。
该方法只接受原始字符串作为参数，如果 string 参数不是原始字符串，那么该方法将不作任何改变地返回。
因此请不要为 eval() 函数传递 String 对象来作为参数。

简单来说吧，就是用JavaScript的解析引擎来解析这一堆字符串里面的内容，这么说吧，你可以这么理解，**你把eval看成是<script>标签**。

`eval('function Test(a,b,c,d){console.log(a,b,c,d)};Test(1,2,3,4)')`就是相当于这样：                    
```html
<script>
function Test(a,b,c,d){
    console.log(a,b,c,d)
};
Test(1,2,3,4)
</script>
```

第二版代码大致如下：                  
```javascript
Function.prototype.applyTwo = function(context) {
    var args = arguments[1]; //获取传入的数组参数
    context.fn = this; //假想context对象预先不存在名为fn的属性
    var fnStr = 'context.fn(';
    for (var i = 0; i < args.length; i++) {
        fnStr += i == args.length - 1 ? args[i] : args[i] + ',';
    }
    fnStr += ')';//得到"context.fn(arg1,arg2,arg3...)"这个字符串在，最后用eval执行
    eval(fnStr); //还是eval强大
    delete context.fn; //执行完毕之后删除这个属性
}
//测试一下
var jawil = {
    name: "jawil",
    sayHello: function (age) {
         console.log(this.name,age);
     }
};

var  lulin = {
    name: "lulin",
};

jawil.sayHello.applyTwo(lulin,[24])//lulin 24
```

好像就行了是不是，其实这只是最粗糙的版本，能用，但是不完善，完成了大约百分之六七十了。


### 模拟实现第三步
1.this参数可以传null或者不传，当为null的时候，视为指向window             

demo1:
```javascript
var name = 'jawil';
function sayHello() {
    console.log(this.name);
}
sayHello.apply(null); // 'jawil'
```
demo2:                                  
```javascript
var name = 'jawil';
function sayHello() {
    console.log(this.name);
}
sayHello.apply(); // 'jawil'
```

2.函数是可以有返回值的         
```javascript
var obj = {
    name: 'jawil'
}

function sayHello(age) {
    return {
        name: this.name,
        age: age
    }
}

console.log(sayHello.apply(obj,[24]));// {name: "jawil", age: 24}
```

这些都是小问题，想到了，就很好解决。我们来看看此时的第三版apply模拟方法。
```javascript
//原生JavaScript封装apply方法，第三版
Function.prototype.applyThree = function(context) {
    var context = context || window
    var args = arguments[1] //获取传入的数组参数
    context.fn = this //假想context对象预先不存在名为fn的属性
    if (args == void 0) { //没有传入参数直接执行
        return context.fn()
    }
    var fnStr = 'context.fn('
    for (var i = 0; i < args.length; i++) {
        //得到"context.fn(arg1,arg2,arg3...)"这个字符串在，最后用eval执行
        fnStr += i == args.length - 1 ? args[i] : args[i] + ','
    }
    fnStr += ')'
    var returnValue = eval(fnStr) //还是eval强大
    delete context.fn //执行完毕之后删除这个属性
    return returnValue
}
```


### 模拟实现第四步
其实一开始就埋下了一个隐患，我们看看这段代码：                     
```javascript
Function.prototype.applyThree = function(context) {
    var context = context || window
    var args = arguments[1] //获取传入的数组参数
    context.fn = this //假想context对象预先不存在名为fn的属性
    ......
}
```
就是这句话， `context.fn = this //假想context对象预先不存在名为fn的属性` ,这就是一开始的隐患,
我们只是假设，但是并不能防止contenx对象一开始就没有这个属性，要想做到完美，就要保证这个context.fn中的fn的唯一性。

于是我自然而然的想到了强大的ES6,这玩意还是好用啊，幸好早就了解并一直在使用ES6,还没有学习过ES6的童鞋赶紧学习一下，没有坏处的。

重新复习下新知识：                       
基本数据类型有6种：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。

ES5对象属性名都是字符串容易造成属性名的冲突。
```javascript
var a = { name: 'jawil'};
a.name = 'lulin';
//这样就会重写属性
```

ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。                
注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象                     
Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。                       

```javascript
// 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();
s1 === s2 // false

// 有参数的情况
var s1 = Symbol("foo");
var s2 = Symbol("foo");
s1 === s2 // false
```
注意：Symbol值不能与其他类型的值进行运算。                    

作为属性名的Symbol
```javascript
var mySymbol = Symbol();

// 第一种写法
var a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
var a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
var a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```
注意，Symbol值作为对象属性名时，不能用点运算符。

继续看下面这个例子：
```javascript
var a = {};
var name = Symbol();
a.name = 'jawil';
a[name] = 'lulin';
console.log(a.name,a[name]);             //jawil,lulin
```
Symbol值作为属性名时，该属性还是公开属性，不是私有属性。                                                 
这个有点类似于java中的protected属性
（protected和private的区别：在类的外部都是不可以访问的，在类内的子类可以继承protected不可以继承private）                            
但是这里的Symbol在类外部也是可以访问的，只是不会出现在for...in、for...of循环中，
也不会被Object.keys()、Object.getOwnPropertyNames()返回。
但有一个 `Object.getOwnPropertySymbols` 方法，可以获取指定对象的所有Symbol属性名。                            

看看第四版的实现demo，想必大家了解上面知识已经猜得到怎么写了，很简单。
直接加个var fn = Symbol()就行了
```javascript
//原生JavaScript封装apply方法，第四版
Function.prototype.applyFour = function(context) {
    var context = context || window
    var args = arguments[1] //获取传入的数组参数
    var fn = Symbol()
    context[fn] = this //假想context对象预先不存在名为fn的属性
    if (args == void 0) { //没有传入参数直接执行
        return context[fn]()
    }
    var fnStr = 'context[fn]('
    for (var i = 0; i < args.length; i++) {
        //得到"context.fn(arg1,arg2,arg3...)"这个字符串在，最后用eval执行
        fnStr += i == args.length - 1 ? args[i] : args[i] + ','
    }
    fnStr += ')'
    var returnValue = eval(fnStr) //还是eval强大
    delete context[fn] //执行完毕之后删除这个属性
    return returnValue
}
```

### 模拟实现第五步
呃呃呃额额，慢着，ES3就出现的方法，你用ES6来实现，你好意思么？
你可能会说，不管黑猫白猫，只要能抓住老鼠的猫就是好猫，面试官直说不准用call和apply方法但是没说不准用ES6语法啊。                           
反正公说公有理婆说婆有理，这里还是不用Symbol方法实现一下，我们知道，ES6其实都是语法糖，ES6能写的，
咋们ES5都能实现，这就导致了babel这类把ES6语法转化成ES5的代码了。                                 
至于babel把Symbol属性转换成啥代码了，我也没去看，有兴趣的可以看一下稍微研究一下，这里我说一下简单的模拟。                                      
ES5 没有 Sybmol，属性名称只可能是一个字符串，如果我们能做到这个字符串不可预料，
那么就基本达到目标。要达到不可预期，一个随机数基本上就解决了。                                 
```javascript
//简单模拟Symbol属性
function jawilSymbol(obj) {
    var unique_proper = "00" + Math.random();
    if (obj.hasOwnProperty(unique_proper)) {
        arguments.callee(obj)//如果obj已经有了这个属性，递归调用，直到没有这个属性
    } else {
        return unique_proper;
    }
}
//原生JavaScript封装apply方法，第五版
Function.prototype.applyFive = function(context) {
    var context = context || window
    var args = arguments[1] //获取传入的数组参数
    var fn = jawilSymbol(context);
    context[fn] = this //假想context对象预先不存在名为fn的属性
    if (args == void 0) { //没有传入参数直接执行
        return context[fn]()
    }
    var fnStr = 'context[fn]('
    for (var i = 0; i < args.length; i++) {
        //得到"context.fn(arg1,arg2,arg3...)"这个字符串在，最后用eval执行
        fnStr += i == args.length - 1 ? args[i] : args[i] + ','
    }
    fnStr += ')'
    var returnValue = eval(fnStr) //还是eval强大
    delete context[fn] //执行完毕之后删除这个属性
    return returnValue
};
var obj = {
    name: 'jawil'
}
function sayHello(age) {
    return {
        name: this.name,
        age: age
    }
}
console.log(sayHello.applyFive(obj,[24]));// 完美输出{name: "jawil", age: 24}
```


## 实现Call方法
这个不需要讲了吧，道理都一样，就是参数一样，这里我给出我实现的一种方式，看不懂，自己写一个去。
```javascript
//原生JavaScript封装call方法
Function.prototype.callOne = function(context) {
    return this.applyFive(([].shift.applyFive(arguments), arguments));
    //巧妙地运用上面已经实现的applyFive函数
}
```
看不太明白也不能怪我咯，我就不细讲了，看个demo证明一下，这个写法没问题。
```javascript
Function.prototype.applyFive = function(context) {//刚才写的一大串}
Function.prototype.callOne = function(context) {
    return this.applyFive(([].shift.applyFive(arguments)), arguments)
    //巧妙地运用上面已经实现的applyFive函数
};
//测试一下
var obj = {
    name: 'jawil'
};

function sayHello(age) {
    return {
        name: this.name,
        age: age
    }
}
console.log(sayHello.callOne(obj,24));// 完美输出{name: "jawil", age: 24}
```

## 实现bind方法
什么是bind函数               
如果掌握了上面实现apply的方法，我想理解起来模拟实现bind方法也是轻而易举，原理都差不多，我们还是来看看bind方法的定义。                       
我们还是简单的看下ECMAScript规范对bind方法的定义，暂时看不懂不要紧，获取几个关键信息就行。                            

bind() 方法会创建一个新函数，当这个新函数被调用时，它的 this 值是传递给 bind() 的第一个参数, 
它的参数是 bind() 的其他参数和其原本的参数，
bind返回的绑定函数也能使用new操作符创建对象：这种行为就像把原函数当成构造器。
提供的this值被忽略，同时调用时的参数被提供给模拟函数。。

语法是这样样子的： `fun.bind(thisArg[, arg1[, arg2[, ...]]])`

是不是似曾相识，这不是call方法的语法一个样子么，，，但它们是一样的吗？

bind方法传递给调用函数的参数可以逐个列出，也可以写在数组中。
bind方法与call、apply最大的不同就是前者返回一个绑定上下文的函数，
而后两者是直接执行了函数。由于这个原因，上面的代码也可以这样写:
```javascript
jawil.sayHello.bind(lulin)(24); //hello, i am lulin 24 years old
jawil.sayHello.bind(lulin)([24]); //hello, i am lulin 24 years old
```

bind方法还可以这样写 fn.bind(obj, arg1)(arg2).

**用一句话总结bind的用法：**
该方法创建一个新函数，称为绑定函数，绑定函数会以创建它时传入bind方法的第一个参数作为this，
传入bind方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。

以前解决这个问题的办法通常是缓存this，例如：
```javascript
function Person(name){
  this.nickname = name;
  this.distractedGreeting = function() {
    var self = this; // <-- 注意这一行!
    setTimeout(function(){
      console.log("Hello, my name is " + self.nickname); // <-- 还有这一行!
    }, 500);
  }
}
 
var alice = new Person('jawil');
alice.distractedGreeting();
// after 500ms logs "Hello, my name is jawil"
```

但是现在有一个更好的办法！您可以使用bind。上面的例子中被更新为：
```javascript
function Person(name){
  this.nickname = name;
  this.distractedGreeting = function() {
    setTimeout(function(){
      console.log("Hello, my name is " + this.nickname);
    }.bind(this), 500); // <-- this line!
  }
}
 
var alice = new Person('jawil');
alice.distractedGreeting();
// after 500ms logs "Hello, my name is jawil"
```

**用法总结：**                   
bind() 最简单的用法是创建一个函数，使这个函数不论怎么调用都有同样的 this 值。
JavaScript新手经常犯的一个错误是将一个方法从对象中拿出来，然后再调用，希望方法中的 this 是原来的对象。
（比如在回调中传入这个方法。）如果不做特殊处理的话，一般会丢失原来的对象。
从原来的函数和原来的对象创建一个绑定函数，则能很漂亮地解决这个问题：
```javascript
this.x = 9; 
var module = {
  x: 81,
  getX: function() { return this.x; }
};
 
module.getX(); // 81
 
var getX = module.getX;
getX(); // 9, 因为在这个例子中，"this"指向全局对象
 
// 创建一个'this'绑定到module的函数
var boundGetX = getX.bind(module);
boundGetX(); // 81
```
备注：                     
很不幸，Function.prototype.bind 在IE8及以下的版本中不被支持，
所以如果你没有一个备用方案的话，可能在运行时会出现问题。
bind 函数在 ECMA-262 第五版才被加入；它可能无法在所有浏览器上运行。
你可以部份地在脚本开头加入以下代码，就能使它运作，让不支持的浏览器也能使用 bind() 功能。

### 初级实现
了解了以上内容，我们来实现一个初级的bind函数Polyfill:                   
```javascript
Function.prototype.bind = function (context) {
    var me = this;
    var argsArray = Array.prototype.slice.callOne(arguments);
    return function () {
        return me.applyFive(context, argsArray.slice(1))
    }
}
```
简单解读：
基本原理是使用apply进行模拟。函数体内的this，就是需要绑定this的实例函数，或者说是原函数。
最后我们使用apply来进行参数（context）绑定，并返回。                
同时，将第一个参数（context）以外的其他参数，作为提供给原函数的预设参数，这也是基本的“颗粒化（curring）”基础。                             


### 初级实现的加分项
进行兼容处理，就是锦上添花了。
```javascript
Function.prototype.bind = Function.prototype.bind || function (context) {
    ...
}
```

### 颗粒化（curring）实现
对于函数的柯里化不太了解的童鞋，可以先尝试读读这篇文章：[前端基础进阶（八）：深入详解函数的柯里化](https://www.jianshu.com/p/5e1899fe7d6b)。                           
上述的实现方式中，我们返回的参数列表里包含：atgsArray.slice(1)，他的问题在于存在预置参数功能丢失的现象。                           
想象我们返回的绑定函数中，如果想实现预设传参（就像bind所实现的那样），就面临尴尬的局面。真正实现颗粒化的“完美方式”是：                          
```javascript
Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.callOne(arguments, 1);
    return function () {
        var innerArgs = Array.prototype.slice.callOne(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.applyFive(context, finalArgs);
    }
}
```

### 构造函数场景下的兼容
```javascript
Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.callOne(arguments, 1);
    var F = function () {};
    F.prototype = this.prototype;
    var bound = function () {
        var innerArgs = Array.prototype.slice.callOne(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.apply(this instanceof F ? this : context || this, finalArgs);
    }
    bound.prototype = new F();
    return bound;
}
```


### 更严谨的做法
我们需要调用bind方法的一定要是一个函数，所以可以在函数体内做一个判断：
```javascript
if (typeof this !== "function") {
  throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
}
```
做到所有这一切，基本算是完成了。其实MDN上有个自己实现的polyfill，就是如此实现的。
另外，《JavaScript Web Application》一书中对bind()的实现，也是如此。


### 最终答案
```javascript
//简单模拟Symbol属性
function jawilSymbol(obj) {
    var unique_proper = "00" + Math.random();
    if (obj.hasOwnProperty(unique_proper)) {
        arguments.callee(obj)//如果obj已经有了这个属性，递归调用，直到没有这个属性
    } else {
        return unique_proper;
    }
}
//原生JavaScript封装apply方法，第五版
Function.prototype.applyFive = function(context) {
    var context = context || window
    var args = arguments[1] //获取传入的数组参数
    var fn = jawilSymbol(context);
    context[fn] = this //假想context对象预先不存在名为fn的属性
    if (args == void 0) { //没有传入参数直接执行
        return context[fn]()
    }
    var fnStr = 'context[fn]('
    for (var i = 0; i < args.length; i++) {
        //得到"context.fn(arg1,arg2,arg3...)"这个字符串在，最后用eval执行
        fnStr += i == args.length - 1 ? args[i] : args[i] + ','
    }
    fnStr += ')'
    var returnValue = eval(fnStr) //还是eval强大
    delete context[fn] //执行完毕之后删除这个属性
    return returnValue
}
//简单模拟call函数
Function.prototype.callOne = function(context) {
    return this.applyFive(([].shift.applyFive(arguments)), arguments)
    //巧妙地运用上面已经实现的applyFive函数
}

//简单模拟bind函数
Function.prototype.bind = Function.prototype.bind || function (context) {
    var me = this;
    var args = Array.prototype.slice.callOne(arguments, 1);
    var F = function () {};
    F.prototype = this.prototype;
    var bound = function () {
        var innerArgs = Array.prototype.slice.callOne(arguments);
        var finalArgs = args.concat(innerArgs);
        return me.applyFive(this instanceof F ? this : context || this, finalArgs);
    }
    bound.prototype = new F();
    return bound;
}
var obj = {
    name: 'jawil'
}

function sayHello(age) {
    return {
        name: this.name,
        age: age
    }
}

console.log(sayHello.bind(obj,24)());// 完美输出{name: "jawil", age: 24}
```


































      



           

## 85.知道 JS 中的尾调用吗，如何做尾调优化？【JavaScript】
**回答:**      
## 深入理解 JavaScript 中的尾调用

[es6 javascript 尾调用](https://blog.csdn.net/qq_30100043/article/details/53406001)                                                 
[深入理解JavaScript中的尾调用(Tail Call)](https://www.jb51.net/article/104875.htm)                           


### 1、什么是尾调用

尾调用是函数式编程里比较重要的一个概念，尾调用的概念非常简单，
一句话就能说清楚，它的意思是在函数的执行过程中，如果最后一个动作是一个函数的调用，
即这个调用的返回值被当前函数直接返回，则称为尾调用。
```javascript
function f(x){
	return g(x);
}
```

上面代码中，函数 f 的最后一步是调用函数 g ，这就叫尾调用。**以下三种情况，都不属于尾调用。**                     
```javascript
//  情况一
function f(x){
	let y = g(x);
	return y;
}
//  情况二
function f(x){
	return g(x) + 1;
}
//  情况三
function f(x){
	g(x);
}
```
上面代码中，情况一是调用函数 g 之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。
```javascript
function f(x){
	g(x);
	return undefined;
}
```

尾调用不一定出现在函数尾部，只要是最后一步操作即可。
```javascript
function f(x) {
	if (x > 0) {
		return m(x)
	}
	return n(x);
}
```
上面代码中，函数 m 和 n 都属于尾调用，因为它们都是函数 f 的最后一步操作。


### 2、尾调用优化
尾调用之所以与其他调用不同，就在于它的特殊的调用位置。                         

我们知道，函数调用会在内存形成一个 “ 调用记录 ” ，又称 “ 调用帧 ” （ call frame ），保存调用位置和内部变量等信息。
如果在函数 A 的内部调用函数 B ，那么在 A 的调用帧上方，还会形成一个 B 的调用帧。
等到 B 运行结束，将结果返回到 A ， B 的调用帧才会消失。
如果函数 B 内部还调用函数 C ，那就还有一个 C 的调用帧，以此类推。
所有的调用帧，就形成一个 “ 调用栈 ” （ call stack ）。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，
因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。                             
```javascript
function f() {
	let m = 1;
	let n = 2;
	return g(m + n);
}
f();
//  等同于
function f() {
	return g(3);
}
f();
//  等同于
g(3);
```
上面代码中，如果函数 g 不是尾调用，函数 f 就需要保存内部变量 m 和 n 的值、 g 的调用位置等信息。
但由于调用 g 之后，函数 f 就结束了，所以执行到最后一步，完全可以删除 f(x)  的调用帧，只保留 g(3)  的调用帧。                        

这就叫做 “ 尾调用优化 ” （ Tail call optimization ），即只保留内层函数的调用帧。
如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是 “ 尾调用优化 ” 的意义。                           

注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行 “ 尾调用优化 ” 。
```javascript
function addOne(a){
	var one = 1;
	function inner(b){
		return b + one;
	}
	return inner(a);
}
```
上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。

### 3、尾递归
函数调用自身，称为递归。如果尾调用自身，就称为尾递归。
递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生 “ 栈溢出 ” 错误（ stack overflow ）。
但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生 “ 栈溢出 ” 错误。
```javascript
function factorial(n) {
	if (n === 1) return 1;
	return n * factorial(n - 1);
}
factorial(5) // 120
```
上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用记录，复杂度 O(n)  。                 

如果改写成尾递归，只保留一个调用记录，复杂度 O(1)  。                  
```javascript
function factorial(n, total) {
	if (n === 1) return total;
	return factorial(n - 1, n * total);
}
factorial(5, 1) // 120
```

还有一个比较著名的例子，就是计算 fibonacci（斐波那契）  数列，也能充分说明尾递归优化的重要性
如果是非尾递归的 fibonacci  递归方法
```javascript
function Fibonacci (n) {
	if ( n <= 1 ) {return 1};
	return Fibonacci(n - 1) + Fibonacci(n - 2);
}
Fibonacci(10); // 89
// Fibonacci(100)
// Fibonacci(500)
//  堆栈溢出了
```

如果我们使用尾递归优化过的 fibonacci  递归算法                   
```javascript
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
	if( n <= 1 ) {return ac2};
	return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}
Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
```
由此可见， “ 尾调用优化 ” 对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。
ES6 也是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署 “ 尾调用优化 ” 。这就是说，在 ES6 中，只要使用尾递归，就不会发生栈溢出，相对节省内存。
 
### 4、递归函数的改写
尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。
比如上面的例子，阶乘函数 factorial  需要用到一个中间变量 total  ，那就把这个中间变量改写成函数的参数。
这样做的缺点就是不太直观，第一眼很难看出来，为什么计算 5 的阶乘，需要传入两个参数 5 和 1 ？

两个方法可以解决这个问题。
**方法一是在尾递归函数之外，再提供一个正常形式的函数。**
```javascript
function tailFactorial(n, total) {
	if (n === 1) return total;
	return tailFactorial(n - 1, n * total);
}
function factorial(n) {
	return tailFactorial(n, 1);
}
factorial(5) // 120
```
上面代码通过一个正常形式的阶乘函数 factorial  ，调用尾递归函数 tailFactorial  ，看起来就正常多了。

函数式编程有一个概念，**叫做柯里化（ currying ）**，意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。
```javascript
function currying(fn, n) {
	return function (m) {
		return fn.call(this, m, n);
	};
}
function tailFactorial(n, total) {
	if (n === 1) return total;
	return tailFactorial(n - 1, n * total);
}
const factorial = currying(tailFactorial, 1);
factorial(5) // 120
```
上面代码通过柯里化，将尾递归函数 tailFactorial  变为只接受 1 个参数的 factorial  。


**第二种方法就简单多了，就是采用 ES6 的函数默认值。**                     
```javascript
function factorial(n, total = 1) {
	if (n === 1) return total;
	return factorial(n - 1, n * total);
}
factorial(5) // 120
```
上面代码中，参数 total  有默认值 1 ，所以调用时不用提供这个值。                           

总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。
对于其他支持 “ 尾调用优化 ” 的语言（比如 Lua ， ES6 ），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。


### 5、严格模式
ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。                           
这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。                            
func.arguments：返回调用时函数的参数。                          
func.caller：返回调用当前函数的那个函数。                          
尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。                           
```javascript
function restricted() {
	"use strict";
	restricted.caller; //  报错
	restricted.arguments; //  报错
}
restricted();
```

### 6、尾递归优化的实现
尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。                        
它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。
怎么做可以减少调用栈呢？就是采用 “ 循环 ” 换掉 “ 递归 ” 。                     

下面是一个正常的递归函数。                       
```javascript
function sum(x, y) {
	if (y > 0) {
		return sum(x + 1, y - 1);
	} else {
		return x;
	}
}
sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
```

上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。
一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。
**蹦床函数(trampoline)** 可以将递归执行转为循环执行。                        
```javascript
function trampoline(f) {
	while (f && f instanceof Function) {
		f = f();
	}
	return f;
}
```
上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。
注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。

然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。
```javascript
function sum(x, y) {
	if (y > 0) {
		return sum.bind(null, x + 1, y - 1);
	} else {
		return x;
	}
}
```
上面代码中，sum函数的每次执行，都会返回自身的另一个版本。
现在，使用蹦床函数执行sum，就不会发生调用栈溢出。


```javascript
trampoline(sum(1, 100000))
// 100001
//蹦床函数并不是真正的尾递归优化，下面的实现才是。
function tco(f) {
	var value;
	var active = false;
	var accumulated = [];
	return function accumulator() {
		accumulated.push(arguments);
		if (!active) {
			active = true;
			while (accumulated.length) {
				value = f.apply(this, accumulated.shift());
			}
			active = false;
			return value;
		}
	};
}
var sum = tco(function(x, y) {
	if (y > 0) {
		return sum(x + 1, y - 1)
	}else {
		return x
	}
});
sum(1, 100000)
// 100001
```
上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。
默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。
然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；
而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。
这样就很巧妙地将 “ 递归 ” 改成了 “ 循环 ” ，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。

           

## 88.从浏览器地址栏输入url到显示页面所经历的流程有哪些(以HTTP为例)？【浏览器】
**回答:**      
1. 在浏览器地址栏输入URL
   
2. 浏览器查看**缓存**，如果请求资源在缓存中并且新鲜，跳转到转码步骤
   
  1. 如果资源未缓存，发起新请求
     
  2. 如果已缓存，检验是否足够新鲜，足够新鲜直接提供给客户端，否则与服务器进行验证。
     
  3. 检验新鲜通常有两个HTTP头进行控制`Expires`和`Cache-Control`：
    - HTTP1.0提供Expires，值为一个绝对时间表示缓存新鲜日期
    - HTTP1.1增加了Cache-Control: max-age=,值为以秒为单位的最大新鲜时间
     
3. 浏览器**解析URL**获取协议，主机，端口，path
   
4. 浏览器**组装一个HTTP（GET）请求报文**
   
5. 浏览器**获取主机ip地址**，过程如下：
   
  1. 浏览器缓存
     
  2. 本机缓存
     
  3. hosts文件
     
  4. 路由器缓存
     
  5. ISP DNS缓存
     
  6. DNS递归查询（可能存在负载均衡导致每次IP不一样）
     
6. **打开一个socket与目标IP地址，端口建立TCP链接**，三次握手如下：
   
  1. 客户端发送一个TCP的**SYN=1，Seq=X**的包到服务器端口
     
  2. 服务器发回**SYN=1， ACK=X+1， Seq=Y**的响应包
     
  3. 客户端发送**ACK=Y+1， Seq=Z**
     
7. TCP链接建立后**发送HTTP请求**
   
8. 服务器接受请求并解析，将请求转发到服务程序，如虚拟主机使用HTTP Host头部判断请求的服务程序
   
9. 服务器检查**HTTP请求头是否包含缓存验证信息**如果验证缓存新鲜，返回**304**等对应状态码
   
10. 处理程序读取完整请求并准备HTTP响应，可能需要查询数据库等操作
    
11. 服务器将**响应报文通过TCP连接发送回浏览器**
    
12. 浏览器接收HTTP响应，然后根据情况选择**关闭TCP连接或者保留重用，关闭TCP连接的四次握手如下**：
    
  1. 主动方发送**Fin=1， Ack=Z， Seq= X**报文
     
  2. 被动方发送**ACK=X+1， Seq=Z**报文
     
  3. 被动方发送**Fin=1， ACK=X， Seq=Y**报文
     
  4. 主动方发送**ACK=Y， Seq=X**报文
     
13. 浏览器检查响应状态吗：是否为1XX，3XX， 4XX， 5XX，这些情况处理与2XX不同
    
14. 如果资源可缓存，**进行缓存**
    
15. 对响应进行**解码**（例如gzip压缩）
    
16. 根据资源类型决定如何处理（假设资源为HTML文档）
    
17. **解析HTML文档，构件DOM树，下载资源，构造CSSOM树，执行js脚本**，这些操作没有严格的先后顺序，以下分别解释
    
18. **构建DOM树**：
    
  1. **Tokenizing**：根据HTML规范将字符流解析为标记
     
  2. **Lexing**：词法分析将标记转换为对象并定义属性和规则
     
  3. **DOM construction**：根据HTML标记关系将对象组成DOM树
     
19. 解析过程中遇到图片、样式表、js文件，**启动下载**
    
20. 构建**CSSOM树**：
    
  1. **Tokenizing**：字符流转换为标记流
     
  2. **Node**：根据标记创建节点
     
  3. **CSSOM**：节点创建CSSOM树
     
21. **[根据DOM树和CSSOM树构建渲染树](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction)**:
    
  1. 从DOM树的根节点遍历所有**可见节点**，不可见节点包括：1）`script`,`meta`这样本身不可见的标签。2)被css隐藏的节点，如`display: none`
     
  2. 对每一个可见节点，找到恰当的CSSOM规则并应用
     
  3. 发布可视节点的内容和计算样式
     
22. **js解析如下**：
    
  1. 浏览器创建Document对象并解析HTML，将解析到的元素和文本节点添加到文档中，此时**document.readystate为loading**
     
  2. HTML解析器遇到**没有async和defer的script时**，将他们添加到文档中，然后执行行内或外部脚本。
     这些脚本会同步执行，并且在脚本下载和执行时解析器会暂停。
     这样就可以用document.write()把文本插入到输入流中。
     **同步脚本经常简单定义函数和注册事件处理程序，他们可以遍历和操作script和他们之前的文档内容**
     
  3. 当解析器遇到设置了**async**属性的script时，开始下载脚本并继续解析文档。
     脚本会在它**下载完成后尽快执行**，但是**解析器不会停下来等它下载**。
     异步脚本**禁止使用document.write()**，它们可以访问自己script和之前的文档元素
     
  4. 当文档完成解析，document.readState变成interactive
     
  5. 所有**defer**脚本会**按照在文档出现的顺序执行**，延迟脚本**能访问完整文档树**，禁止使用document.write()
     
  6. 浏览器**在Document对象上触发DOMContentLoaded事件**
     
  7. 此时文档完全解析完成，浏览器可能还在等待如图片等内容加载，
     等这些**内容完成载入并且所有异步脚本完成载入和执行**，document.readState变为complete,window触发load事件
     
23. **显示页面**（HTML解析过程中会逐步显示页面）

           

## 89.从哪些方面可以对网站性能优化？【浏览器】
**回答:**      
- content方面
    1. 减少HTTP请求：合并文件、CSS精灵、inline Image
    2. 减少DNS查询：DNS查询完成之前浏览器不能从这个主机下载任何任何文件。方法：DNS缓存、将资源分布到恰当数量的主机名，平衡并行下载和DNS查询
    3. 避免重定向：多余的中间访问
    4. 使Ajax可缓存
    5. 非必须组件延迟加载
    6. 未来所需组件预加载
    7. 减少DOM元素数量
    8. 将资源放到不同的域下：浏览器同时从一个域下载资源的数目有限，增加域可以提高并行下载量
    9. 减少iframe数量
    10. 不要404

- Server方面
    1. 使用CDN
    2. 添加Expires或者Cache-Control响应头
    3. 对组件使用Gzip压缩
    4. 配置ETag
    5. Flush Buffer Early
    6. Ajax使用GET进行请求
    7. 避免空src的img标签
    
- Cookie方面
    1. 减小cookie大小
    2. 引入资源的域名不要包含cookie
    
- css方面
    1. 将样式表放到页面顶部
    2. 不使用CSS表达式
    3. 使用<link>不使用@import
    4. 不使用IE的Filter
    
- Javascript方面
    1. 将脚本放到页面底部
    2. 将javascript和css从外部引入
    3. 压缩javascript和css
    4. 删除不需要的脚本
    5. 减少DOM访问
    6. 合理设计事件监听器
    
- 图片方面
    1. 优化图片：根据实际颜色需要选择色深、压缩
    2. 优化css精灵
    3. 不要在HTML中拉伸图片
    4. 保证favicon.ico小并且可缓存
    
- 移动方面
    1. 保证组件小于25k
    2. Pack Components into a Multipart Document

           

## 90.redux-thunk 和 redux 是什么关系？【web框架】
**回答:**      
## 理解redux和redux的中间件redux-thunk

目录
- [Action的认识](#Action的认识)
- [Reducer的认识](#Reducer的认识)
- [Store的认识](#Store的认识)
- [上面三者的使用案例](#上面三者的使用案例)
- [Action创建函数](#Action创建函数)
- [redux-thunk中间件的认识](#redux-thunk中间件的认识)
- [参考文章](#参考文章)



## Action的认识
简单点说Action就是一个对象，一个必须带key为type的对象[value是自己定义的]，其他的key就根据用户自己喜好自己定义:                      
以下都是action的定义 
```
1、{type:”ADD”}
2、{type:”ADD”,key1:”“,key2:”“}
```

## Reducer的认识
别主观意识就是类似数组中的reduce，也不是只能定义reducer，它仅仅是一个称呼，纯函数，
函数名次自己随便定义都可以，但是函数的参数只能是**state与action**,
可以简单的理解为一个工厂函数，传递一个旧的state通过加工后产出一个新的state：
简单的代码如下：                    
```js
function count(state = 0, action) {
    switch (action.type) {
        case 'ADD':
            return state + 1;
        case 'REDUCER':
            return state - 1;
        default:
            return state;
    }
}
```
如果当state是对象的时候上面的代码是错误的:                                
redux里面规定state是不能修改的。                               
在javascript中对象是引用数据类型，当你修改了state的时候，变化前后的两个state将会指向同一个地址的，react-redux就会以为这两个相同的state，因为不会执行渲染                              
解决办法，我们用Object.assign去处理，如有不清楚Object.assign，请参考Object.assign文档                              

## Store的认识
store是一个全局对象，将action和reducer以及state联系在一起，主要职责:                                      
维护应用的state                                      
提供getState()方法获取state                                       
提供dispatch(action)方法更新state                                     
通过subscribe(方法)注册监听器                                        

## 上面三者的使用案例
```js
'use strict';
import {createStore} from 'redux';
function count(state = 0, action) {
    switch (action.type) {
        case 'ADD':
            return state + 1;
        case 'REDUCER':
            return state - 1;
        default:
            return state
    }
}

let store = createStore(count);

let currentValue = store.getState();
console.log('当前的值:', currentValue);

//定义一个监听的方法
let listener = () => {
    const previosValue = currentValue;
    currentValue = store.getState();
    console.log('上一个值:', previosValue, '当前值:', currentValue)
};
//创建一个监听
store.subscribe(listener);
//分发任务
store.dispatch({type:"ADD"});
store.dispatch({type:"ADD"});
store.dispatch({type:"ADD"});
store.dispatch({type:"REDUCER"});
```

## Action创建函数
上面我们说的action是一个对象，只是含有type的key的对象                           
action创建函数的意思就是创建一个action的函数，函数返回一个对象                           
```js
function add(){
    return{
        type:"ADD",
    }
}
function reducer() {
    return{
        type:"REDUCER",
    }
}
```
使用的时候直接store.dispatch(add());就可以                        

action创建函数的意义:                      
action创建函数表面是返回一个对象                             
真正的意义在于逻辑的封装                                


## redux-thunk中间件的认识
redux-thunk中间件可以让action创建函数先不返回一个action对象，而是返回一个函数，
函数传递两个参数(dispatch,getState),在函数体内进行业务逻辑的封装
```js
function add() {
    return {
        type: 'ADD',
    }
}
function addIfOdd() {
    return (dispatch, getState) => {
        const currentValue = getState();
        if (currentValue % 2 == 0) {
            return false;
        }
        //分发一个任务
        dispatch(add())
    }
}
```



## 参考文章
- [理解redux和redux的中间件redux-thunk的认识](https://blog.csdn.net/kuangshp128/article/details/67632683)

           

## 91.Iterator 和 for...of 了解多少？【JavaScript】
**回答:**      
## Iterator 和 for...of 循环

<!-- toc -->

- [1、Iterator 的概念](#1iterator-%E7%9A%84%E6%A6%82%E5%BF%B5)
- [2、数据结构的默认 Iterator 接口](#2%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E9%BB%98%E8%AE%A4-iterator-%E6%8E%A5%E5%8F%A3)
- [3、调用 Iterator 接口的场合](#3%E8%B0%83%E7%94%A8-iterator-%E6%8E%A5%E5%8F%A3%E7%9A%84%E5%9C%BA%E5%90%88)
  * [3.1、解构赋值](#31%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC)
  * [3.2、扩展运算符](#32%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6)
  * [3.3、yield*](#33yield)
  * [3.4、其他场合](#34%E5%85%B6%E4%BB%96%E5%9C%BA%E5%90%88)
- [4、Iterator 接口与 Generator 函数](#4iterator-%E6%8E%A5%E5%8F%A3%E4%B8%8E-generator-%E5%87%BD%E6%95%B0)
- [5、for...of 循环 - 重点！！！](#5forof-%E5%BE%AA%E7%8E%AF-------%E9%87%8D%E7%82%B9)
  * [5.1、数组](#51%E6%95%B0%E7%BB%84)
  * [5.2、Set 和 Map 结构](#52set-%E5%92%8C-map-%E7%BB%93%E6%9E%84)
  * [5.3、计算生成的数据结构](#53%E8%AE%A1%E7%AE%97%E7%94%9F%E6%88%90%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)
  * [5.4、对象](#54%E5%AF%B9%E8%B1%A1)
- [6、对比JS中的几种遍历：for forEach for...in for...of](#6%E5%AF%B9%E6%AF%94js%E4%B8%AD%E7%9A%84%E5%87%A0%E7%A7%8D%E9%81%8D%E5%8E%86for-----foreach---forin---forof)
  * [理解 JavaScript 中的 for…of 循环](#%E7%90%86%E8%A7%A3-javascript-%E4%B8%AD%E7%9A%84-forof-%E5%BE%AA%E7%8E%AF)
  * [Arrays(数组)](#arrays%E6%95%B0%E7%BB%84)
  * [Maps(映射)](#maps%E6%98%A0%E5%B0%84)
  * [Set(集合)](#set%E9%9B%86%E5%90%88)
  * [String(字符串)](#string%E5%AD%97%E7%AC%A6%E4%B8%B2)
  * [Arguments Object(参数对象)](#arguments-object%E5%8F%82%E6%95%B0%E5%AF%B9%E8%B1%A1)
  * [Generators(生成器)](#generators%E7%94%9F%E6%88%90%E5%99%A8)
  * [退出迭代](#%E9%80%80%E5%87%BA%E8%BF%AD%E4%BB%A3)
  * [普通对象不可迭代](#%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%8F%AF%E8%BF%AD%E4%BB%A3)
  * [For…of vs For…in](#forof-vs-forin)

<!-- tocstop -->

### 1、Iterator 的概念

JavaScript 原有的表示 “ 集合 ” 的数据结构，主要是数组（ Array ）和对象（ Object ）， ES6 又添加了 Map 和 Set 。
这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是 Map ， Map 的成员是对象。
这样就需要一种统一的接口机制，来处理所有不同的数据结构。                                         
遍历器（ Iterator ）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。
任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。           
Iterator 的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是 ES6 创造了一种新的遍历命令for...of循环， Iterator 接口主要供for...of消费。          

Iterator 的遍历过程是这样的。         
- （ 1 ）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。
- （ 2 ）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。
- （ 3 ）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。
- （ 4 ）不断调用指针对象的next方法，直到它指向数据结构的结束位置。

每一次调用next方法，都会返回数据结构的当前成员的信息。
具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。            


### 2、数据结构的默认 Iterator 接口

Iterator 接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找 Iterator 接口。           
在 ES6 中，有三类数据结构原生具备 Iterator 接口：数组、某些类似数组的对象、 Set 和 Map 结构。             

实例：
```javascript
    let arr = ['a', 'b', 'c'];
    let iter = arr[Symbol.iterator]();
    iter.next() // { value: 'a', done: false }
    iter.next() // { value: 'b', done: false }
    iter.next() // { value: 'c', done: false }
    iter.next() // { value: undefined, done: true }
```

上面提到，原生就部署 Iterator 接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for...of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的 Iterator 接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。              


### 3、调用 Iterator 接口的场合         
有一些场合会默认调用 Iterator 接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。             

#### 3.1、解构赋值           
对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法。          
实例1：                
```javascript
    let set = new Set().add('a').add('b').add('c');
    let [x,y] = set;
    // x='a'; y='b'
    let [first, ...rest] = set;
    // first='a'; rest=['b','c'];
```

#### 3.2、扩展运算符      
扩展运算符（ ... ）也会调用默认的 iterator 接口。            
实例2：            
```javascript
    //  例一
    var str = 'hello';
    [...str] // ['h','e','l','l','o']
    //  例二
    let arr = ['b', 'c'];
    ['a', ...arr, 'd']
    // ['a', 'b', 'c', 'd']
```

#### 3.3、yield*         
yield* 后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。         
实例3：            
```javascript
    let generator = function* () {
        yield 1;
        yield* [2,3,4];
        yield 5;
    };
    var iterator = generator();
    iterator.next() // { value: 1, done: false }
    iterator.next() // { value: 2, done: false }
    iterator.next() // { value: 3, done: false }
    iterator.next() // { value: 4, done: false }
    iterator.next() // { value: 5, done: false }
    iterator.next() // { value: undefined, done: true }
```

#### 3.4、其他场合       
由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。            
- for...of
- Array.from()
- Map(), Set(), WeakMap(), WeakSet() （比如new Map([['a',1],['b',2]])）
- Promise.all()
- Promise.race()


### 4、Iterator 接口与 Generator 函数         
Symbol.iterator方法的最简单实现，还是使用下一章要介绍的 Generator 函数。           
实例：         
```javascript
    var myIterable = {};
    myIterable[Symbol.iterator] = function* () {
        yield 1;
        yield 2;
        yield 3;
    };
    [...myIterable] // [1, 2, 3]
    
    //  或者采用下面的简洁写法
    let obj = {
        * [Symbol.iterator]() {
            yield 'hello';
            yield 'world';
        }
    };
    for (let x of obj) {
        console.log(x);
    }
    // hello
    // world
```

### 5、for...of 循环   -   重点！！！           
ES6 借鉴 C++ 、 Java 、 C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了Symbol.iterator属性，就被视为具有 iterator 接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。             
for...of 循环可以使用的范围包括数组、 Set 和 Map 结构、某些类似数组的对象（比如 arguments 对象、 DOM NodeList 对象）、后文的 Generator 对象，以及字符串。                

#### 5.1、数组         
数组原生具备 iterator 接口，for...of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。          
实例1:            
```javascript
    const arr = ['red', 'green', 'blue'];
    let iterator = arr[Symbol.iterator]();
    
    for(let v of arr) {
        console.log(v); // red green blue
    }
    
    for(let v of iterator) {
        console.log(v); // red green blue
    }
``` 

JavaScript 原有的for...in循环，只能获得对象的键名，不能直接获取键值。 ES6 提供for...of循环，允许遍历获得键值。     
实例2:            
```javascript
    var arr = ['a', 'b', 'c', 'd'];
    
    for (let a in arr) {
        console.log(a); // 0 1 2 3
    }
    
    for (let a of arr) {
        console.log(a); // a b c d
    }
```
上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。         

实例3：for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。          
```javascript
    let arr = [3, 5, 7];
    arr.foo = 'hello';
    
    for (let i in arr) {
        console.log(i); // "0", "1", "2", "foo"
    }
    
    for (let i of arr) {
        console.log(i); // "3", "5", "7"
    }
```

#### 5.2、Set 和 Map 结构           
Set 和 Map 结构也原生具有 Iterator 接口，可以直接使用for...of循环。     
实例1：基本使用            
```javascript
    var engines = new Set(["Gecko", "Trident", "Webkit", "Webkit"]);
    for (var e of engines) {
        console.log(e);
    }
    // Gecko
    // Trident
    // Webkit
    
    var es6 = new Map();
    es6.set("edition", 6);
    es6.set("committee", "TC39");
    es6.set("standard", "ECMA-262");
    for (var [name, value] of es6) {
        console.log(name + ": " + value);
    }
    4、通信类
    // committee: TC39
    // standard: ECMA-262
```

Set 结构遍历时，返回的是一个值，而 Map 结构遍历时，返回的是一个数组，该数组的两个成员分别为当前 Map 成员的键名和键值。         
实例2：   
```javascript
    let map = new Map().set('a', 1).set('b', 2);
    for (let pair of map) {
        console.log(pair);
    }
    // ['a', 1]
    // ['b', 2]
    
    for (let [key, value] of map) {
        console.log(key + ' : ' + value);
    }
    // a : 1
    // b : 2
```

#### 5.3、计算生成的数据结构

有些数据结构是在现有数据结构的基础上，计算生成的。比如， ES6 的数组、 Set 、 Map 都部署了以下三个方法，调用后都返回遍历器对象。     

- entries() 返回一个遍历器对象，用来遍历[ 键名 ,  键值 ]组成的数组。对于数组，键名就是索引值；对于 Set ，键名与键值相同。 Map 结构的iterator 接口，默认就是调用 entries 方法。
- keys() 返回一个遍历器对象，用来遍历所有的键名。
- values() 返回一个遍历器对象，用来遍历所有的键值。

实例：         
```javascript
    let arr = ['a', 'b', 'c'];
    
    for (let pair of arr.entries()) {
        console.log(pair);
    }
    // [0, 'a']
    // [1, 'b']
    // [2, 'c']
```

#### 5.4、对象             
对于普通的对象，for...of结构不能直接使用，会报错，必须部署了 iterator 接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。              
实例：         
```javascript
    var es6 = {
        edition: 6,
        committee: "TC39",
        standard: "ECMA-262"
    };
    
    for (e in es6) {
        console.log(e);
    }
    // edition
    // committee
    // standard
    
    for (e of es6) {
        console.log(e);
    }
    // TypeError: es6 is not iterable
```
一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。           
```javascript
    for (var key of Object.keys(someObject)) {
        console.log(key + ": " + someObject[key]);
    }
```

另一个方法是使用 Generator 函数将对象重新包装一下。         
```javascript
    function* entries(obj) {
        for (let key of Object.keys(obj)) {
            yield [key, obj[key]];
        }
    }
    for (let [key, value] of entries(obj)) {
        console.log(key, "->", value);
    }
    // a -> 1
    // b -> 2
    // c -> 3
```


### 6、对比JS中的几种遍历：for     forEach   for...in   for...of
#### 理解 JavaScript 中的 for…of 循环
for...of 语句创建一个循环来迭代可迭代的对象。
在 ES6 中引入的 for...of 循环，以替代 for...in 和 forEach() ，并支持新的迭代协议。
for...of 允许你遍历 Arrays（数组）, Strings（字符串）, Maps（映射）, Sets（集合）等可迭代的数据结构等。                          
对象数据结构是不可以用于for...of 的

语法：
```js
for (variable of iterable) {
    statement
}
```
- variable：每个迭代的属性值被分配给该变量。
- iterable：一个具有可枚举属性并且可以迭代的对象。

#### Arrays(数组)
Arrays（数组）就是类列表（list-like）对象。数组原型上有各种方法，允许对其进行操作，比如修改和遍历等操作。
下面手在一个数组上进行的 for...of 操作：
```js
// array-example.js
const iterable = ['mini', 'mani', 'mo'];
 
for (const value of iterable) {
  console.log(value);
}
 
// Output:
// mini
// mani
// mo
```


#### Maps(映射)
Map 对象就是保存 key-value(键值) 对。对象和原始值可以用作 key(键)或 value(值)。
Map 对象根据其插入方式迭代元素。换句话说， for...of 循环将为每次迭代返回一个 key-value(键值) 数组。
```js
// map-example.js
const iterable = new Map([['one', 1], ['two', 2]]);
 
for (const [key, value] of iterable) {
  console.log(`Key: ${key} and Value: ${value}`);
}
 
// Output:
// Key: one and Value: 1
// Key: two and Value: 2
```

#### Set(集合)
Set(集合) 对象允许你存储任何类型的唯一值，这些值可以是原始值或对象。 
Set(集合) 对象只是值的集合。 Set(集合) 元素的迭代基于其插入顺序。
Set(集合) 中的值只能发生一次。如果您创建一个具有多个相同元素的 Set(集合) ，那么它仍然被认为是单个元素                       
```js
// set-example.js
const iterable = new Set([1, 1, 2, 2, 1]);
 
for (const value of iterable) {
  console.log(value);
}
// Output:
// 1
// 2
```

#### String(字符串)
```js
// string-example.js
const iterable = 'javascript';
 
for (const value of iterable) {
  console.log(value);
}
 
// Output:
// "j"
// "a"
// "v"
// "a"
// "s"
// "c"
// "r"
// "i"
// "p"
// "t"
```


#### Arguments Object(参数对象)
```js
// arguments-example.js
function args() {
  for (const arg of arguments) {
    console.log(arg);
  }
}
 
args('a', 'b', 'c');
// Output:
// a
// b
// c
```

#### Generators(生成器)
```js
// generator-example.js
function* generator(){ 
  yield 1; 
  yield 2; 
  yield 3; 
}
 
for (const g of generator()) { 
  console.log(g); 
}
 
// Output:
// 1
// 2
// 3
```


#### 退出迭代
avaScript 提供了四种已知的终止循环执行的方法：break、continue、return 和 throw。让我们来看一个例子：
```js
const iterable = ['mini', 'mani', 'mo'];
 
for (const value of iterable) {
  console.log(value);
  break;
}
 
// Output:
// mini
```


#### 普通对象不可迭代
for...of 循环仅适用于迭代。 而普通对象不可迭代。 我们来看一下：
```js
const obj = { fname: 'foo', lname: 'bar' };
 
for (const value of obj) { // TypeError: obj[Symbol.iterator] is not a function
    console.log(value);
}
```
在这里，我们定义了一个普通对象 obj ，并且当我们尝试 for...of 对其进行操作时，会报错：TypeError: obj[Symbol.iterator] is not a function。

我们可以通过将类数组(array-like)对象转换为数组来绕过它。该对象将具有一个 length 属性，其元素必须可以被索引。我们来看一个例子：
```js
// object-example.js
const obj = { length: 3, 0: 'foo', 1: 'bar', 2: 'baz' };
 
const array = Array.from(obj);
for (const value of array) { 
    console.log(value);
}
// Output:
// foo
// bar
// baz
```
Array.from() 方法可以让我通过类数组(array-like)或可迭代对象来创建一个新的 Array(数组) 实例。

#### For…of vs For…in
for...of 更多用于特定于集合（如数组和对象），但不包括所有对象。                        
注意：任何具有 Symbol.iterator 属性的元素都是可迭代的。

for...in 不考虑构造函数原型的不可枚举属性。它只需要查找可枚举属性并将其打印出来。


           

## 94.纯 TS 项目工程中, 如何使用 alias path?【JavaScript】
**回答:**      
TODO 待补充内容

可以看这个文档： https://www.miganzi.com/tech/typescript-s-paths-config/
           

## 100.flex 布局了解多少？【CSS】
**回答:**      
## flex 布局的学习

- [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)
- [Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)
- [Flex 布局教程：实例篇代码](https://github.com/JailBreakC/flex-box-demo)


## 容器属性
以下6个属性设置在容器上。                   
```
flex-direction
flex-wrap
flex-flow
justify-content
align-items
align-content
```

### flex-direction属性
属性决定主轴的方向（即项目的排列方向）。
```css
.box {
  flex-direction: row | row-reverse | column | column-reverse;
}
```
- row（默认值）：主轴为水平方向，起点在左端。
- row-reverse：主轴为水平方向，起点在右端。
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿。


### flex-wrap属性
默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。                       
```
.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```
它可能取三个值。                        
（1）nowrap（默认）：不换行。                      
（2）wrap：换行，第一行在上方。                      
（3）wrap-reverse：换行，第一行在下方。                      


### flex-flow
flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。                   
```css
.box {
  flex-flow: <flex-direction> || <flex-wrap>;
}
```

### justify-content属性
属性定义了项目在主轴上的对齐方式。                       
```
.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。

    flex-start（默认值）：左对齐
    flex-end：右对齐
    center： 居中
    space-between：两端对齐，项目之间的间隔都相等。
    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。


### align-items属性
定义项目在交叉轴上如何对齐。                  
```
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
```

它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。

    flex-start：交叉轴的起点对齐。
    flex-end：交叉轴的终点对齐。
    center：交叉轴的中点对齐。
    baseline: 项目的第一行文字的基线对齐。
    stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
    

### align-content属性
定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
```
.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

    flex-start：与交叉轴的起点对齐。
    flex-end：与交叉轴的终点对齐。
    center：与交叉轴的中点对齐。
    space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
    space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
    stretch（默认值）：轴线占满整个交叉轴。
    
    
## 项目的属性
以下6个属性设置在项目上。

    order
    flex-grow
    flex-shrink
    flex-basis
    flex
    align-self

### order属性
定义项目的排列顺序。数值越小，排列越靠前，默认为0。
```
.item {
  order: <integer>;
}
```

### flex-grow
定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。
如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。


### flex-shrink属性
flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。
如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。

### flex-basis 
定义了在分配多余空间之前，项目占据的主轴空间（main size）。
浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
```
.item {
  flex-basis: <length> | auto; /* default auto */
}
```
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

### flex属性
是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
```
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```
该属性有两个快捷值：`auto (1 1 auto) 和 none (0 0 auto)`。
建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

### align-self属性
align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

```
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```
该属性可能取6个值，除了auto，其他都与align-items属性完全一致。


### 参考文章
- [lex 布局中固定宽度不起作用，被压缩了](https://www.jianshu.com/p/4a8825a17181)
- [Flex弹性布局（附超Q小demo）](https://juejin.im/post/5cba07005188251b960f56eb)






           

## 102.map 和 weakMap 的区别 ?【JavaScript】
**回答:**      
Map 和 WeakMap 都是 JavaScript 中的键值对数据结构，它们的主要区别在于其键的存储方式和内存管理。

Map 对象中的键可以是任何类型的值，包括基本类型和引用类型，而 WeakMap 对象中的键必须是对象。在 Map 中，如果一个键不再被引用，它仍然会被 Map 对象保留，因为 Map 对象对其进行了强引用。这会导致内存泄漏的问题。而 WeakMap 对象只会对其键进行弱引用，也就是说，如果一个键不再被引用，它会被垃圾回收器回收，因此不会导致内存泄漏的问题。

此外，WeakMap 没有 Map 中的一些方法，比如 size、keys、values 和 forEach 等方法，因为 WeakMap 的键不是强引用，所以无法确定其大小。

总之，如果需要存储对象键值对，并且不需要保留键的引用，可以考虑使用 WeakMap，否则使用 Map。
           



# 资深开发者相关问题【共计 9 道题】

## 76.JS 内存泄露问题该如何排查？【JavaScript】
**回答:**      
## 什么是内存泄露

> 该问题转载自：https://github.com/zhansingsong/js-leakage-patterns

> **内存泄漏**指由于疏忽或错误造成程序未能释放已经不再使用的内存。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费。内存泄漏通常情况下只能由获得程序源代码的程序员才能分析出来。然而，有不少人习惯于把任何不需要的内存使用的增加描述为内存泄漏，即使严格意义上来说这是不准确的。
> ————[wikipedia](https://zh.wikipedia.org/wiki/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F)

**⚠️ 注：下文中标注的 CG 是 Chrome 浏览器中 Devtools 的【Collect garbage】按钮缩写，表示回收垃圾操作。**
![image](https://user-images.githubusercontent.com/22188674/224474179-30705fda-6d94-41b9-9979-053914e02da5.png)

## 意外的全局变量

JavaScript 对未声明变量的处理方式：在全局对象上创建该变量的引用(即全局对象上的属性，不是变量，因为它能通过`delete`删除)。如果在浏览器中，全局对象就是**window**对象。

如果未声明的变量缓存大量的数据，会导致这些数据只有在窗口关闭或重新刷新页面时才能被释放。这样会造成意外的内存泄漏。

```js
function foo(arg) {
  bar = 'this is a hidden global variable with a large of data';
}
```

等同于：

```js
function foo(arg) {
  window.bar = 'this is an explicit global variable with a large of data';
}
```

另外，通过**this**创建意外的全局变量：

```js
function foo() {
  this.variable = 'potential accidental global';
}

// 当在全局作用域中调用foo函数，此时this指向的是全局对象(window)，而不是'undefined'
foo();
```

### 解决方法：

在 JavaScript 文件中添加`'use strict'`，开启严格模式，可以有效地避免上述问题。

```js
function foo(arg) {
  'use strict'; // 在foo函数作用域内开启严格模式
  bar = 'this is an explicit global variable with a large of data'; // 报错：因为bar还没有被声明
}
```

如果需要在一个函数中使用全局变量，可以像如下代码所示，在**window**上明确声明：

```js
function foo(arg) {
  window.bar = 'this is a explicit global variable with a large of data';
}
```

这样不仅可读性高，而且后期维护也方便

> 谈到全局变量，需要注意那些用来临时存储大量数据的全局变量，确保在处理完这些数据后将其设置为 null 或重新赋值。全局变量也常用来做 cache，一般 cache 都是为了性能优化才用到的，为了性能，最好对 cache 的大小做个上限限制。因为 cache 是不能被回收的，越高 cache 会导致越高的内存消耗。

## console.log

`console.log`：向 web 开发控制台打印一条消息，常用来在开发时调试分析。有时在开发时，需要打印一些对象信息，但发布时却忘记去掉`console.log`语句，这可能造成内存泄露。

在传递给`console.log`的对象是不能被垃圾回收 ♻️，因为在代码运行之后需要在开发工具能查看对象信息。所以最好不要在生产环境中`console.log`任何对象。

### 实例

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Leaker</title>
</head>

<body>
  <input type="button" value="click">
  <script>
    !function () {
      function Leaker() {
        this.init();
      };
      Leaker.prototype = {
        init: function () {
          this.name = (Array(100000)).join('*');
          console.log("Leaking an object %o: %o", (new Date()), this);// this对象不能被回收
        },

        destroy: function () {
          // do something....
        }
      };
      document.querySelector('input').addEventListener('click', function () {
        new Leaker();
      }, false);
    }()
  </script>
</body>

</html>
```

这里结合 Chrome 的 Devtools–>Performance 做一些分析，操作步骤如下：

<u>**:warning:注：最好在隐藏窗口中进行分析工作，避免浏览器插件影响分析结果**</u>

1.  开启【Performance】项的记录
2.  执行一次 CG，创建基准参考线
3.  连续单击【click】按钮三次，新建三个 Leaker 对象
4.  执行一次 CG
5.  停止记录

![image](https://user-images.githubusercontent.com/22188674/224474228-13446f61-b837-4ede-88a7-38227d8ab9c5.png)

可以看出【JS Heap】线最后没有降回到基准参考线的位置，显然存在没有被回收的内存。如果将代码修改为：

```js
!(function() {
  function Leaker() {
    this.init();
  }
  Leaker.prototype = {
    init: function() {
      this.name = Array(100000).join('*');
    },

    destroy: function() {
      // do something....
    },
  };
  document.querySelector('input').addEventListener(
    'click',
    function() {
      new Leaker();
    },
    false,
  );
})();
```

去掉`console.log("Leaking an object %o: %o", (new Date()), this);`语句。重复上述的操作步骤，分析结果如下：

![image](https://user-images.githubusercontent.com/22188674/224474259-46b22d10-0314-4664-adc1-fdef2a575c19.png)

从对比分析结果可知，`console.log`打印的对象是不会被垃圾回收器回收的。因此最好不要在页面中`console.log`任何大对象，这样可能会影响页面的整体性能，特别在生产环境中。除了`console.log`外，另外还有`console.dir`、`console.error`、`console.warn`等都存在类似的问题，这些细节需要特别的关注。

## closures(闭包)

当一个函数 A 返回一个内联函数 B，即使函数 A 执行完，函数 B 也能访问函数 A 作用域内的变量，这就是一个闭包——————本质上闭包是将函数内部和外部连接起来的一座桥梁。

```js
function foo(message) {
  function closure() {
    console.log(message);
  }
  return closure;
}

// 使用
var bar = foo('hello closure!');
bar(); // 返回 'hello closure!'
```

在函数 foo 内创建的函数 closure 对象是不能被回收掉的，因为它被全局变量 bar 引用，处于一直可访问状态。通过执行`bar()`可以打印出`hello closure!`。如果想释放掉可以将`bar = null`即可。

<u>**由于闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。过度使用闭包可能会导致内存占用过多。**</u>

### 实例

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Closure</title>
</head>

<body>
  <p>不断单击【click】按钮</p>
  <button id="click_button">Click</button>
  <script>
    function f() {
      var str = Array(10000).join('#');
      var foo = {
        name: 'foo'
      }
      function unused() {
        var message = 'it is only a test message';
        str = 'unused: ' + str;
      }
      function getData() {
        return 'data';
      }
      return getData;
    }

    var list = [];

    document.querySelector('#click_button').addEventListener('click', function () {
      list.push(f());
    }, false);
  </script>
</body>

</html>
```

这里结合 Chrome 的 Devtools->Memory 工具进行分析，操作步骤如下：

<u>**:warning:注：最好在隐藏窗口中进行分析工作，避免浏览器插件影响分析结果**</u>

1.  选中【Record allocation timeline】选项
2.  执行一次 CG
3.  单击【start】按钮开始记录堆分析
4.  连续单击【click】按钮十多次
5.  停止记录堆分析

![image](https://user-images.githubusercontent.com/22188674/224474271-188cb4f6-a00d-4a29-98ab-10e02818b93d.png)

上图中蓝色柱形条表示随着时间新分配的内存。选中其中某条蓝色柱形条，过滤出对应新分配的对象：

![image](https://user-images.githubusercontent.com/22188674/224474296-a78617eb-17e6-4964-a1e5-2f9a08650872.png)

查看对象的详细信息：

![image](https://user-images.githubusercontent.com/22188674/224474311-fca18dc0-7ce8-410f-a573-55cbd32ee07f.png)

从图可知，在返回的闭包作用链(Scopes)中携带有它所在函数的作用域，作用域中还包含一个 str 字段。而 str 字段并没有在返回 getData()中使用过。为什么会存在在作用域中，按理应该被 GC 回收掉， why:question:

原因是在相同作用域内创建的多个内部函数对象是共享同一个[变量对象（variable object）](http://dmitrysoshnikov.com/ecmascript/chapter-2-variable-object/)。如果创建的内部函数没有被其他对象引用，不管内部函数是否引用外部函数的变量和函数，在外部函数执行完，对应变量对象便会被销毁。反之，如果内部函数中存在有对外部函数变量或函数的访问（可以不是被引用的内部函数），并且存在某个或多个内部函数被其他对象引用，那么就会形成闭包，外部函数的变量对象就会存在于闭包函数的作用域链中。这样确保了闭包函数有权访问外部函数的所有变量和函数。了解了问题产生的原因，便可以对症下药了。对代码做如下修改：

```js
function f() {
  var str = Array(10000).join('#');
  var foo = {
    name: 'foo',
  };
  function unused() {
    var message = 'it is only a test message';
    // str = 'unused: ' + str; //删除该条语句
  }
  function getData() {
    return 'data';
  }
  return getData;
}

var list = [];

document.querySelector('#click_button').addEventListener(
  'click',
  function() {
    list.push(f());
  },
  false,
);
```

getData()和 unused()内部函数共享 f 函数对应的变量对象，因为 unused()内部函数访问了 f 作用域内 str 变量，所以 str 字段存在于 f 变量对象中。加上 getData()内部函数被返回，被其他对象引用，形成了闭包，因此对应的 f 变量对象存在于闭包函数的作用域链中。这里只要将函数 unused 中`str = 'unused: ' + str;`语句删除便可解决问题。

![image](https://user-images.githubusercontent.com/22188674/224474321-74c7546e-4e2a-4d06-b32d-b25ac5f4235b.png)

查看一下闭包信息：

![image](https://user-images.githubusercontent.com/22188674/224474341-9c7ec3b8-e3a1-40ad-9bcc-f570ca7d2bd6.png)

## DOM 泄露

在 JavaScript 中，DOM 操作是非常耗时的。因为 JavaScript/ECMAScript 引擎独立于渲染引擎，而 DOM 是位于渲染引擎，相互访问需要消耗一定的资源。如 Chrome 浏览器中 DOM 位于 WebCore，而 JavaScript/ECMAScript 位于 V8 中。假如将 JavaScript/ECMAScript、DOM 分别想象成两座孤岛，两岛之间通过一座收费桥连接，过桥需要交纳一定“过桥费”。JavaScript/ECMAScript 每次访问 DOM 时，都需要交纳“过桥费”。因此访问 DOM 次数越多，费用越高，页面性能就会受到很大影响。[了解更多:information_source:](http://www.phpied.com/dom-access-optimization/)

![](http://www.phpied.com/wp-content/uploads/2009/12/domlandia.png)

为了减少 DOM 访问次数，一般情况下，当需要多次访问同一个 DOM 方法或属性时，会将 DOM 引用缓存到一个局部变量中。<u>但如果在执行某些删除、更新操作后，可能会忘记释放掉代码中对应的 DOM 引用，这样会造成 DOM 内存泄露。</u>

### 实例------>

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Dom-Leakage</title>
</head>
<body>
  <input type="button" value="remove" class="remove" style="display:none;">
  <input type="button" value="add" class="add">

  <div class="container">
    <pre class="wrapper"></pre>
  </div>
  <script>
    // 因为要多次用到pre.wrapper、div.container、input.remove、input.add节点，将其缓存到本地变量中，
    var wrapper = document.querySelector('.wrapper');
    var container = document.querySelector('.container');
    var removeBtn = document.querySelector('.remove');
    var addBtn = document.querySelector('.add');
    var counter = 0;
    var once = true;
    // 方法
    var hide = function(target){
      target.style.display = 'none';
    }
    var show = function(target){
      target.style.display = 'inline-block';
    }
    // 回调函数
    var removeCallback = function(){
      removeBtn.removeEventListener('click', removeCallback, false);
      addBtn.removeEventListener('click', addCallback, false);
      hide(addBtn);
      hide(removeBtn);
      container.removeChild(wrapper);
    }
    var addCallback = function(){
      wrapper.appendChild(document.createTextNode('\t' + ++counter + '：a new line text\n'));
      // 显示删除操作按钮
      if(once){
        show(removeBtn);
        once = false;
      }
    }
    // 绑定事件
    removeBtn.addEventListener('click', removeCallback, false);
    addBtn.addEventListener('click', addCallback, false);
  </script>
</body>
</html>
```

这里结合 Chrome 浏览器的 Devtools–>Performance 做一些分析，操作步骤如下：

<u>**:warning:注：最好在隐藏窗口中进行分析工作，避免浏览器插件影响分析结果**</u>

1.  开启【Performance】项的记录
2.  执行一次 CG，创建基准参考线
3.  连续单击【add】按钮 6 次，增加 6 个文本节点到 pre 元素中
4.  单击【remove】按钮，删除刚增加 6 个文本节点和 pre 元元素
5.  执行一次 CG
6.  停止记录堆分析

![image](https://user-images.githubusercontent.com/22188674/224474368-2e72c152-76f6-4246-983a-bd4793eac45b.png)

从分析结果图可知，虽然 6 次 add 操作增加 6 个 Node，但是 remove 操作并没有让 Nodes 节点数下降，即 remove 操作失败。尽管还主动执行了一次 CG 操作，Nodes 曲线也没有下降。因此可以断定内存泄露了！那问题来了，如何去查找问题的原因呢？这里可以通过 Chrome 浏览器的 Devtools–>Memory 进行诊断分析，执行如下操作步骤：

<u>**:warning:注：最好在隐藏窗口中进行分析工作，避免浏览器插件影响分析结果**</u>

1.  选中【Take heap snapshot】选项
2.  连续单击【add】按钮 6 次，增加 6 个文本节点到 pre 元素中
3.  单击【Take snapshot】按钮，执行一次堆快照
4.  单击【remove】按钮，删除刚增加 6 个文本节点和 pre 元元素
5.  单击【Take snapshot】按钮，执行一次堆快照
6.  选中生成的第二个快照报告，并将视图由"Summary"切换到"Comparison"对比模式，在[class filter]过滤输入框中输入关键字：**Detached**

![image](https://user-images.githubusercontent.com/22188674/224474384-936ed2c1-3e5d-4e86-bb50-291b53500de0.png)

从分析结果图可知，导致整个 pre 元素和 6 个文本节点无法别回收的原因是：代码中存在全局变量`wrapper`对 pre 元素的引用。知道了产生的问题原因，便可对症下药了。对代码做如下就修改：

```js
// 因为要多次用到pre.wrapper、div.container、input.remove、input.add节点，将其缓存到本地变量中，
var wrapper = document.querySelector('.wrapper');
var container = document.querySelector('.container');
var removeBtn = document.querySelector('.remove');
var addBtn = document.querySelector('.add');
var counter = 0;
var once = true;
// 方法
var hide = function(target) {
  target.style.display = 'none';
};
var show = function(target) {
  target.style.display = 'inline-block';
};
// 回调函数
var removeCallback = function() {
  removeBtn.removeEventListener('click', removeCallback, false);
  addBtn.removeEventListener('click', addCallback, false);
  hide(addBtn);
  hide(removeBtn);
  container.removeChild(wrapper);

  wrapper = null; //在执行删除操作时，将wrapper对pre节点的引用释放掉
};
var addCallback = function() {
  wrapper.appendChild(
    document.createTextNode('\t' + ++counter + '：a new line text\n'),
  );
  // 显示删除操作按钮
  if (once) {
    show(removeBtn);
    once = false;
  }
};
// 绑定事件
removeBtn.addEventListener('click', removeCallback, false);
addBtn.addEventListener('click', addCallback, false);
```

在执行删除操作时，将 wrapper 对 pre 节点的引用释放掉，即在删除逻辑中增加`wrapper = null;`语句。再次在 Devtools–>Performance 中重复上述操作：

![image](https://user-images.githubusercontent.com/22188674/224474409-f5d310a6-8d94-40e8-be75-72250cf00da2.png)

### 小试牛刀

再来看看网上的一个实例，代码如下：

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Practice</title>
</head>
<body>
  <div id="refA"><ul><li><a href="#"></a></li><li><a href="#"></a></li><li><a href="#" id="refB"></a></li></ul></div>
  <div></div>
  <div></div>

  <script>
    var refA = document.getElementById('refA');
    var refB = document.getElementById('refB');
    document.body.removeChild(refA);

    // #refA不能GC回收，因为存在变量refA对它的引用。将其对#refA引用释放，但还是无法回收#refA。
    refA = null;

    // 还存在变量refB对#refA的间接引用(refB引用了#refB，而#refB属于#refA)。将变量refB对#refB的引用释放，#refA就可以被GC回收。
    refB = null;
  </script>
</body>
</html>
```

整个过程如下图所演示：

![image](https://user-images.githubusercontent.com/22188674/224474442-b0ceefcf-a959-4cab-800c-df389737098b.png)

有兴趣的同学可以使用 Chrome 的 Devtools 工具，验证一下分析结果，实践很重要~~~:high_brightness:

## timers

在 JavaScript 常用`setInterval()`来实现一些动画效果。当然也可以使用链式`setTimeout()`调用模式来实现：

```js
setTimeout(function() {
  // do something. . . .
  setTimeout(arguments.callee, interval);
}, interval);
```

如果在不需要`setInterval()`时，没有通过`clearInterval()`方法移除，那么`setInterval()`会不停地调用函数，直到调用`clearInterval()`或窗口关闭。如果链式`setTimeout()`调用模式没有给出终止逻辑，也会一直运行下去。因此再不需要重复定时器时，确保对定时器进行清除，避免占用系统资源。另外，在使用`setInterval()`和`setTimeout()`来实现动画时，无法确保定时器按照指定的时间间隔来执行动画。为了能在 JavaScript 中创建出平滑流畅的动画，浏览器为 JavaScript 动画添加了一个新 API-requestAnimationFrame()。[关于 setInterval、setTimeout 与 requestAnimationFrame 实现动画上的区别 ➹ 猛击 😊](https://github.com/zhansingsong/js-leakage-patterns/blob/master/requestAnimationFrame/requestAnimationFrame.md)

### 实例

如下通过`setInterval()`实现一个 clock 的小实例，不过代码存在问题的，有兴趣的同学可以先尝试找一下问题的所在~~~~~😎
操作：

* 单击【start】按钮开始 clock，同时 web 开发控制台会打印实时信息
* 单击【stop】按钮停止 clock，同时 web 开发控制台会输出停止信息

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>setInterval</title>
</head>
<body>
  <input type="button" value="start" class="start">
  <input type="button" value="stop" class="stop">

  <script>
    var counter = 0;
    var clock = {
      start: function () {
        setInterval(this.step.bind(null, ++counter), 1000);
      },
      step: function (flag) {
        var date = new Date();
        var h = date.getHours();
        var m = date.getMinutes();
        var s = date.getSeconds();
        console.log("%d-----> %d:%d:%d", flag, h, m, s);
      }
    }
    document.querySelector('.start').addEventListener('click', clock.start.bind(clock), false);
    document.querySelector('.stop').addEventListener('click', function () {
      console.log('----> stop <----');
      clock = null;
    }, false);
  </script>
</body>
</html>
```

上述代码存在两个问题：

1.  如果不断的单击【start】按钮，会断生成新的 clock。

2.  单击【stop】按钮不能停止 clock。

输出结果:

![image](https://user-images.githubusercontent.com/22188674/224474541-d2ad7c5a-d465-4167-b69d-c38c09930a67.png)

针对暴露出的问题，对代码做如下修改：

```js
var counter = 0;
var clock = {
  timer: null,
  start: function() {
    // 解决第一个问题
    if (this.timer) {
      clearInterval(this.timer);
    }
    this.timer = setInterval(this.step.bind(null, ++counter), 1000);
  },
  step: function(flag) {
    var date = new Date();
    var h = date.getHours();
    var m = date.getMinutes();
    var s = date.getSeconds();
    console.log('%d-----> %d:%d:%d', flag, h, m, s);
  },
  // 解决第二个问题
  destroy: function() {
    console.log('----> stop <----');
    clearInterval(this.timer);
    node = null;
    counter = void 0;
  },
};
document
  .querySelector('.start')
  .addEventListener('click', clock.start.bind(clock), false);
document
  .querySelector('.stop')
  .addEventListener('click', clock.destroy.bind(clock), false);
```

## EventListener

做移动开发时，需要对不同设备尺寸做适配。如在开发组件时，有时需要考虑处理横竖屏适配问题。一般做法，在横竖屏发生变化时，需要将组件销毁后再重新生成。而在组件中会对其进行相关事件绑定，如果在销毁组件时，没有将组件的事件解绑，在横竖屏发生变化时，就会不断地对组件进行事件绑定。这样会导致一些异常，甚至可能会导致页面崩掉。

### 实例

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>callbacks</title>
</head>
<body>
  <div class="container"></div>
  <script>
    var container = document.querySelector('.container');
    var counter = 0;
    var createHtml = function (n, counter) {
      var template = `${(new Array(n)).join(`<div>${counter}: this is a new data <input type="button" value="remove"></div>`)}`
      container.innerHTML = template;
    }

    var resizeCallback = function (init) {
      createHtml(10, ++counter);
      // 事件委托
      container.addEventListener('click', function (event){
        var target = event.target;
          if(target.tagName === 'INPUT'){
              container.removeChild(target.parentElement)
          }
      }, false);
    }
    window.addEventListener('resize', resizeCallback, false);
    resizeCallback(true);
  </script>
</body>
</html>
```

页面是存在问题的，这里结合 Devtools–>Performance 分析一下问题所在，操作步骤如下：

<u>**:warning:注：最好在隐藏窗口中进行分析工作，避免浏览器插件影响分析结果**</u>

1.  开启 Performance 项的记录
2.  执行一次 CG，创建基准参考线
3.  对窗口大小进行调整
4.  执行一次 CG
5.  停止记录

![image](https://user-images.githubusercontent.com/22188674/224474562-ee38b81c-d14c-4340-8c60-a0ffb1357029.png)

如分析结果所示，在窗口大小变化时，会不断地对`container`添加代理事件。

同一个元素节点注册了多个相同的 EventListener，那么重复的实例会被抛弃。这么做不会让得 EventListener 被重复调用，也不需要用 removeEventListener 手动清除多余的 EventListener，因为重复的都被自动抛弃了。而这条规则只是针对于命名函数。[对于匿名函数，浏览器会将其看做不同的 EventListener](https://triangle717.wordpress.com/2015/12/14/js-avoid-duplicate-listeners/)，所以只要将匿名的 EventListener，命名一下就可以解决问题：

```js
var container = document.querySelector('.container');
var counter = 0;
var createHtml = function(n, counter) {
  var template = `${new Array(n).join(
    `<div>${counter}: this is a new data <input type="button" value="remove"></div>`,
  )}`;
  container.innerHTML = template;
};
//
var clickCallback = function(event) {
  var target = event.target;
  if (target.tagName === 'INPUT') {
    container.removeChild(target.parentElement);
  }
};
var resizeCallback = function(init) {
  createHtml(10, ++counter);
  // 事件委托
  container.addEventListener('click', clickCallback, false);
};
window.addEventListener('resize', resizeCallback, false);
resizeCallback(true);
```

在 Devtools–>Performance 中再重复上述操作，分析结果如下：
![image](https://user-images.githubusercontent.com/22188674/224474599-dd23494a-8bc5-4064-859b-32d2ffa60221.png)

在开发中，开发者很少关注事件解绑，因为浏览器已经为我们处理得很好了。不过在使用第三方库时，需要特别注意，因为一般第三方库都实现了自己的事件绑定，如果在使用过程中，在需要销毁事件绑定时，没有调用所解绑方法，就可能造成事件绑定数量的不断增加。如下链接是我在项目中使用 jquery，遇见到类似问题：[jQuery 中忘记解绑注册的事件，造成内存泄露 ➹ 猛击 😊](https://github.com/zhansingsong/js-leakage-patterns/blob/master/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8BListeners/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E4%B9%8BListeners.md)

## 总结

本文主要介绍了几种常见的内存泄露。在开发过程，需要我们特别留意一下本文所涉及到的几种内存泄露问题。因为这些随时可能发生在我们日常开发中，如果我们对它们不了解是很难发现它们的存在。可能在它们将问题影响程度放大时，才会引起我们的关注。不过那时可能就晚了，因为产品可能已经上线，接着就会严重影响产品的质量和用户体验，甚至可能让我们承受大量用户流失的损失。作为开发的我们必须把好这个关，让我们开发的产品带给用户最好的体验。

## 参考文章：

* [An interesting kind of JavaScript memory leak](https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156)
* [Memory Leaks in Microsoft Internet Explorer](http://isaacschlueter.com/2006/10/msie-memory-leaks/trackback/index.html)
* [Memory leak when logging complex objects](https://stackoverflow.com/questions/12996129/memory-leak-when-logging-complex-objects)

           

## 78.[vue]: vue2.x 虚拟 dom 是怎么实现的？【web框架】
**回答:**      
## virtual-dom 实现之一: snabbdom

vue2.0就是使用的snabbdom                 
一个简单的使用实例：
```javascript
var snabbdom = require('snabbdom');
var patch = snabbdom.init([ // Init patch function with chosen modules
  require('snabbdom/modules/class').default, // makes it easy to toggle classes
  require('snabbdom/modules/props').default, // for setting properties on DOM elements
  require('snabbdom/modules/style').default, // handles styling on elements with support for animations
  require('snabbdom/modules/eventlisteners').default, // attaches event listeners
]);
var h = require('snabbdom/h').default; // helper function for creating vnodes

var container = document.getElementById('container');

var vnode = h('div#container.two.classes', {on: {click: someFn}}, [
  h('span', {style: {fontWeight: 'bold'}}, 'This is bold'),
  ' and this is just normal text',
  h('a', {props: {href: '/foo'}}, 'I\'ll take you places!')
]);
// Patch into empty DOM element – this modifies the DOM as a side effect
patch(container, vnode);

var newVnode = h('div#container.two.classes', {on: {click: anotherEventHandler}}, [
  h('span', {style: {fontWeight: 'normal', fontStyle: 'italic'}}, 'This is now italic type'),
  ' and this is still just normal text',
  h('a', {props: {href: '/bar'}}, 'I\'ll take you places!')
]);
// Second `patch` invocation
patch(vnode, newVnode); // Snabbdom efficiently updates the old view to the new state
```


### snabbdom 核心api
- snabbdom.init:
  The core exposes only one single function snabbdom.init. This init takes a list of modules and returns a patch function that uses the specified set of modules.
```javascript
var patch = snabbdom.init([
  require('snabbdom/modules/class').default,
  require('snabbdom/modules/style').default,
]);
```

- patch:
```javascript
patch(oldVnode, newVnode);
```

- snabbdom/h:
  It is recommended that you use snabbdom/h to create vnodes. h accepts a tag/selector as a string, an optional data object and an optional string or array of children.
```javascript
var h = require('snabbdom/h').default;
var vnode = h('div', {style: {color: '#000'}}, [
  h('h1', 'Headline'),
  h('p', 'A paragraph'),
]);
```

- snabbdom/tovnode:
  Converts a DOM node into a virtual node. Especially good for patching over an pre-existing, server-side generated content.
```javascript
var snabbdom = require('snabbdom')
var patch = snabbdom.init([ // Init patch function with chosen modules
  require('snabbdom/modules/class').default, // makes it easy to toggle classes
  require('snabbdom/modules/props').default, // for setting properties on DOM elements
  require('snabbdom/modules/style').default, // handles styling on elements with support for animations
  require('snabbdom/modules/eventlisteners').default, // attaches event listeners
]);
var h = require('snabbdom/h').default; // helper function for creating vnodes
var toVNode = require('snabbdom/tovnode').default;

var newVNode = h('div', {style: {color: '#000'}}, [
  h('h1', 'Headline'),
  h('p', 'A paragraph'),
]);

patch(toVNode(document.querySelector('.container')), newVNode)
```

### h函数 和 patch 的使用
例如下面的一个dom 结构：
```html
<ul id="list">
    <li class="item">item1</li>
    <li class="item">item2</li>
</ul>
```
用h函数来表示，就如下形式：
```javascript
let vnode = h('ul#list', {}, [
    h('li.item', {}, 'item1'),
    h('li.item', {}, 'item2')
])
```
作用就是模拟的一个真实节点。

patch的使用方式：                 
第一种方式 patch('容器', vnode);  // 这种使用方式是直接渲染dom                            
第二种是用方式: patch(oldVnode, newVnode);         // 这种方式会自动对比dom的差异性，然后只渲染我们需要dom;

一个简单的使用实例：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>snabbdom</title>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-class.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-props.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-style.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/snabbdom-eventlisteners.js"></script>
    <script src="https://cdn.bootcss.com/snabbdom/0.7.1/h.js"></script>
</head>
<body>
<div id="container"></div><br>

<button id="btn-change">change</button>


<script>
    let snabbdom = window.snabbdom;
    let container = document.getElementById('container');
    let buttonChange = document.getElementById('btn-change');

    // 定义patch
    let patch = snabbdom.init([
        snabbdom_class,
        snabbdom_props,
        snabbdom_style,
        snabbdom_eventlisteners
    ]);

    // 定义h
    let h = snabbdom.h;

    // 生成vnode
    let vnode = h('ul#list', {}, [
        h('li.item', {}, 'item1'),
        h('li.item', {}, 'item2')
    ]);
    patch(container, vnode);

    // 模拟一个修改的情况
    buttonChange.addEventListener('click', function () {
        let newVnode = h('ul#list', {}, [
            h('li.item', {}, 'item1'),
            h('li.item', {}, 'item B'),
            h('li.item', {}, 'item 3')
        ]);
        patch(vnode, newVnode);
    })
</script>
</body>
</html>
```

### snabbdom 的使用实例
```html
<body>
<div id="container"></div>
<br>
<button id="btn-change">change</button>
<script>
    let snabbdom = window.snabbdom;
    let container = document.getElementById('container');
    let buttonChange = document.getElementById('btn-change');

    // 定义patch
    let patch = snabbdom.init([
        snabbdom_class,
        snabbdom_props,
        snabbdom_style,
        snabbdom_eventlisteners
    ]);

    // 定义h
    let h = snabbdom.h;
    let data = [
        {
            name: 'yanle',
            age: '20',
            address: '重庆'
        },
        {
            name: 'yanle2',
            age: '25',
            address: '成都'
        },
        {
            name: 'yanle3',
            age: '27',
            address: '深圳'
        }
    ];

    data.unshift({
        name: '姓名',
        age: '年龄',
        address: '地址'
    });

    let vnode;
    function render(data) {
        let newVnode = h('table', {style: {'font-size': '16px'}}, data.map(function (item) {
            let tds = [];
            let i ;
            for (i in item) {
                if(item.hasOwnProperty(i)) {
                    tds.push(h('td', {},   h('a', {props: {href: '/foo'}}, item[i])))
                }
            }
            return h('tr', {}, tds)
        }));

        if(vnode) {
            patch(vnode, newVnode);
        } else {
            patch(container, newVnode);
        }

        vnode = newVnode;
    }

    // 初次渲染
    render(data);
    buttonChange.addEventListener('click', function () {
        data[1].age=30;
        data[1].address = '非洲';
        render(data);
    });
</script>
</body>
```


##  diff算法
### 概念
就是找出两个文件的不同

diff 算法是非常复杂的，实现难度非常大， 源码两非常大。 所以需要去繁就简，明白流程，不关心细节。                 
在vdom中，需要找出本次dom 必须更新的节点来更新，其他的不用更新。找出这个过程就是diff算法实现的。找出前后两个虚拟dom的差异。


### diff实现的过程
这里以snabbdom为例子：                 
patch(container, vnode); patch(vnode, newVnode); 这两个方法里面就使用到了diff算法。 用patch方法来解析diff算法流程核心。

**patch(container, vnode)**                             
![02-11-1](https://user-images.githubusercontent.com/22188674/224475327-0b8f19b3-7a35-40ec-960b-6040852f1a7d.png)

如果上面的数据， 我们怎么构建真正的dom 结构：
```javascript
let createElement = function(vnode) {
    let tag = vnode.tag;
    let attrs = vnode.attrs || {};
    let children = vnode.children || {};
    
    if(!tag) return null;
    
    // 创建元素
    let elem = document.createElement(tag);
    
    // 属性
    let attrName;
    for (attrName in attrs) {
        if(attrs.hasOwnProperty(attrName)) {
            elem.setAttribute(attrName, attrs[attrName])
        }
    }
    
    // 子元素
    children.forEach(function (childVnode) {
        // 给 elem 添加元素
        elem.appendChild(createElement(childVnode))
    });
    
    return elem;
};
```

**patch(vnode, newVnode)**                      
![02-11-2](https://user-images.githubusercontent.com/22188674/224475289-d2f8b10a-1f02-4126-9f2e-b813b0387c84.png)                          
![02-11-3](https://user-images.githubusercontent.com/22188674/224475309-45c68933-3aa8-402a-8353-d09b506e0d46.png)

伪代码实现如下
```javascript
let createElement = function(vnode) {
    let tag = vnode.tag;
    let attrs = vnode.attrs || {};
    let children = vnode.children || {};

    if(!tag) return null;

    // 创建元素
    let elem = document.createElement(tag);

    // 属性
    let attrName;
    for (attrName in attrs) {
        if(attrs.hasOwnProperty(attrName)) {
            elem.setAttribute(attrName, attrs[attrName])
        }
    }

    // 子元素
    children.forEach(function (childVnode) {
        // 给 elem 添加元素
        elem.appendChild(createElement(childVnode))
    });

    return elem;
};
```

### diff算法的其他内容
- 节点的新增和删除
- 节点重新排序
- 节点属性、样式、事件绑定
- 如果极致压榨性能

           

## 79.[vue]: 是如何实现 MVVM 的？【web框架】
**回答:**      


## 引入：使用jquery和其他框架的区别

### 原生JS实现一个todo-list
```html
<body>
<div>
    <input type="text" name="" id="txt-title"> <br>
    <button id="btn-submit">submit</button>
</div>
<div>
    <ul id="ul-list"></ul>
</div>
<script>
    let $txtTitle = document.getElementById('txt-title');
    let $buttonSubmit = document.getElementById('btn-submit');
    let $ulList = document.getElementById('ul-list');
    $buttonSubmit.addEventListener('click', function () {
        let title = $txtTitle.value;
        if(!title) return false;

        let $li = document.createElement('li');
        $li.innerText = title;

        $ulList.appendChild($li);
        $txtTitle.value = '';
    })
</script>
</body>
```


### vue实现todo-list
```html
<body>
<div id="app">
    <div>
        <input v-model="title"> <br>
        <button id="btn-submit" v-on:click="add">submit</button>
    </div>
    <div>
        <ul id="ul-list">
            <li v-for="item in list">{{item}}</li>
        </ul>
    </div>
</div>
<script>
    let vm = new window.Vue({
        el: '#app',
        data: {
            title: '',
            list: []
        },
        methods: {
            add: function () {
                this.list.push(this.title);
                this.title = '';
            }
        }
    })
</script>
</body>
```

### 两者之间的区别
- 数据和视图分离(开放封闭原则： 扩展开放，修改封闭)
- 数据驱动视图


### 对mvvm的理解
具体的理解自己再去整理

MVVM框架的三大要素：                                                                        
响应式、模板引擎、渲染


## 响应式的实现
修改data属性之后，立马就能监听到。                 
data属性挂在到vm实例上面。

有下面的一个问题，我们是如何监听属性的获取和属性的赋值的。
```javascript
let obj = {
    name: 'yanle',
    age: 25
};
console.log(obj.name);
obj.age = 26;
```

是通过**Object.defineProperty** 实现的, 下面的代码就可以实现一个完整的属性修改和获取的监听。
```javascript
let vm = {};
let data = {
    name: 'yanle',
    age: 25
};
let key, value;
for (key in data) {
    (function (key) {
        Object.defineProperty(vm, key, {
            get: function () {
                console.log('get', data[key]);
                return data[key];           // data的属性代理到vm 上 
            },
            set: function (newValue) {
                console.log('set', newValue);
                data[key] = newValue;
            }
        })
    })(key)
}
```

## vue中的模板

**模板**                              
本质就是字符串；                        
有逻辑： if for 等；                  
跟html格式很像， 但是区别很大;                              
最终要转为HTML来现实；                               
模板需要用JS代码来实现， 因为有逻辑，只能用JS来实现；


**render函数-with用法**：
```javascript
let obj = {
    name: 'yanle',
    age: 20,
    getAddress: function () {
        alert('重庆')
    }
};
// 不用with 的情况
// function fn() {
//     alert(obj.name);
//     alert(obj.age);
//     obj.getAddress();
// }
// fn();

// 使用with的情况
function fn1() {
    with (obj) {
        alert(name);
        alert(age);
        getAddress();
    }
}
fn1();
```
这种with 的使用方法就如上所述。但是尽量不要用，因为《JavaScript语言精粹》中，作者说过，这种使用方式会给代码的调试带来非常大的困难。                               
但是vue源码中的render 就是用的这个;


**render函数**:                                   
<img width="274" alt="02-12-1" src="https://user-images.githubusercontent.com/22188674/224475416-9567c516-981f-4399-9128-4efcb70e8502.png">                               
![02-12-2](https://user-images.githubusercontent.com/22188674/224475405-34baf640-f897-4a26-9817-109e8b4c1bde.png)

模板中的所有信息都包含在了render 函数中。                        
一个特别简单的示例:
```javascript
let vm = new Vue({
        el: '#app',
        data: {
            price: 200
        }
    });

    // 一下是手写的
    function render() {
        with (this) {               // 就是vm
            _c(
                'div',
                {
                    attr: {'id': 'app'}
                },
                [
                    _c('p', [_v(_s(price))])
                ]
            )
        }
    }

    function render1() {
        return vm._c(
            'div',
            {
                attr: {'id': 'app'}
            },
            [
                _c('p', [vm._v(vm._s(vm.price))])       // vm._v 是创建文本， _s 就是toString
            ]
        )
    }
```

如果我们用一个复杂的例子来描述这个东西。在源码中， 搜索code.render, 然后在在此之前打印render 函数，就可以看看这个到底是什么东西了。
```javascript
var createCompiler = createCompilerCreator(function baseCompile (
    template,
    options
) {
    var ast = parse(template.trim(), options);
    if (options.optimize !== false) {
        optimize(ast, options);
    }
    var code = generate(ast, options);
    console.log(code.render);
    return {
        ast: ast,
        render: code.render,
        staticRenderFns: code.staticRenderFns
    }
});
```
然后运行， 就可以看到到底render 函数是什么东西了。 就可以截取源码出来看了。                  
相对应的模板如下:
```html
<div id="app">
    <div>
        <input v-model="title"> <br>
        <button id="btn-submit" v-on:click="add">submit</button>
    </div>
    <div>
        <ul id="ul-list">
            <li v-for="item in list">{{item}}</li>
        </ul>
    </div>
</div>
```
截取的render函数如下：
```javascript
function codeRender() {
    with (this) {
        return _c('div',
            {attrs: {"id": "app"}},
            [
                _c('div', [
                    _c('input', {
                        directives: [{
                            name: "model",
                            rawName: "v-model",
                            value: (title),             // 渲染 指定数据
                            expression: "title"
                        }],
                        domProps: {"value": (title)},   // 渲染 指定数据
                        on: {                       // 通过input输入事件， 修改title
                            "input": function ($event) {
                                if ($event.target.composing) return;
                                title = $event.target.value
                            }
                        }
                    }),
                    _v(" "),                // 文本节点
                    _c('br'),
                    _v(" "),
                    _c('button', {          // dom 节点
                            attrs: {"id": "btn-submit"},
                            on: {"click": add}              // methods 里面的东西也都挂在this上面去了
                        },
                        [_v("submit")])]),

                _v(" "),

                _c('div', [
                    _c('ul',
                        {attrs: {"id": "ul-list"}},
                        _l((list), function (item) {                // 数组节点
                            return _c('li', [_v(_s(item))])
                        })
                    )
                ])
            ])
    }
}
```
从vue2.0开始支持预编译， 我们在开发环境下，写模板， 编译打包之后， 模板就变成了JS代码了。vue已经有工具支持这个过程。


## vue中的渲染
vue的渲染是直接渲染为虚拟dom ,这一块儿的内容，其实是借鉴的snabbdom, 非常相似，可以去看看snabbdom 就可以一目了然了。                         
vue中的具体渲染实现:                        
![02-12-03](https://user-images.githubusercontent.com/22188674/224475434-c4e33700-d223-4472-8e96-5cc7b6c04d70.png)



## 整体流程的实现

第一步： 解析模板形成render 函数
- with 用法
- 模板中的所有数据都被render 函数包含
- 模板中data的属性，变成了JS变量
- 模板中的v-model、v-for、v-on都变成了JS的逻辑
- render函数返回vnode

第二步： 响应式开始监听数据变化
- Object.defineProperty 的使用
- 讲data中的属性代理到vm 上

第三步： 首次渲染，显示页面，而且绑定数据和依赖
- 初次渲染， 执行updateComponent, 执行vm._render();
- 执行render函数， 会访问到vm.list和vm.title等已经绑定好了的数据；
- 会被详情是的get 方法监听到                           
  为何一定要监听get, 直接监听set 不行吗？ data中有很多的属性，有的被用到了，有的没有被用到。被用到的会走get, 不被用到的不会走get。
  没有被get监听的属性，set的时候也不会被坚挺。为的就是减少不必要的重复渲染，节省性能。
- 执行updateComponent的时候，会执行vdom的patch方法
- patch 讲vnode渲染为DOM， 初次渲染完成

第四步： data属性变化，出发render
- 修改属性值， 会被响应式的set监听到
- set中会执行updateComponent， 重新执行vm.render()
- 生成vnode和prevVnode, 通过patch进行对比
- 渲染到html中  

           

## 80.[Redux]: 看过 Redux 源码吗， 对 Redux 了解多少？【web框架】
**回答:**      
## 深入Redux架构

目录：
- [1、关于redux](#01)
- [2、API](#02)
- [3、中间件与异步操作](#03)
- [4、异步操作的基本思路](#04)
- [5、React-Redux的用法](#05)

参考文章：[http://www.cnblogs.com/MuYunyun/p/6530715.html](http://www.cnblogs.com/MuYunyun/p/6530715.html)

## <div id="01">1、关于redux</div>

### 1.1、什么情况需要用redux？
- 用户的使用方式复杂
- 不同身份的用户有不同的使用方式（比如普通用户和管理员）
- 多个用户之间可以协作
- 与服务器大量交互，或者使用了WebSocket
- View要从多个来源获取数据

简单说，如果你的UI层非常简单，没有很多互动，Redux 就是不必要的，用了反而增加复杂性。多交互、多数据源场景就比较适合使用Redux。

### 1.2、设计思想
- Web 应用是一个状态机，视图与状态是一一对应的。
- 所有的状态，保存在一个对象里面。

### 1.3、Redux工作流程

![react04-01](https://user-images.githubusercontent.com/22188674/224475588-53d35049-5ed3-4921-bd35-847a3859b23b.png)                           

首先，用户发出 Action。                         
`store.dispatch(action);`                               

然后，Store 自动调用 Reducer，并且传入两个参数：当前 State 和收到的 Action。 Reducer 会返回新的 State 。                                                    
`let nextState = todoApp(previousState, action);`


State 一旦有变化，Store 就会调用监听函数。                                 
// 设置监听函数                       
`store.subscribe(listener);`

listener可以通过store.getState()得到当前状态。如果使用的是 React，这时可以触发重新渲染 View。                                
```javascript
function listerner() {
  let newState = store.getState();
  component.setState(newState);   
}
```

如果现在没理解以上流程，不要急，看完以下API就差不多能懂得Redux的核心机制了。

## <div id="02">2、API</div>                         

### Store
Store 就是保存数据的地方，你可以把它看成一个容器。整个应用只能有一个 Store。

Redux 提供createStore这个函数，用来生成 Store。                     
下面代码中，createStore函数接受另一个函数作为参数，返回新生成的 Store 对象。                         
```javascript
import { createStore } from 'redux';
const store = createStore(fn);
```

### State
Store对象包含所有数据。如果想得到某个时点的数据，就要对 Store 生成快照。这种时点的数据集合，就叫做 State。                          
当前时刻的 State，可以通过store.getState()拿到。
```javascript
import { createStore } from 'redux';
const store = createStore(fn);

const state = store.getState();
```
Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。


### Action
State 的变化，会导致 View 的变化。但是，用户接触不到 State，只能接触到 View。所以，State 的变化必须是 View 导致的。Action 就是 View 发出的通知，表示 State 应该要发生变化了。                          
Action 是一个对象。其中的type属性是必须的，表示 Action 的名称。其他属性可以自由设置，社区有一个规范可以参考。                                
```javascript
const action = {
  type: 'ADD_TODO',
  payload: 'Learn Redux'
};
```
上面代码中，Action 的名称是ADD_TODO，它携带的信息是字符串Learn Redux。                        
可以这样理解，Action 描述当前发生的事情。改变 State 的唯一办法，就是使用 Action。它会运送数据到 Store。


### Action Creator
View 要发送多少种消息，就会有多少种 Action。如果都手写，会很麻烦。可以定义一个函数来生成 Action，这个函数就叫 Action Creator。                    
```javascript
const ADD_TODO = '添加 TODO';

function addTodo(text) {
  return {
    type: ADD_TODO,
    text
  }
}
const action = addTodo('Learn Redux');
```

### store.dispatch()
store.dispatch()是 View 发出 Action 的唯一方法。                     
```javascript
import { createStore } from 'redux';
const store = createStore(fn);

store.dispatch({
  type: 'ADD_TODO',
  payload: 'Learn Redux'
});
```
上面代码中，store.dispatch接受一个 Action 对象作为参数，将它发送出去。                          
结合 Action Creator，这段代码可以改写如下。
```javascript
store.dispatch(addTodo('Learn Redux'));
```

### Reducer
Store 收到 Action 以后，必须给出一个新的 State，这样 View 才会发生变化。这种 State 的计算过程就叫做 Reducer。                             
Reducer 是一个函数，它接受 Action 和当前 State 作为参数，返回一个新的 State。下面是一个实际的例子
```javascript
const defaultState = 0;
const reducer = (state = defaultState, action) => {
  switch (action.type) {
    case 'ADD':
      return state + action.payload;
    default: 
      return state;
  }
};

const state = reducer(1, {
  type: 'ADD',
  payload: 2
});
```
上面代码中，reducer函数收到名为ADD的 Action 以后，就返回一个新的 State，作为加法的计算结果。
其他运算的逻辑（比如减法），也可以根据 Action 的不同来实现。                                        
实际应用中，Reducer 函数不用像上面这样手动调用，store.dispatch方法会触发 Reducer 的自动执行。
为此，Store 需要知道 Reducer 函数，做法就是在生成 Store 的时候，将 Reducer 传入createStore方法。                           
```javascript
import { createStore } from 'redux';
const store = createStore(reducer);
```
上面代码中，createStore接受 Reducer 作为参数，生成一个新的 Store。
以后每当store.dispatch发送过来一个新的 Action，就会自动调用 Reducer，得到新的 State。


### store.subscribe()
Store 允许使用store.subscribe方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。                      
```javascript
import { createStore } from 'redux';
const store = createStore(reducer);

store.subscribe(listener);
```
显然，只要把 View 的更新函数（对于 React 项目，就是组件的render方法或setState方法）放入listen，就会实现 View 的自动渲染。                        
store.subscribe方法返回一个函数，调用这个函数就可以解除监听。                      
```javascript
let unsubscribe = store.subscribe(() =>
  console.log(store.getState())
);
unsubscribe();
```


## <div id="03">3、中间件与异步操作</div>
一个关键问题没有解决：异步操作怎么办？Action 发出以后，Reducer 立即算出 State，这叫做同步；Action 发出以后，过一段时间再执行 Reducer，这就是异步。                             
怎么才能 Reducer 在异步操作结束后自动执行呢？这就要用到新的工具：中间件（middleware）。

为了理解中间件，让我们站在框架作者的角度思考问题：如果要添加功能，你会在哪个环节添加？                         
（1）Reducer：纯函数，只承担计算 State 的功能，不合适承担其他功能，也承担不了，因为理论上，纯函数不能进行读写操作。                       
（2）View：与 State 一一对应，可以看作 State 的视觉层，也不合适承担其他功能。                        
（3）Action：存放数据的对象，即消息的载体，只能被别人操作，自己不能进行任何操作。                        
想来想去，只有发送 Action 的这个步骤，即store.dispatch()方法，可以添加功能。                              

### 中间件的用法
本文不涉及如何编写中间件，因为常用的中间件都有现成的，只要引用别人写好的模块即可。                       
```javascript
import { applyMiddleware, createStore } from 'redux';
import createLogger from 'redux-logger';
const logger = createLogger();

const store = createStore(
  reducer,
  applyMiddleware(logger)
);
```

上面代码中，redux-logger提供一个生成器createLogger，可以生成日志中间件logger。
然后，将它放在applyMiddleware方法之中，传入createStore方法，就完成了store.dispatch()的功能增强。

这里有两点需要注意：
（1）createStore方法可以接受整个应用的初始状态作为参数，那样的话，applyMiddleware就是第三个参数了。
```javascript
const store = createStore(
  reducer,
  initial_state,
  applyMiddleware(logger)
);
```

（2）中间件的次序有讲究。
```javascript
const store = createStore(
  reducer,
  applyMiddleware(thunk, promise, logger)
);
```
上面代码中，applyMiddleware方法的三个参数，就是三个中间件。有的中间件有次序要求，使用前要查一下文档。比如，logger就一定要放在最后，否则输出结果会不正确。


## <div id="04">4、异步操作的基本思路</div>

理解了中间件以后，就可以处理异步操作了。

同步操作只要发出一种 Action 即可，异步操作的差别是它要发出三种 Action。                                 
- 操作发起时的 Action
- 操作成功时的 Action
- 操作失败时的 Action

以向服务器取出数据为例，三种 Action 可以有两种不同的写法。
```
// 写法一：名称相同，参数不同
{ type: 'FETCH_POSTS' }
{ type: 'FETCH_POSTS', status: 'error', error: 'Oops' }
{ type: 'FETCH_POSTS', status: 'success', response: { ... } }

// 写法二：名称不同
{ type: 'FETCH_POSTS_REQUEST' }
{ type: 'FETCH_POSTS_FAILURE', error: 'Oops' }
{ type: 'FETCH_POSTS_SUCCESS', response: { ... } }
```

除了 Action 种类不同，异步操作的 State 也要进行改造，反映不同的操作状态。下面是 State 的一个例子。
```javascript
let state = {
  // ... 
  isFetching: true,
  didInvalidate: true,
  lastUpdated: 'xxxxxxx'
};
```
上面代码中，State 的属性isFetching表示是否在抓取数据。didInvalidate表示数据是否过时，lastUpdated表示上一次更新时间。

现在，整个异步操作的思路就很清楚了。                              
- 操作开始时，送出一个 Action，触发 State 更新为"正在操作"状态，View 重新渲染
- 操作结束后，再送出一个 Action，触发 State 更新为"操作结束"状态，View 再一次重新渲染

### 总结
在异步请求的时候，其实很多时候都是直接发出请求如果请求成功了之后，在存入reducers, 并不是不管成功与否，都存入reducers。                                        


### redux-thunk中间件
异步操作至少要送出两个 Action：用户触发第一个 Action，这个跟同步操作一样，没有问题；如何才能在操作结束时，系统自动送出第二个 Action 呢？
奥妙就在 Action Creator 之中。
```javascript
class AsyncApp extends Component {
  componentDidMount() {
    const { dispatch, selectedPost } = this.props
    dispatch(getApplyList(selectedPost))
  }
}
// ...
```
上面代码是一个异步组件的例子。加载成功后（componentDidMount方法），它送出了（dispatch方法）一个 Action，向服务器要求数据 fetchPosts(selectedSubreddit)。
这里的fetchPosts就是 Action Creator。                         
下面就是getApplyList的代码，关键之处就在里面， 这是我在公司的代码风格写法。
```javascript
export function getApplyList(query) {
    return function(dispatch) {
        dispatch(modalUpdate({
            loadingTable: true
        }));
        fetch('apply', query)
            .then(function(res) {
                dispatch(updateApply(res.data));                // 这个是调用的action Mppper
                dispatch(modalUpdate({
                    loadingTable: false
                }));
            }).catch(function(err) {
                dispatch(modalUpdate({
                    pageWarn: err.message,
                    loadingTable: false
                }));
            });
    };
}

// 对应的action Mapper
export function updateApply(data) {
    return {
        type: UPDATE_APPLY,
        data
    };
}
```

这里是博客文章的代码风格写法
```javascript
const fetchPosts = postTitle => (dispatch, getState) => {
  dispatch(requestPosts(postTitle));
  return fetch(`/some/API/${postTitle}.json`)
    .then(response => response.json())
    .then(json => dispatch(receivePosts(postTitle, json)));
};

// 使用方法一
store.dispatch(fetchPosts('reactjs'));
// 使用方法二
store.dispatch(fetchPosts('reactjs')).then(() =>
  console.log(store.getState())
);
```
上面代码中，fetchPosts是一个Action Creator（动作生成器），返回一个函数。
这个函数执行后，先发出一个Action（requestPosts(postTitle)），然后进行异步操作。
拿到结果后，先将结果转成 JSON 格式，然后再发出一个 Action（ receivePosts(postTitle, json)）。                                    

上面代码中，有几个地方需要注意。
- （1）fetchPosts返回了一个函数，而普通的 Action Creator 默认返回一个对象。
- （2）返回的函数的参数是dispatch和getState这两个 Redux 方法，普通的 Action Creator 的参数是 Action 的内容。
- （3）在返回的函数之中，先发出一个 Action（requestPosts(postTitle)），表示操作开始。
- （4）异步操作结束之后，再发出一个 Action（receivePosts(postTitle, json)），表示操作结束。

这样的处理，就解决了自动发送第二个 Action 的问题。但是，又带来了一个新的问题，Action 是由store.dispatch方法发送的。
而store.dispatch方法正常情况下，参数只能是对象，不能是函数。                               
这时，就要使用中间件**redux-thunk**。
```javascript
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import reducer from './reducers';

// Note: this API requires redux@>=3.1.0
const store = createStore(
  reducer,
  applyMiddleware(thunk)
);
```
上面代码使用redux-thunk中间件，改造store.dispatch，使得后者可以接受函数作为参数。                       
因此，异步操作的第一种解决方案就是，写出一个返回函数的 Action Creator，然后使用redux-thunk中间件改造store.dispatch。


## <div id="05">5、React-Redux的用法</div>
为了方便使用，Redux 的作者封装了一个 React 专用的库 React-Redux，本文主要介绍它。                       
这个库是可以选用的。实际项目中，你应该权衡一下，是直接使用 Redux，还是使用 React-Redux。后者虽然提供了便利，但是需要掌握额外的 API，并且要遵守它的组件拆分规范。

本人项目中使用的最多的就是 react-redux;                      

React-Redux 将所有组件分成两大类：**UI 组件（presentational component）和容器组件（container component）**。

### UI组件
UI 组件有以下几个特征。                           
- 只负责 UI 的呈现，不带有任何业务逻辑
- 没有状态（即不使用this.state这个变量）
- 所有数据都由参数（this.props）提供
- 不使用任何 Redux 的 API

下面就是一个 UI 组件的例子。
```javascript
const Title = value => <h1>{value}</h1>;
```
因为不含有状态，UI 组件又称为"纯组件"，即它纯函数一样，纯粹由参数决定它的值。

### 容器组件
容器组件的特征恰恰相反。
- 负责管理数据和业务逻辑，不负责 UI 的呈现
- 带有内部状态
- 使用 Redux 的 API

总之，只要记住一句话就可以了：UI 组件负责 UI 的呈现，容器组件负责管理数据和逻辑。

你可能会问，如果一个组件既有 UI 又有业务逻辑，那怎么办？回答是，将它拆分成下面的结构：外面是一个容器组件，里面包了一个UI 组件。前者负责与外部的通信，将数据传给后者，由后者渲染出视图。                         
React-Redux 规定，所有的 UI 组件都由用户提供，容器组件则是由 React-Redux 自动生成。也就是说，用户负责视觉层，状态管理则是全部交给它。

### connect()
React-Redux 提供connect方法，用于从 UI 组件生成容器组件。connect的意思，就是将这两种组件连起来。                         
connect方法的完整 API 如下。下面这个例子是我在项目中使用的一个完整结构示例                    
```javascript
/* eslint-disable react/jsx-no-target-blank */
import React, {Component} from 'react';
import {push} from 'react-router-redux';
import {connect} from 'react-redux';
import PropTypes from 'prop-types';
import {Button, message} from 'antd';

// mapStateToProps
function propMap(state, ownProps) {
    return {
        modal: state.modal,
        routing: ownProps
    };
}

class InvoiceList extends Component {
    constructor() {
        super();
        this.state = {
            invoiceListData: {}
        };
        this.handleGetList = this.handleGetList.bind(this);
    }

    componentDidMount() {
        // 每次刷新空拉数据一次
        this.handleGetList();
    }

    render() {
        const {routing, modal} = this.props;
        return (
            <div className="app-reimbursement-invoice-list">
                <ReimbursementHeaderNav current="invoice-list"/>
                {/*.......*/}
            </div>
        );
    }

    // 点击查询数据
    handleGetList(filters, type) {
        console.log('点击查询数据')
    }
}
InvoiceList.propTypes = {
    routing: PropTypes.object.isRequired,
    modal: PropTypes.object.isRequired,
    dispatch: PropTypes.func.isRequired
};
export default connect(propMap)(InvoiceList);
```
InvoiceList就是由 React-Redux 通过connect方法自动生成的容器组件。
connect方法接受两个参数：mapStateToProps和mapDispatchToProps。
它们定义了 UI 组件的业务逻辑。前者负责输入逻辑，即将state映射到 UI 组件的参数（props），后者负责输出逻辑，即将用户对 UI 组件的操作映射成 Action。
通常我们只使用了第一个参数；                      

### mapStateToProps                         
mapStateToProps是一个函数。它的作用就是像它的名字那样，建立一个从（外部的）state对象到（UI 组件的）props对象的映射关系。
作为函数，mapStateToProps执行后应该返回一个对象，里面的每一个键值对就是一个映射。                    
```javascript
const mapStateToProps = (state) => {
  return {
    todos: getVisibleTodos(state.todos, state.visibilityFilter)
  }
}
```
上面代码中，mapStateToProps是一个函数，它接受state作为参数，返回一个对象。这个对象有一个todos属性，代表 UI 组件的同名参数，
后面的getVisibleTodos也是一个函数，可以从state算出 todos 的值。                       
下面就是getVisibleTodos的一个例子，用来算出todos。                     
```javascript
const getVisibleTodos = (todos, filter) => {
  switch (filter) {
    case 'SHOW_ALL':
      return todos
    case 'SHOW_COMPLETED':
      return todos.filter(t => t.completed)
    case 'SHOW_ACTIVE':
      return todos.filter(t => !t.completed)
    default:
      throw new Error('Unknown filter: ' + filter)
  }
}
```
mapStateToProps会订阅 Store，每当state更新的时候，就会自动执行，重新计算 UI 组件的参数，从而触发 UI 组件的重新渲染。                     
mapStateToProps的第一个参数总是state对象，还可以使用第二个参数，代表容器组件的props对象                            
```javascript
const mapStateToProps = (state, ownProps) => {
  return {
    active: ownProps.filter === state.visibilityFilter
  }
}
```
使用ownProps作为参数后，如果容器组件的参数发生变化，也会引发 UI 组件重新渲染。                   
connect方法可以省略mapStateToProps参数，那样的话，UI 组件就不会订阅Store，就是说 Store 的更新不会引起 UI 组件的更新。                     


### mapDispatchToProps()
mapDispatchToProps是connect函数的第二个参数，用来建立 UI 组件的参数到store.dispatch方法的映射。
也就是说，它定义了哪些用户的操作应该当作 Action，传给 Store。它可以是一个函数，也可以是一个对象。

如果mapDispatchToProps是一个函数，会得到dispatch和ownProps（容器组件的props对象）两个参数。
```javascript
const mapDispatchToProps = (
  dispatch,
  ownProps
) => {
  return {
    onClick: () => {
      dispatch({
        type: 'SET_VISIBILITY_FILTER',
        filter: ownProps.filter
      });
    }
  };
}
```
从上面代码可以看到，mapDispatchToProps作为函数，应该返回一个对象，该对象的每个键值对都是一个映射，定义了 UI 组件的参数怎样发出 Action。                  

如果mapDispatchToProps是一个对象，它的每个键名也是对应 UI 组件的同名参数，键值应该是一个函数，会被当作 Action creator ，
返回的 Action 会由 Redux 自动发出。举例来说，上面的mapDispatchToProps写成对象就是下面这样。                                  
```ecmascript 6
const mapDispatchToProps = {
  onClick: (filter) => {
    type: 'SET_VISIBILITY_FILTER',
    filter: filter
  }
}
```

总结，实际上项目开发过程中， 只用得上第一个参数，第二个参数一般来说是封装在reducers 层次里面的。不建议直接放置在组建成此调用。因为会导致使用和数据上的紊乱。                     


### <Provider>组件
connect方法生成容器组件以后，需要让容器组件拿到state对象，才能生成 UI 组件的参数。React-Redux 提供Provider组件，可以让容器组件拿到state。
```javascript
import { Provider } from 'react-redux'
import { createStore } from 'redux'
import todoApp from './reducers'
import App from './components/App'

let store = createStore(todoApp);

render(
  <Provider store={store}>
    <App />
  </Provider>,
  document.getElementById('root')
)
```
上面代码中，Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。

### React-Router路由库
使用React-Router的项目，与其他项目没有不同之处，也是使用Provider在Router外面包一层，毕竟Provider的唯一功能就是传入store对象。
```javascript
const Root = ({ store }) => (
  <Provider store={store}>
    <Router>
      <Route path="/" component={App} />
    </Router>
  </Provider>
);
```




           

## 83.react和vue的区别？【web框架】
**回答:**      
# Vue与React的对比

> 文档转自：https://blog.csdn.net/CystalVon/article/details/78428036

Vue.js与React.js从某些反面来说很相似，通过两个框架的学习，有时候对一些用法会有一点思考，为加深学习的思索，特翻阅了两个文档，从以下各方面进行了对比，加深了对这两个框架的认知。

## 1.数据绑定

### 1.1 Vue中有关数据绑定的部分

* vue是双向绑定， Vue.js 最核心的功能有两个，一是响应式的数据绑定系统，二是组件系统。所谓双向绑定，指的是vue实例中的data与其渲染的DOM元素的内容保持一致，无论谁被改变，另一方会相应的更新为相同的数据。这是通过设置属性访问器实现的。
* 在vue中，与数据绑定有关的有 **插值表达式、指令系统、\*Class和Style、事件处理器和表单空间、ajax请求和计算属性**

#### 1.1.1插值表达式

插值和指令又称为模板语法  
. 数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值  
. Mustache 语法不能作用在 HTML 特性上，遇到这种情况应该使用 v-bind 指令

#### 1.1.2 指令

* vue中的指令很方便，指令 (Directives) 是带有 v- 前缀的特殊属性。指令属性的值预期是单个 JavaScript 表达式 (v-for 是例外情况，稍后我们再讨论)。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。

* vue中的12个指令： `v-bind,v-once,v-model,v-text,v-html,v-on,v-if,v-else,v-show,v-for,v-pre,v-clock`

#### 1.1.3 class与style绑定

* 数据绑定的一个常见需求是操作元素的 class 列表和它的内联样式。因为它们都是属性 ，我们可以用v-bind 处理它们：只需要计算出表达式最终的字符串。不过，字符串拼接麻烦又易错。因此，在 v-bind 用于 class 和 style 时，Vue.js 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。
* 对象语法  

  * 我们可以传给 v-bind:class 一个对象，以动态地切换 class
* 数组语法  

  * 我们可以把一个数组传给 v-bind:class，以应用一个 class 列表：

```javascript
<div v-bind:class="[activeClass, errorClass]"></div>
1
```

#### 1.1.4 条件渲染和列表渲染

* v-if条件渲染一组数
* 我们用 v-for 指令根据一组数组的选项列表进行渲染。v-for 指令需要使用 item in items 形式的特殊语法，items 是源数据数组并且 item 是数组元素迭代的别名。

#### 1.1.5 事件处理器

* 通过v-on给元素注册事件
* 使用 v-on 有几个好处：  

  * 扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。
  * 因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。
  * 当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。

#### 1.1.6 表单控件

* v-model在表单控件元素上创建双向数据绑定
* 它会根据控件类型自动选取正确的方法来更新元素。

#### 1.1.7 计算属性

* 在Vue中引入了计算属性来处理模板中放入太多的逻辑会让模板过重且难以维护的问题，这样不但解决了上面的问题，而且也同时让模板和业务逻辑更好的分离。
* 简单来说，假如data里面有属性a=1，然后你需要一个变量跟着a变化，例如b=a+1，那么就需要用到计算属性，Vue实例的computed属性中，设置b为其属性，其表现为一个函数，返回值是b的值。


#### 注： <font>关于vue的数据双向绑定和单向数据流</font>

* **Vue 的依赖追踪是【原理上不支持双向绑定，v-model 只是通过监听 DOM 事件实现的语法糖】**

* vue的依赖追踪是通过 Object.defineProperty 把data对象的属性全部转为 getter/setter来实现的；当改变数据的某个属性值时，会触发set函数,获取该属性值的时候会触发get函数，通过这个特性来实现改变数据时改变视图；也就是说只有当数据改变时才会触发视图的改变，反过来在操作视图时，只能通过DOM事件来改变数据，再由此来改变视图，以此来实现双向绑定
* <font>双向绑定是在同一个组件内，将数据和视图绑定起来，和父子组件之间的通信并无什么关联；</font>
* 组件之间的通信采用<font>单向数据流</font>是为了组件间更好的解耦，在开发中可能有多个子组件依赖于父组件的某个数据，假如子组件可以修改父组件数据的话，一个子组件变化会引发所有依赖这个数据的子组件发生变化，所以vue不推荐子组件修改父组件的数据，直接修改props会抛出警告

### 1.2 react没有数据双向绑定

* react是单向数据流
* react中通过将state（Model层）与View层数据进行双向绑定达数据的实时更新变化，具体来说就是在View层直接写JS代码Model层中的数据拿过来渲染，一旦像**表单操作、触发事件、ajax请求**等触发数据变化，则进行双同步

#### 1.2.1事件处理

* React 元素的事件处理和 DOM元素的很相似。但是有一点语法上的不同:

  * React事件绑定属性的命名采用驼峰式写法，而不是小写。
  * 如果采用 JSX 的语法你需要传入一个函数作为事件处理函数，而不是一个字符串(DOM元素的写法)
  * 在 React 中另一个不同是你不能使用返回 false 的方式阻止默认行为。你必须明确的使用 preventDefault。

  * 当你使用 ES6 class 语法来定义一个组件的时候，事件处理器会成为类的一个方法。一般需要显式的绑定this，例如


    `this.handleClick = this.handleClick.bind(this);`
  * 你必须谨慎对待 JSX 回调函数中的 this，类的方法默认是不会绑定 this 的。如果你忘记绑定 this.handleClick 并把它传入 onClick, 当你调用这个函数的时候 this 的值会是 undefined。

#### 1.2.2 条件渲染

* React 中的条件渲染和 JavaScript 中的一致，使用 JavaScript 操作符 if 或条件运算符来创建表示当前状态的元素，然后让 React 根据它们来更新 UI。
* 你可以通过用花括号包裹代码在 JSX 中嵌入任何表达式 ，也包括 JavaScript 的逻辑与 &&，它可以方便地条件渲染一个元素。之所以能这样做，是因为在 JavaScript 中，true && expression 总是返回 expression，而 false && expression 总是返回 false。因此，如果条件是 true，&& 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。
* 条件渲染的另一种方法是使用 JavaScript 的条件运算符 condition ? true : false。

#### 1.2.3 列表渲染

* 你可以通过使用{}在JSX内构建一个元素集合，使用Javascript中的map()方法循遍历数组
* Keys可以在DOM中的某些元素被增加或删除的时候帮助React识别哪些元素发生了变化。因此你应当给数组中的每一个元素赋予一个确定的标识。一个元素的key最好是这个元素在列表中拥有的一个独一无二的字符串。通常，我们使用来自数据的id作为元素的key。

#### 1.2.4 表单操作

* HTML表单元素与React中的其他DOM元素有所不同,因为表单元素生来就保留一些内部状态。
* 当用户提交表单时，HTML的默认行为会使这个表单会跳转到一个新页面。在React中亦是如此。但大多数情况下，我们都会构造一个处理提交表单并可访问用户输入表单数据的函数。实现这一点的标准方法是使用一种称为“受控组件”的技术。其值由React控制的输入表单元素称为“受控组件”。`this.setState({value: event.target.value});`
* 当你有处理多个受控的input元素时，你可以通过给每个元素添加一个name属性，来让处理函数根据 event.target.name的值来选择做什么。

#### 1.2.5 状态提升

* 在React中，状态分享是通过将state数据提升至离需要这些数据的组件最近的父组件来完成的。这就是所谓的状态提升。`this.props.xxx`
* 在React应用中，对应任何可变数据理应只有一个单一“数据源”。通常，状态都是首先添加在需要渲染数据的组件中。此时，如果另一个组件也需要这些数据，你可以将数据提升至离它们最近的父组件中。你应该在应用中保持 自上而下的数据流，而不是尝试在不同组件中同步状态。

## 2.组件化以及组件数据流

### 2.1 react中的组件及数据流

* React是单向数据流，数据主要从父节点传递到子节点（通过props）。如果顶层（父级）的某个props改变了，React会重渲染所有的子节点。
* react中实现组件有两种实现方式，一种是createClass方法，另一种是通过ES2015的思想类继承React.Component来实现
* 在React应用中，按钮、表单、对话框、整个屏幕的内容等，这些通常都被表示为组件。
* React推崇的是**函数式编程**和**单向数据流**：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）
* 组件可以将UI切分成一些的独立的、可复用的部件，这样你就只需专注于构建每一个单独的部件。组件从概念上看就像是函数，它可以接收任意的输入值（称之为“props”），并返回一个需要在页面上展示的React元素。  
**1. Props的只读性**
* 无论是使用函数或是类来声明一个组件，它决不能修改它自己的props。
* 所有的React组件必须像纯函数那样使用它们的props。

**props与State的区别**  
. props是property的缩写，可以理解为HTML标签的attribute。不可以使用this.props直接修改props，因为props是只读的，props是用于整个组件树中传递数据和配置。在当前组件访问props，使用this.props。  
. props是一个组件的设置参数，可以在父控件中选择性设置。父组件对子控件的props进行赋值，并且props的值不可改变。一个子控件自身不能改变自己的 props。  
. state:当一个组件 mounts的时候，state如果设置有默认值的会被使用，并且state可能时刻的被改变。一个子控件自身可以管理自己的state，但是需要注意的是，无法管理其子控件的state。所以可以认为，state是子控件自身私有的。  
. 每个组件都有属于自己的state，state和props的区别在于前者(state)只存在于组件内部，只能从当前组件调用this.setState修改state值（不可以直接修改this.state！）。  
. props是一个父组件传递给子组件的数据流，可以一直的被传递到子孙组件中。然而 state代表的是子组件自身的内部状态。从语义上讲，改变组件的状态，可能会导致dom结构的改变或者重新渲染。而props是父组件传递的参数，所以可以被用于初始化渲染和改变组件自身的状态，虽然大多数时候组件的状态是又外部事件触发改变的。我们需要知道的是，无论是state改变，还是父组件传递的 props改变，render方法都可能会被执行。  
. 一般我们更新子组件都是通过改变state值，更新新子组件的props值从而达到更新。

#### 2.1.1 组件之间的通信

1. 父子组件数通信  

   * 父与子之间通props属性进行传递
   * 子与父之间，父组件定义事件，子组件触发父组件中的事件时，通过实参的形式来改变父组件中的数据来通信

即：  
. . 父组件更新组件状态 —–props—–> 子组件更新  
. . 子组件更新父组件状态 —–需要父组件传递回调函数—–> 子组件调用触发

1. 非父子组件之间的通信，嵌套不深的非父子组件可以使共同父组件，触发事件函数传形参的方式来实现  
   兄弟组件：

（1） 按照React单向数据流方式，我们需要借助父组件进行传递，通过父组件回调函数改变兄弟组件的props。  
. 其实这种实现方式与子组件更新父组件状态的方式是大同小异的。

（2） 当组件层次很深的时候，在这里，React官方给我们提供了一种上下文方式，可以让子组件直接访问祖先的数据或函数，无需从祖先组件一层层地传递数据到子组件中。

#### 2.1.2 组件的生命周期

```javascript
construtor() //创建组件
componentWillMount() //组件挂载之前
componentDidMount() // 组件挂载之后
componentWillReceiveProps() // 父组件发生render的时候子组件调用该函数
shouldComponentUpdate() // 组件挂载之后每次调用setState后都会调用该函数判断是否需要重新渲染组件，默认返回true
componentDidUpdate() // 更新
render() //渲染，react中的核心函数
componentWillUnmount() //组件被卸载的时候调用，一般在componentDidMount注册的事件需要在这里删除

123456789
```

![组件的生命周期](http://upload-images.jianshu.io/upload_images/3333422-04ea055c73c50c98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 2.2 vue中的组件和数据流

#### 2.2.1 组件化应用构建

* 组件系统是 Vue 的另一个重要概念，因为它是一种抽象，允许我们使用小型、独立和通常可复用的组件构建大型应用。
* 在 Vue 里，一个组件本质上是一个拥有预定义选项的一个 Vue 实例
* 在一个大型应用中，有必要将整个应用程序划分为组件，以使开发可管理。
* 组件(component)是 Vue 最强大的功能之一。组件可以帮助你扩展基本的 HTML 元素，以封装可重用代码。在较高层面上，组件是 Vue 编译器附加行为后的自定义元素。在某些情况下，组件也可以是原生 HTML 元素的形式，以特定的 is 特性扩展。
* 组件中，data必须是一个函数
* 组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。

#### 2.2.2 响应式

* 当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，视图将会产生“响应”，即匹配更新为新的值。
* 当这些数据改变时，视图会进行重渲染。值得注意的是只有当实例被创建时 data 中存在的属性是响应式的。

#### 2.2.3 组件的生命周期

* 每个 Vue 实例在被创建之前都要经过一系列的初始化过程。例如需要设置数据监听、编译模板、挂载实例到 DOM、在数据变化时更新 DOM 等。同时在这个过程中也会运行一些叫做生命周期钩子的函数，给予用户机会在一些特定的场景下添加他们自己的代码。
* 比如 created 钩子可以用来在一个实例被创建之后执行代码，也有一些其它的钩子，在实例生命周期的不同场景下调用，如 mounted、updated、destroyed。钩子的 this 指向调用它的 Vue 实例。
* 生命周期图示：  
![vue生命周期](https://cn.vuejs.org/images/lifecycle.png)

#### 2.2.4 组件之间的通信

* Vue默认的是单向数据流，这是Vue直接提出来说明的，父组件默认可以向子组件传递数据，但是子组件向父组件传递数据就需要额外设置了。
* Vue 也支持双向绑定，默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。
* 父子组件之间的数据通信是通过Prop和自定义事件实现的，而非父子组件可以使用订阅/发布模式实现（类似于Angualr中的非父子指令之间的通信），再复杂一点也是建议使用状态管理（vuex）。
* 在 Vue 中，父子组件之间的关系可以概述为：props 向下，events 向上。父组件通过 props 向下传递数据给子组件，子组件通过 events 发送消息给父组件。

**1.父向子**  
. 每个组件实例都有自己的孤立隔离作用域。也就是说，不能（也不应该）直接在子组件模板中引用父组件数据。要想在子组件模板中引用父组件数据，可以使用 props 将数据向下传递到子组件。  
. 每个 prop 属性,都可以控制是否从父组件的自定义属性中接收数据。子组件需要使用 props 选项显式声明 props，以便它可以从父组件接收到期望的数据。  
. **动态Props**，类似于将一个普通属性绑定到一个表达式，我们还可以使用 v-bind 将 props 属性动态地绑定到父组件中的数据。无论父组件何时更新数据，都可以将数据向下流入到子组件中

**2.子向父**  
. 使用自定义事件  
. 每个 Vue 实例都接入了一个事件接口(events interface)，也就是说，这些 Vue 实例可以做到：  
. 使用 <mi>o</mi><mi>n</mi><mo>(</mo><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>)</mo><mrow><mo>&#x76D1;</mo></mrow><mrow><mo>&#x542C;</mo></mrow><mrow><mo>&#x4E00;</mo></mrow><mrow><mo>&#x4E2A;</mo></mrow><mrow><mo>&#x4E8B;</mo></mrow><mrow><mo>&#x4EF6;</mo></mrow><mo>&#x2212;</mo><mrow><mo>&#x4F7F;</mo></mrow><mrow><mo>&#x7528;</mo></mrow>" role="presentation" style="position: relative;"><nobr>on(eventName)监听一个事件−使用</nobr><math><mi>o</mi><mi>n</mi><mo>(</mo><mi>e</mi><mi>v</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>N</mi><mi>a</mi><mi>m</mi><mi>e</mi><mo>)</mo><mrow><mo>监</mo></mrow><mrow><mo>听</mo></mrow><mrow><mo>一</mo></mrow><mrow><mo>个</mo></mrow><mrow><mo>事</mo></mrow><mrow><mo>件</mo></mrow><mo>−</mo><mrow><mo>使</mo></mrow><mrow><mo>用</mo></mrow></math>emit(eventName) 触发一个事件

**3. 非父子组件通信**  
. 可以使用一个空的 Vue 实例作为一个事件总线中心(central event bus)，用<mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mrow><mo>&#x89E6;</mo></mrow><mrow><mo>&#x53D1;</mo></mrow><mrow><mo>&#x4E8B;</mo></mrow><mrow><mo>&#x4EF6;</mo></mrow><mrow><mo>&#xFF0C;</mo></mrow>" role="presentation" style="position: relative;"><nobr>emit触发事件，</nobr><math><mi>e</mi><mi>m</mi><mi>i</mi><mi>t</mi><mrow><mo>触</mo></mrow><mrow><mo>发</mo></mrow><mrow><mo>事</mo></mrow><mrow><mo>件</mo></mrow><mrow><mo>，</mo></mrow></math>on监听事件

#### 2.2.5 单向数据流

单向数据流示意图：  
![单向数据流](https://vuex.vuejs.org/zh-cn/images/flow.png)

## 3.状态管理

### ~~3.1 react中的状态管理：Flux~~

* Redux 是 React 生态环境中最流行的 Flux 实现。Redux 事实上无法感知视图层，所以它能够轻松的通过一些简单绑定和 Vue 一起使用。  

  1. 创建actions  

     * 定义动作，事件触发需要用dispatcher来调用
     * 行为，如增加操作、删除操作、更新操作，就是一堆函数。
  2. 创建store  

     * store中包含应用的状态和逻辑，用来管理应用中不同的状态和逻辑，相当于Model层
  3. 创建dispatcher  

     * 在dispatcher中通过register来给每个action注对应的的store中的方法
  4. 在view层调用action中的方法  

     * 就是各类component

![flux的示意图](https://img-blog.csdn.net/20150625201409735?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvd2VueHVhbnNvZnQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

### 3.2 vue中的状态管理vuex

* vuex借鉴了 Flux、Redux、和 The Elm Architecture。与其他模式不同的是，Vuex 是专门为 Vue.js 设计的状态管理库，以利用 Vue.js 的细粒度数据响应机制来进行高效的状态更新。这使得它能够更好地和 Vue 进行整合，同时提供简洁的 API 和改善过的开发体验。

* 组件不允许直接修改属于 store 实例的 state，而应执行 action 来分发 (dispatch) 事件通知 store 去改变，我们最终达成了 Flux 架构。这样约定的好处是，我们能够记录所有 store 中发生的 state 改变，同时实现能做到记录变更 (mutation)、保存状态快照、历史回滚/时光旅行的先进的调试工具。

* 每一个 Vuex 应用的核心就是 store（仓库）。“store”基本上就是一个容器，它包含着你的应用中大部分的状态

* Vuex 和单纯的全局对象有以下两点不同：

  1. Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。

  2. 你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化，从而让我们能够实现一些工具帮助我们更好地了解我们的应用。

  3. State
* Vuex 使用单一状态树——是的，用一个对象就包含了全部的应用层级状态。至此它便作为一个“唯一数据源 (SSOT)”而存在。这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。这也意味着，每个应用将仅仅包含一个 store 实例。  

  1. Getters

* 从state中获取状态值，有时候我们需要从 store 中的 state 中派生出一些状态，例如对列表进行过滤并计数。

  1. Mutation  

     * 更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方，并且它会接受 state 作为第一个参数。
     * 你不能直接调用一个 mutation handler。这个选项更像是事件注册：“当触发一个类型为 increment 的 mutation 时，调用此函数。”要唤醒一个 mutation handler，你需要以相应的 type 调用 store.commit 方法

  2. Action

     * Action 类似于 mutation，不同在于：

     * Action 提交的是 mutation，而不是直接变更状态。
     * Action 可以包含任意异步操作。
     * dispatch分发action

  3. Module
* 由于使用单一状态树，应用的所有状态会集中到一个比较大的对象。当应用变得非常复杂时，store 对象就有可能变得相当臃肿。
* Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割

![vuex示意图](https://raw.githubusercontent.com/vuejs/vuex/dev/docs/en/images/vuex.png)

## 4.路由

* 两者的路由很相似，都是利用了组件化思想

### 4.1 react中的路由

* 在路由库的问题上，React 选择把问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。
* react中，需要引入react-router库，  
  使用时，路由器Router就是React的一个组件。
* Router组件本身只是一个容器，真正的路由要通过Route组件定义。
* Route组件定义了URL路径与组件的对应关系。你可以同时使用多个Route组件。

```javascript
<Router history={hashHistory}>
  <Route path="/" component={App}/>
  <Route path="/repos" component={Repos}/>
  <Route path="/about" component={About}/>
</Router>
12345
```

### 4.2 vue中的路由

* Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。

* 使用 Vue.js ，我们已经可以通过组合组件来组成应用程序，当你要把 vue-router 添加进来，我们需要做的是，**将组件(components)映射到路由(routes)，然后告诉 vue-router 在哪里渲染它们。**

  1. HTML中：

```javascript
<div id="app">
  <h1>Hello App!</h1>
  <p>
    <!-- 使用 router-link 组件来导航. -->
    <!-- 通过传入 `to` 属性指定链接. -->
    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
    <router-link to="/foo">Go to Foo</router-link>
    <router-link to="/bar">Go to Bar</router-link>
  </p>
  <!-- 路由出口 -->
  <!-- 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>
12345678910111213
```

## 5. 渲染性能对比

* 在操作界面时，要尽量减少对DOM的操作，Vue 和 React 都使用虚拟DOM来实现，并且两者工作一样好。
* 尽量减少除DOM操作以外的其他操作。（vue和react的不同）

### 5.1 react视图渲染

* React 的渲染建立在 Virtual DOM 上——一种在内存中描述 DOM 树状态的数据结构。当状态发生变化时，React 重新渲染 Virtual DOM，比较计算之后给真实 DOM 打补丁。

* Virtual DOM 提供了函数式的方法描述视图，它不使用数据观察机制，每次更新都会重新渲染整个应用，因此从定义上保证了视图与数据的同步。它也开辟了 JavaScript 同构应用的可能性。

* 在超大量数据的首屏渲染速度上，React 有一定优势，因为 Vue 的渲染机制启动时候要做的工作比较多，而且 React 支持服务端渲染。

* 元素是构成 React 应用的最小单位。元素用来描述你在屏幕上看到的内容，与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象，React DOM 可以确保 浏览器 DOM 的数据内容与 React 元素保持一致。
* 我们用React 开发应用时一般只会定义一个根节点。但如果你是在一个已有的项目当中引入 React 的话，你可能会需要在不同的部分单独定义 React 根节点。我们将 元素传入一个名为 ReactDOM.render() 的方法来将其渲染到页面上，页面上就会显示该元素。

**组件渲染**  
. 当React遇到的元素是用户自定义的组件，它会将JSX属性作为单个对象传递给该组件,这个对象称之为“props”。

### 5.2 vue视图渲染

* Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪。

* vue渲染的过程如下：

  * new Vue，执行初始化
  * 挂载$mount方法，通过自定义Render方法、template、el等生成Render函数
  * 通过Watcher监听数据的变化
  * 当数据发生变化时，Render函数执行生成VNode对象
  * 通过patch方法，对比新旧VNode对象，通过DOM Diff算法，添加、修改、删除真正的DOM元素

## 6. 数据更新

### 6.1 react数据更新

* React 元素都是immutable 不可变的。当元素被创建之后，你是无法改变其内容或属性的。一个元素就好像是动画里的一帧，它代表应用界面在某一时间点的样子。
* 根据我们现阶段了解的有关 React 知识，更新界面的唯一办法是创建一个新的元素，然后将它传入 ReactDOM.render() 方法

### 6.2 vue数据更新

## 7. 开发模式及规模

### 7.1 react

#### 7.1.1 开发模式

* React本身，是严格的view层，MVC模式

#### 7.1.2 规模

* Vue 提供了Vue-cli 脚手架，能让你非常容易地构建项目，包含了 Webpack，Browserify，甚至 no build system。

### 7.2 vue

#### 7.2.1 开发模式

* Vue是MVVM模式的一种方式实现
* 虽然没有完全遵循 MVVM 模型，Vue 的设计无疑受到了它的启发。因此在文档中经常会使用 vm (ViewModel 的简称) 这个变量名表示 Vue 实例。

#### 7.2.2 脚手架

* React 提供了create-react-app，但是现在还存在一些局限性：  

  * 它不允许在项目生成时进行任何配置，而 Vue 支持 Yeoman-like 定制。
  * 它只提供一个构建单页面应用的单一模板，而 Vue 提供了各种用途的模板。
  * 它不能用用户自建的模板构建项目，而自建模板对企业环境下预先建立协议是特别有用的。

## 8. HTML&&CSS

* 在 React 中，一切都是 JavaScript。不仅仅是 HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。这类方案有其优点，但也存在一些不是每个开发者都能接受的取舍。

Vue 的整体思想是拥抱经典的 Web 技术，并在其上进行扩展。

### 8.1 react

#### 8.1.1 JSX

* 在 React 中，所有的组件的渲染功能都依靠 JSX。JSX 是使用 XML 语法编写 JavaScript 的一种语法糖。

* JSX, 一种 JavaScript 的语法扩展。 我们推荐在 React 中使用 JSX 来描述用户界面。JSX 乍看起来可能比较像是模版语言，但事实上它完全是在 JavaScript 内部实现的。

* JSX 用来声明 React 当中的元素。
* JSX本身也是一种表达式，在编译之后呢，JSX 其实会被转化为普通的 JavaScript 对象。这也就意味着，你其实可以在 if 或者 for 语句里使用 JSX，将它赋值给变量，当作参数传入，作为返回值都可以
* JSX 说是手写的渲染函数有下面这些优势：  

  * 你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。
  * 开发工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的 (比如，linting、类型检查、编辑器的自动完成)。

#### 8.1.2 组件作用域内的CSS

* 除非你把组件分布在多个文件上 (例如 CSS Modules)，CSS 作用域在 React 中是通过 CSS-in-JS 的方案实现的 (比如 styled-components、glamorous 和 emotion)。这引入了一个新的面向组件的样式范例，它和普通的 CSS 撰写过程是有区别的。另外，虽然在构建时将 CSS 提取到一个单独的样式表是支持的，但 bundle 里通常还是需要一个运行时程序来让这些样式生效。当你能够利用 JavaScript 灵活处理样式的同时，也需要权衡 bundle 的尺寸和运行时的开销。

### 8.2 vue

#### 8.2.1 Templates模板语法

* 事实上 Vue 也提供了渲染函数，甚至支持 JSX。然而，我们默认推荐的还是模板。任何合乎规范的 HTML 都是合法的 Vue 模板，这也带来了一些特有的优势：  

  * 对于很多习惯了 HTML 的开发者来说，模板比起 JSX 读写起来更自然。这里当然有主观偏好的成分，但如果这种区别会导致开发效率的提升，那么它就有客观的价值存在。
  * 基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。
  * 这也使得设计师和新人开发者更容易理解和参与到项目中。
  * 你甚至可以使用其他模板预处理器，比如 Pug 来书写 Vue 的模板。
* Vue.js 使用了基于 HTML 的模板语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。所有 Vue.js 的模板都是合法的 HTML ，所以能被遵循规范的浏览器和 HTML 解析器解析。
* 在底层的实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合响应系统，在应用状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。

#### 8.2.2 单文件组件CSS

* Vue 设置样式的默认方法是单文件组件里类似 style 的标签。  
  单文件组件让你可以在**同一个文件里完全控制 CSS**，将其作为组件代码的一部分。
* Vue 的单文件组件里的样式设置是非常灵活的。通过 vue-loader，你可以使用任意预处理器、后处理器，甚至深度集成 CSS Modules——全部都在

### 8.3 小结

* 更抽象一点来看，我们可以把组件区分为两类：一类是**偏视图表现**的 (presentational)，一类则是**偏逻辑**的 (logical)。我们推荐在前者中使用模板，在后者中使用 JSX 或渲染函数。这两类组件的比例会根据应用类型的不同有所变化，但整体来说我们发现表现类的组件远远多于逻辑类组件。

## 9. 使用场景

### 9.1 选择react

#### 9.1.1 期待构建一个大型应用程序——选择React

* 同时用Vue和React实现的简单应用程序，可能会让一个开发者潜意识中更加倾向于Vue。这是因为基于模板的应用程序第一眼看上去更加好理解，而且能很快跑起来。但是这些好处引入的技术债会阻碍应用扩展到更大的规模。模板容易出现很难注意到的运行时错误，同时也很难去测试，重构和分解。  
  相比之下，Javascript模板可以组织成具有很好的分解性和干（DRY）代码的组件，干代码的可重用性和可测试性更好。Vue也有组件系统和渲染函数，但是React的渲染系统可配置性更强，还有诸如浅（shallow）渲染的特性，和React的测试工具结合起来使用，使代码的可测试性和可维护性更好。  
  与此同时，React的immutable应用状态可能写起来不够简洁，但它在大型应用中意义非凡，因为透明度和可测试性在大型项目中变得至关重要。

#### 9.1.2 期待同时适用于Web端和原生APP的框架——选择React

* React Native是一个使用Javascript构建移动端原生应用程序（iOS，Android）的库。 它与React.js相同，只是不使用Web组件，而是使用原生组件。 如果你学过React.js，很快就能上手React Native，反之亦然。  
  它的意义在于，开发者只需要一套知识和工具就能开发Web应用和移动端原生应用。如果你想同时做Web端开发和移动端开发，React为你准备了一份大礼。  
  阿里的Weex也是一个跨平台UI项目，目前它以Vue为灵感，使用了许多相同的语法，同时计划在未来完全集成Vue，然而集成的时间和细节还不清楚。因为Vue将HTML模板作为它设计的核心部分，并且现有特性不支持自定义渲染，因此很难看出目前的Vue.js的跨平台能力能像React和React Native一样强大。

#### 9.1.3 期待最大的生态系统——选择React

* 毫无疑问，React是目前最受欢迎的前端框架。它在NPM上每个月的下载量超过了250万次，相比之下，Vue是22.5万次。人气不仅仅是一个肤浅的数字，这意味着更多的文章，教程和更多Stack Overflow的解答，还意味有着更多的工具和插件可以在项目中使用，让开发者不再孤立无援。  
  这两个框架都是开源的，但是React诞生于Facebook，有Facebook背书，它的开发者和Facebook都承诺会持续维护React。相比之下，Vue是独立开发者尤雨溪的作品。尤雨溪目前在全职维护Vue，也有一些公司资助Vue，但是规模和Facebook和Google没得比。不过请对Vue的团队放心，它的小规模和独立性并没有成为劣势，Vue有着固定的发布周期，甚至更令人称道的是，Github上Vue只有54个open issue，3456个closed issue，作为对比，React有多达530个open issue，3447个closed issue。

### 9.2 选择vue

#### 9.2.1 期待模板搭建应用——选择 Vue

* Vue应用的默认选项是把markup放在HTML文件中。数据绑定表达式采用的是和Angular相似的mustache语法，而指令（特殊的HTML属性）用来向模板添加功能。  
  相比之下，React应用不使用模板，它要求开发者借助JSX在JavaScript中创建DOM。
* 对于来自标准Web开发方式的新开发者，模板更容易理解。但是一些资深开发者也喜欢模板，因为模板可以更好的把布局和功能分割开来，还可以使用Pug之类的模板引擎。  
  但是使用模板的代价是不得不学习所有的HTML扩展语法，而渲染函数只需要会标准的HTML和JavaScript。而且比起模板，渲染函数更加容易调试和测试。当然你不应该因为这方面的原因错过Vue，因为在Vue2.0中提供了使用模板或者渲染函数的选项。

#### 9.2.2 期待简单和“能用就行”的东西——选择 Vue

* 一个简单的Vue项目可以不需要转译直接运行在浏览器中，所以使用Vue可以像使用jQuery一样简单。当然这对于React来说在技术上也是可行的，但是典型的React代码是重度依赖于JSX和诸如class之类的ES6特性的。  
  Vue的简单在程序设计的时候体现更深，让我们来比较一下两个框架是怎样处理应用数据的（也就是state）。
* React中是通过比较当前state和前一个state来决定何时在DOM中进行重渲染以及渲染的内容，因此需要不可变（immutable）的state。  
  Vue中的数据是可变（mutated）的，所以同样的操作看起来更加简洁。  
  让我们来看看Vue中是如何进行状态管理的。当向state添加一个新对象的时候，Vue将遍历其中的所有属性并且转换为getter，setter方法，现在Vue的响应系统开始保持对state的跟踪了，当state中的内容发生变化的时候就会自动重新渲染DOM。令人称道的是，Vue中改变state的状态的操作不仅更加简洁，而且它的重新渲染系统也比React 的更快更有效率。
* Vue的响应系统还有有些坑的，例如：它不能检测属性的添加和删除和某些数组更改。这时候就要用到Vue API中的类似于React的set方法来解决。

#### 9.2.3 期待应用尽可能的小和快——选择Vue

* 当应用程序的状态改变时，React和Vue都将构建一个虚拟DOM并同步到真实DOM中。 两者都有各自的方法优化这个过程。  
  Vue核心开发者提供了一个benchmark测试，可以看出Vue的渲染系统比React的更快。测试方法是10000个项目的列表渲染100次，结果如下图。从实用的观点来看，这种benchmark只和边缘情况有关，大部分应用程序中不会经常进行这种操作，所以这不应该被视为一个重要的比较点。但是，页面大小是与所有项目有关的，这方面Vue再次领先，它目前的版本压缩后只有25.6KB。React要实现同样的功能，你需要React DOM（37.4KB）和React with Addon库（11.4KB），共计44.8KB，几乎是Vue的两倍大。双倍的体积并不能带来双倍的功能。

## 10. 服务器端渲染（SSR）

* 客户端渲染路线：1. 请求一个html -> 2. 服务端返回一个html -> 3. 浏览器下载html里面的js/css文件 -> 4. 等待js文件下载完成 -> 5. 等待js加载并初始化完成 -> 6. js代码终于可以运行，由js代码向后端请求数据( ajax/fetch ) -> 7. 等待后端数据返回 -> 8. react-dom( 客户端 )从无到完整地，把数据渲染为响应页面

* 服务端渲染路线：1. 请求一个html -> 2. 服务端请求数据( 内网请求快 ) -> 3. 服务器初始渲染（服务端性能好，较快） -> 4. 服务端返回已经有正确内容的页面 -> 5. 客户端请求js/css文件 -> 6. 等待js文件下载完成 -> 7. 等待js加载并初始化完成 -> 8. react-dom( 客户端 )把剩下一部分渲染完成( 内容小，渲染快 )

### 10.1 react

* React的虚拟DOM是其可被用于服务端渲染的关键。首先每个ReactComponent 在虚拟DOM中完成渲染，然后React通过虚拟DOM来更新浏览器DOM中产生变化的那一部分，虚拟DOM作为内存中的DOM表现，为React在Node.js这类非浏览器环境下的吮吸给你提供了可能，React可以从虚拟DoM中生成一个字符串。而不是跟新真正的DOM，这使得我们可以在客户端和服务端使用同一个React Component。

* React 提供了两个可用于服务端渲染组件的函数：React.renderToString 和React.render-ToStaticMarkup。 在设计用于服务端渲染的ReactComponent时需要有预见性，考虑以下方面。

  * 选取最优的渲染函数。
  * 如何支持组件的异步状态。
  * 如何将应用的初始化状态传递到客户端。
  * 哪些生命周期函数可以用于服务端的渲染。
  * 如何为应用提供同构路由支持。
  * 单例、实例以及上下文的用法。

### 10.2 vue

**1. 什么是服务器端渲染（SSR）？**

* Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将静态标记”混合”为客户端上完全交互的应用程序。

* 服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在服务器和客户端上运行。

**2. 服务器端渲染优势**  
. 更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。  
. 更快的内容到达时间(time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content)与转化率直接相关」的应用程序而言，服务器端渲染(SSR)至关重要。

## 11. 附： react理念

### 1. 把UI图划分出组件层级

### 2. 用React创建一个静态版本

* 传入数据模型，渲染 UI 但没有任何交互。最好把这些过程解耦，因为创建一个静态版本更多需要的是码代码，不太需要逻辑思考，而添加交互则更多需要的是逻辑思考，不是码代码。
* 在创建静态版本的时候不要使用 state。
* 你可以自顶向下或者自底向上构建应用。也就是，你可以从层级最高的组件开始构建(即 FilterableProductTable开始)或层级最低的组件开始构建(ProductRow)。在较为简单的例子中，通常自顶向下更容易，而在较大的项目中，自底向上会更容易并且在你构建的时候有利于编写测试。
* React 的单向数据流(也叫作单向绑定)保证了一切是模块化并且是快速的。

#### 3. 定义 UI 状态的最小(但完整)表示

* 想想实例应用中的数据，让我们来看看每一条，找出哪一个是 state。每个数据只要考虑三个问题：

  * 它是通过 props 从父级传来的吗？如果是，他可能不是 state。
  * 它随着时间推移不变吗？如果是，它可能不是 state。
  * 你能够根据组件中任何其他的 state 或 props 把它计算出来吗？如果是，它不是 state。

#### 4. 确定你的State应该位于哪里

* 对你应用的每一个 state：

  * 确定每一个需要这个 state 来渲染的组件。
  * 找到一个公共所有者组件(一个在层级上高于所有其他需要这个 state 的组件的组件)
  * 这个公共所有者组件或另一个层级更高的组件应该拥有这个 state。
  * 如果你没有找到可以拥有这个 state 的组件，创建一个仅用来保存状态的组件并把它加入比这个公共所有者组件层级更高的地方。

#### 5. 添加反向数据流

## 小结

总结一下，我们发现，  
. Vue的优势包括：  
. 模板和渲染函数的弹性选择  
. 简单的语法及项目创建  
. 更快的渲染速度和更小的体积  
. React的优势包括：  
. 更适用于大型应用和更好的可测试性  
. 同时适用于Web端和原生App  
. 更大的生态圈带来的更多支持和工具  
. 而实际上，React和Vue都是非常优秀的框架，它们之间的相似之处多过不同之处，并且它们大部分最棒的功能是相通的：  
. 利用**虚拟DOM**实现快速渲染  
. 轻量级  
. 响应式和组件化  
. 服务器端渲染  
. 易于集成路由工具，打包工具以及状态管理工具  
. 优秀的支持和社区

文章参考来源：

* [vue官方文档关于框架的对比](https://cn.vuejs.org/v2/guide/comparison.html)
* [react中文文档](https://discountry.github.io/react/docs/hello-world.html)
* [vue官方文档](https://cn.vuejs.org/v2/guide/installation.html)

           

## 86.V8 引擎了解多少？【Nodejs、网络】
**回答:**      
目录                  
- [渲染引擎与网页渲染](#渲染引擎与网页渲染)
    - [编程分类](#编程分类)
    - [渲染引擎](#渲染引擎)
    - [网页渲染流程简析](#网页渲染流程简析)
- [JavaScript引擎](#JavaScript引擎)
- [V8引擎](#V8引擎)
    - [数据解析](#数据解析)
    - [V8引擎渲染过程](#V8引擎渲染过程)
    - [JavaScript代码编译过程](#JavaScript代码编译过程)
    - [优化回滚](#优化回滚)
    - [内存管理](#内存管理)
    - [垃圾回收](#垃圾回收)
    - [快照](#快照)
    - [V8 VS JavaScriptCore](#V8-VS-JavaScriptCore)
- [功能扩展](#功能扩展)
    - [绑定](#绑定)
    - [Extension](#Extension)
- [总结](#总结)
    

## 渲染引擎与网页渲染
### 编程分类
编程语言分为 **编译型语言和解释型语** 言两类。                              
编译型语言在执行之前要先进行完全编译，而 **解释型语言一边编译一边执行**，
很明显解释型语言的执行速度是慢于编译型语言的，而JavaScript就是一种解释型脚本语言，
支持动态类型、弱类型、基于原型的语言，内置支持类型。

### 渲染引擎
就是将HTML/CSS/JavaScript等文本或图片等信息转换成浏览器上可见的可视化图像结果的转换程序。              
WebKit，一个由苹果发起的一个开源项目，如今它在移动端占据着垄断地位，更有基于WebKit的web操作系统不断涌现(如：Chrome OS、Web OS)。                        

WebKit内部结构大体如下                      
![01](https://user-images.githubusercontent.com/22188674/224484181-6bb95a67-aae8-46bb-a3ce-7565bf891ed0.png)                                 

上图中实线框内模块是所有移植的共有部分，虚线框内不同的厂商可以自己实现。由上图可知，WebKit主要有操作系统、WebCore 、WebKit嵌入式接口和第三方库组成。

**操作系统**: 是管理和控制计算机硬件与软件资源的计算机程序。                           
**WebCore**: JavaScriptCore是WebKit的默认引擎，在谷歌系列产品中被替换为V8引擎。                           
**WebKit嵌入式接口**: 该接口主要供浏览器调用，与移植密切相关，不同的移植有不同的接口规范。
**第三方库**: 主要是诸如图形库、网络库、视频库、数据存储库等第三方库。

### 网页渲染流程简析
首先，系统将网页输入到HTML解析器，HTML解析器解析，然后构建DOM树，在这期间如果遇到JavaScript代码则交给JavaScript引擎处理；
如果遇到CSS样式信息，则构建一个内部绘图模型。该模型由布局模块计算模型内部各个元素的位置和大小信息，最后由绘图模块完成从该模型到图像的绘制。 

对于网页的绘制过程，大体可以分为3个阶段：                               

**1、从输入URL到生成DOM树**                             
在这个阶段中，主要会经历一下几个步骤：                                                                                      
地址栏输入URL，WebKit调用资源加载器加载相应资源；                                                               
加载器依赖网络模块建立连接，发送请求并接收答复；                                                                
WebKit接收各种网页或者资源数据，其中某些资源可能同步或异步获取；                                                             
网页交给HTML解析器转变为词语；                                                               
解释器根据词语构建节点，形成DOM树；                                                             
如果节点是JavaScript代码，调用JavaScript引擎解释并执行；                                                              
JavaScript代码可能会修改DOM树结构；                                                                
如果节点依赖其他资源，如图片、视频等，调用资源加载器加载它们，但这些是异步加载的，不会阻碍当前DOM树继续创建；如果是JavaScript资源URL（没有标记异步方式），则需要停止当前DOM树创建，直到JavaScript加载并被JavaScript引擎执行后才继续DOM树的创建。

**2、从DOM树到构建WebKit绘图上下文**                                                             
CSS文件被CSS解释器解释成内部表示；                                                                                
CSS解释器完成工作后，在DOM树上附加样式信息，生成RenderObject树；                                                                                                       
RenderObject节点在创建的同时，WebKit会根据网页层次结构构建RenderLayer树，同时构建一个虚拟绘图上下文。                                                                                                            

**3、绘图上下文内容并呈现图像内容**                                    
绘图上下文是一个与平台无关的抽象类，它将每个绘图操作桥接到不同的具体实现类，也就是绘图具体实现类；                                       
绘图实现类也可能有简单的实现，也可能有复杂的实现，软件渲染、硬件渲染、合成渲染等；                                       
绘图实现类将2D图形库或者3D图形库绘制结果保存，交给浏览器界面进行展示。                                       

[这一部分内容还可以看这里：渲染机制](/books/专题知识库/05、基础知识点专题/02_01、进阶知识部分1-10.md#no01-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6)                                        

## JavaScript引擎
JavaScript这种解释性语言来讲，如何提高解析速度就是当务之急。JavaScript引擎和渲染引擎的关系如下图所示                                                                  
![02](https://user-images.githubusercontent.com/22188674/224484189-606623ef-308f-4b4e-a931-49cccf2f7b9a.png)                                         

为了提高性能，JavaScript引入了Java虚拟机和C++编译器中的众多技术。
而一个完整JavaScript引擎的执行过程大致流程如下：**源代码-→抽象语法树-→字节码-→JIT-→本地代码**。一个典型的抽象语法树如下图所示：                                    

题外话 关于 JIT:                 
JIT 编译 (JIT compilation)，运行时需要代码时。                      
JIT具体的做法是这样的:当载入一个类型时,CLR为该类型创建一个内部数据结构和相应的函数,当函数第一被调用时,JIT将该函数编译成机器语言.当再次遇到该函数时则直接从cache中执行已编译好的机器语言.                              

为了节约将抽象语法树通过JIT技术转换成本地代码的时间，V8放弃了生成字节码阶段的性能优化。而通过Profiler采集一些信息，来优化本地代码。                            
在2017年4月底，v8 发布了5.9 版本，在此版本中新增了一个 Ignition 字节码解释器，并默认开启。
做出这一改变的原因为：（主要动机）减轻机器码占用的内存空间，即牺牲时间换空间；
提高代码的启动速度；对 v8 的代码进行重构，降低 v8 的代码复杂度（[详细介绍请查阅：JS 引擎与字节码的不解之缘](https://cnodejs.org/topic/59084a9cbbaf2f3f569be482)）

## V8引擎
前面，我们介绍了V8引擎的一些历史，下面我们重点来看看V8项目一些知识。首先，V8项目的结构如下：                       
![03](https://user-images.githubusercontent.com/22188674/224484198-70bd0c01-6b45-43ba-acb5-69453aa11b80.png)                         

### 数据解析
JavaScript作为一种无类型的语言，在编译时并不能准确知道变量的类型，只可以在运行时确定。因而JavaScript运行效率比C++或Java低。                                         
而对于JavaScript 来说，并不能像C++那样在执行时已经知道变量的类型和地址，所以在代码解析过程中，会产生很多的临时变量，而变量的存取是非常普遍和频繁的。                                       
在JavaScript中，除boolean，number，string，null，undefined这个五个简单变量外，其他的数据都是对象，V8使用一种特殊的方式来表示它们，进而优化JavaScript的内部表示问题。                                           

JavaScript对象在V8中的实现包含三个部分：隐藏类指针，这是v8为JavaScript对象创建的隐藏类；属性值表指针，指向该对象包含的属性值；元素表指针，指向该对象包含的属性。                                

在V8中，数据的内部表示由数据的实际内容和数据的句柄构成。数据的实际内容是变长的，类型也是不同的；句柄固定大小，包含指向数据的指针。
这种设计可以方便V8进行垃圾回收和移动数据内容，如果直接使用指针的话就会出问题或者需要更大的开销，
使用句柄的话，只需修改句柄中的指针即可，使用者使用的还是句柄，指针改动是对使用者透明的。

除少数数据(如整型数据)由handle本身存储外，其他内容限于句柄大小和变长等原因，都存储在堆中。
整数直接从value中取值，然后使用一个指针指向它，可以减少内存的占用并提高访问速度。
一个句柄对象的大小是4字节(32位设备)或者8字节(64位设备)，而在JavaScriptCore中，使用的8个字节表示句柄。
在堆中存放的对象都是4字节对齐的，所以它们指针的后两位是不需要的，V8用这两位表示数据的类型，00为整数，01为其他。

### V8引擎渲染过程
V8引擎在执行JavaScript的过程中，主要有两个阶段：编译和运行。                                        
在V8引擎中，源代码先被解析器转变为抽象语法树(AST)，然后使用JIT编译器的全代码生成器从AST直接生成本地可执行代码。                                      
但由于缺少了转换为字节码这一中间过程，也就减少了优化代码的机会。                                        

V8引擎编译本地代码时使用的主要类如下所示：                                              
**Script**：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；                                                          
**Compiler**：编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；                                                          
**AstNode**：抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；                                                           
**FullCodeGenerator**：AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。                                                          


### JavaScript代码编译过程
Script类调用Compiler类的Compile函数为其生成本地代码；                                                   
Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码；                                                  
本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。                                                   

大体的流程图如下所示：                                             
![04](https://user-images.githubusercontent.com/22188674/224484204-a4d766cc-3179-4d40-bb8a-9bd8e574886e.png)                                                     

在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。
但是，在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是采用在调用时才会编译的逻辑来动态编译。                                                      

由于V8缺少了生成中间字节码这一环节，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，
然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。
当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚。                                                                            

在这一阶段涉及的类主要有：                                   
Script：表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；                                                                  
Execution：运行代码的辅组类，包含一些重要函数，如Call函数，它辅组进入和执行Script代码；                                                                   
JSFunction：需要执行的JavaScript函数表示类；                                                                    
Runtime：运行这些本地代码的辅组类，主要提供运行时所需的辅组函数，如：属性访问、类型转换、编译、算术、位操作、比较、正则表达式等；                                                                    
Heap：运行本地代码需要使用的内存堆类；                                                                   
MarkCompactCollector：垃圾回收机制的主要实现类，用来标记、清除和整理等基本的垃圾回收过程；                                                                 
SweeperThread：负责垃圾回收的线程。                                                                    

在V8中，函数是一个基本单位，当某个JavaScript函数被调用时，V8会查找该函数是否已经生成本地代码，如果已经生成，则直接调用该函数。
否则，V8引擎会生成属于该函数的本地代码。
这样，对于那些不用的代码就可以减少执行时间。再次借助Runtime类中的辅组函数，将不用的空间进行标记清除和垃圾回收。                                                 

### 优化回滚
因为V8是基于AST直接生成本地代码，没有经过中间表示层的优化，所以本地代码尚未经过很好的优化。
于是，在2010年，V8引入了新的编译器-Crankshaft，它主要针对热点函数进行优化，
基于JavaScript源代码开始分析而非本地代码，同时构建Hydroger图并基于此来进行优化分析。

Crankshaft编译器为了性能考虑，通常会做出比较乐观和大胆的预测—代码稳定且变量类型不变，所以可以生成高效的本地代码。
但是，鉴于JavaScript的一个弱类型的语言，变量类型也可能在执行的过程中进行改变，鉴于这种情况，V8会将该编译器做的想当然的优化进行回滚，称为优化回滚。                             

例如，下面的示例：
```javascript
var counter = 0;
function test(x, y) {
    counter++;
    if (counter < 1000000) {
        // do something
        return 'jeri';
    }
    var unknown = new Date();
    console.log(unknown);
}
``` 
该函数被调用多次之后，V8引擎可能会触发Crankshaft编译器对其进行优化，而优化代码认为示例代码的类型信息都已经被确定。
当程序执行到new Date()这个地方，并未获取unknown这个变量的类型，V8只得将该部分代码进行回滚。

优化回滚是一个很耗时的操作，在写代码过程中，尽量不要触发优化该操作。在最近发布的 V8 5.9 版本中，新增了一个 Ignition 字节码解释器，
TurboFan 和 Ignition 结合起来共同完成JavaScript的编译。
这个版本中消除 Cranshaft 这个旧的编译器，并让新的 Turbofan 直接从字节码来优化代码，
并当需要进行反优化的时候直接反优化到字节码，而不需要再考虑 JS 源代码。

### 内存管理
Node中通过JavaScript使用内存时就会发现只能使用部分内存（64位系统下约为1.4 GB，32位系统下约为0.7 GB），
其深层原因是 V8 垃圾回收机制的限制所致（如果可使用内存太大，V8在进行垃圾回收时需耗费更多的资源和时间，严重影响JS的执行效率）。下面对内存管理进行介绍。                         

内存的管理组要由分配和回收两个部分构成。V8的内存划分如下：                                              
**Zone**：管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，
只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。                                                                                                                
**堆**：管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分(这和Java等的堆不一样)：                                                                                                               
    **年轻分代**：为新创建的对象分配内存空间，经常需要进行垃圾回收。
    为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。                                                                                                              
    **年老分代**：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。                                                                                                               
    **大对象**：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。                                                                                                             

用一张图可以表示如下：                                             
![05](https://user-images.githubusercontent.com/22188674/224484225-4b86d1f8-1b8f-4eda-8cbf-9b7dec04556b.png)                                                                             

### 垃圾回收                                            
V8 使用了分代和大数据的内存分配，在回收内存时使用精简整理的算法标记未引用的对象，然后消除没有标记的对象，最后整理和压缩那些还未保存的对象，即可完成垃圾回收。                            
在V8中，使用较多的是年轻分代和年老分代。年轻分代中的对象垃圾回收主要通过 **Scavenge** 算法进行垃圾回收。在Scavenge的具体实现中，主要采用了 **Cheney** 算法。                        

Cheney算法：通过复制的方式实现的垃圾回收算法。
它将堆内存分为两个 semispace（半空间），一个处于使用中（From空间），另一个处于闲置状态（To空间）。
当分配对象时，先是在From空间中进行分配。
当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。
完成复制后，From空间和To空间的角色发生对换。在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。                                     

年轻分代中的对象有机会晋升为年老分代，条件主要有两个：一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。                                                  

对于年老分代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：
一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。
为此，V8在年老分代中主要采用了**Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）** 相结合的方式进行垃圾回收。                           

### 快照                              
在V8引擎启动时，需要构建JavaScript运行环境，需要加载很多内置对象，
同时也需要建立内置的函数，如Array，String，Math等。为了使V8更加整洁，
加载对象和建立函数等任务都是使用JavaScript文件来实现的，V8引擎负责提供机制来支持，就是在编译和执行JavaScript前先加载这些文件。                      

V8引擎需要编译和执行这些内置的JavaScript代码，同时使用堆等来保存执行过程中创建的对象、代码等，这些都需要时间。
为此，V8引入了快照机制，将这些内置的对象和函数加载之后的内存保存并序列化。经过快照机制的启动时间可以缩减几毫秒。                           

## V8 VS JavaScriptCore
JavaScriptCore引擎是WebKit中默认的JavaScript引擎，也是苹果开源的一个项目，应用较为广泛。
最初，性能不是很好，从2008年开始了一系列的优化，重新实现了编译器和字节码解释器，使得引擎的性能有较大的提升。
随后内嵌缓存、基于正则表达式的JIT、简单的JIT及字节码解释器等技术引入进来，JavaScriptCore引擎也在不断的迭代和发展。                         

JavaScriptCore 的大致流程为：源代码-→抽象语法树-→字节码-→JIT-→本地代码。                                       
JavaScriptCore与V8有一些不同之处，其中最大的不同就是新增了字节码的中间表示，
并加入了多层JIT编译器（如：简单JIT编译器、DFG JIT编译器、LLVM等）优化性能，不停的对本地代码进行优化(在V8 的 5.9 版本中，新增了一个 Ignition 字节码解释器)。                                                                                

## 功能扩展                         
JavaScript引擎的主要功能是解析和执行JavaScript代码，往往不能满足使用者多样化的需要，
那么就可以增加扩展以提升它的能力。V8引擎有两种扩展机制：绑定和扩展。

### 绑定                  
使用IDL文件或接口文件生成绑定文件，将这些文件同V8引擎一起编译。
WebKit中使用IDL来定义JavaScript，但又与IDL有所不同，有一些改变。定义一个新的接口的步骤大致如下：                     
1.定义新的接口文件，可以在JavaScript代码进行调用，如mymodule.MyObj.myAttr：                      
```javascript
module mymodule {
    interface [
            InterfaceName = MyObject
    ] MyObj { 
        readonly attribute long myAttr;
        DOMString myMethod (DOMString myArg);
    };
}
``` 

2.按照引擎定义的标准接口为基础实现接口类，生成JavaScript引擎所需的绑定文件。
WebKit提供了工具帮助生成所需的绑定类，根据引擎不同和引擎开发语言的不同而有所差异。
V8引擎会为上述示例代码生成 v8MyObj.h (MyObj类具体的实现代码)和 V8MyObj.cpp (桥接代码，辅组注册桥接的函数到V8引擎)两个绑定文件。

JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，
不能根据需要在引擎启动后再动态注入这些本地代码。
在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，
绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。

### Extension                       
通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很强的灵活性。                          
Extension机制的大致思路就是，V8提供一个基类Extension和一个全局注册函数，要想扩展JavaScript能力，需要经过以下步骤：                                    
```c++
class MYExtension : public v8::Extension {
    public:
        MYExtension() : v8::Extension("v8/My", "native function my();") {}
        virtual v8::Handle<v8::FunctionTemplate> GetNativeFunction (
        v8::Handle<v8::String> name) {
            // 可以根据name来返回不同的函数
            return v8::FunctionTemplate::New(MYExtention::MY);
        }
        static v8::Handle<v8::Value> MY(const v8::Arguments& args) {
            // Do sth here
            return v8::Undefined();
        }
};
MYExtension extension;
RegisterExtension(&extension);
```
1.基于Extension基类构建一个它的子类，并实现它的虚函数—GetNativeFunction，根据参数name来决定返回实函数；                            
2.创建一个该子类的对象，并通过注册函数将该对象注册到V8引擎，当JavaScript调用’my’函数时就可被调用到。
Extension机制是调用V8的接口注入新函数，动态扩展非常方便，但没有绑定机制高效，适用于对性能要求不高的场景。

## 总结                           
作为一个提高JavaScript渲染的高效引擎，学习V8引擎应该重点掌握以下几个概念：

- 类型。                                                                                                                                                                       
    对于函数，JavaScript是一种动态类型语言，JavaScriptCore和V8都使用隐藏类和内嵌缓存来提高性能，
    为了保证缓存命中率，一个函数应该使用较少的数据类型；
    对于数组，应尽量存放相同类型的数据，这样就可以通过偏移位置来访问。                       
- 数据表示。                     
    简单类型数据（如整型）直接保存在句柄中，可以减少寻址时间和内存占用，
    如果可以使用整数表示的，尽量不要用浮点类型。
- 内存。
    虽然JavaScript语言会自己进行垃圾回收，但我们也应尽量做到及时回收不用的内存，
    对不再使用的对象设置为null或使用delete方法来删除(使用delete方法删除会触发隐藏类新建，需要更多的额外操作)。
- 优化回滚。
    在执行多次之后，不要出现修改对象类型的语句，尽量不要触发优化回滚，否则会大幅度降低代码的性能。 
- 新机制。
    使用JavaScript引擎或者渲染引擎提供的新机制和新接口提高性能。



参考文章如下：                     
[Google V8 引擎【翻】](https://blog.csdn.net/xiangzhihong8/article/details/74996757)

           

## 87.如何进行 node 内存优化？【Nodejs】
**回答:**      
目录
- [V8 内存生命周期](#V8内存生命周期)
- [垃圾回收器](#垃圾回收器)
    - [JavaScript的垃圾回收器](#JavaScript的垃圾回收器)
    - [内存管理问题](#内存管理问题)
- [Chrome的内存限制](#Chrome的内存限制)
    - [存在限制](#存在限制)
    - [为何限制](#为何限制)
- [Chrome-V8的堆构成](#ChromeV8的堆构成)
- [ChromeV8的垃圾回收机制](#ChromeV8的垃圾回收机制)
    - [如何判断回收内容](#如何判断回收内容)
    - [如何识别指针和数据](#如何识别指针和数据)
    - [V8的回收策略](#V8的回收策略)
    - [V8的分代内存](#V8的分代内存)
- [新生代](#新生代)
    - [新生代的特点](#新生代的特点)
    - [新生代的垃圾回收算法](#新生代的垃圾回收算法)
    - [写屏障](#写屏障)
    - [对象的晋升](#对象的晋升)
- [老生代](#老生代)
    - [老生代的特点](#老生代的特点)
    - [老生代的垃圾回收算法](#老生代的垃圾回收算法)
    - [算法思路](#算法思路)
    - [结合使用标记清除和标记整理](#结合使用标记清除和标记整理)
    

[前置知识点儿请看这里](/books/专题知识库/05、基础知识点专题/other/14、V8引擎初步介绍/README.md)

## V8内存生命周期
假设代码中有一个对象 jerry ，这个对象从创建到被销毁，刚好走完了整个生命周期，通常会是这样一个过程：                                                              
1、这个对象被分配到了 new space；                                
2、随着程序的运行，new space 塞满了，gc 开始清理 new space 里的死对象，jerry 因为还处于活跃状态，所以没被清理出去；                             
3、gc 清理了两遍 new space，发现 jerry 依然还活跃着，就把 jerry 移动到了 old space；                             
4、随着程序的运行，old space 也塞满了，gc 开始清理 old space，这时候发现 jerry 已经没有被引用了，就把 jerry 给清理出去了。                      

说明：                     
第二步里，清理 new space 的过程叫做 **Scavenge**，这个过程采用了空间换时间的做法，
用到了上面图中的 **inactive new space**，过程如下：                                               
当活跃区满了之后，交换活跃区和非活跃区，交换后活跃区变空了；                                  
将非活跃区的两次清理都没清理出去的对象移动到 old space；                                   
将还没清理够两次的但是活跃状态的对象移动到活跃区。                                                          

第四步里，清理 old space 的过程叫做 **Mark-sweep** ，这块占用内存很大，所以没有使用 Scavenge，
这个回收过程包含了若干次标记过程和清理过程：                              
标记从根（root）可达的对象为黑色；                             
遍历黑色对象的邻接对象，直到所有对象都标记为黑色；                               
循环标记若干次；                                
清理掉非黑色的对象。                              

简单来说，**Mark-sweep 就是把从根节点无法获取到的对象清理掉了。**                    

## 垃圾回收器
### JavaScript的垃圾回收器                    
JavaScript使用垃圾回收机制来自动管理内存。                          
垃圾回收是一把双刃剑，其好处是可以大幅简化程序的内存管理代码，降低程序员的负担，减少因 长时间运转而带来的内存泄露问题。
但使用了垃圾回收即意味着程序员将无法掌控内存。                             
ECMAScript没有暴露任何垃圾回收器的接口。我们无法强迫其进 行垃圾回收，更无法干预内存管理                               

### 内存管理问题                      
在浏览器中，Chrome V8引擎实例的生命周期不会很长（谁没事一个页面开着几天几个月不关），而且运行在用户的机器上。
如果不幸发生内存泄露等问题，仅仅会 影响到一个终端用户。
且无论这个V8实例占用了多少内存，最终在关闭页面时内存都会被释放，几乎没有太多管理的必要（当然并不代表一些大型Web应用不需 要管理内存）。
但如果使用Node作为服务器，就需要关注内存问题了，一旦内存发生泄漏，久而久之整个服务将会瘫痪（服务器不会频繁的重启）。

## Chrome的内存限制
### 存在限制                    
Chrome限制了所能使用的内存极限（64位为1.4GB，32位为1.0GB），这也就意味着将无法直接操作一些大内存对象。                           

### 为何限制                        
Chrome之所以限制了内存的大小，表面上的原因是V8最初是作为浏览器的JavaScript引擎而设计，不太可能遇到大量内存的场景，
而深层次的原因 则是由于**V8的垃圾回收机制的限制。**
由于V8需要保证JavaScript应用逻辑与垃圾回收器所看到的不一样，V8在执行垃圾回收时会阻塞 JavaScript应用逻辑，
直到垃圾回收结束再重新执行JavaScript应用逻辑，这种行为被称为“全停顿”（stop-the-world）。
若V8的堆内存为1.5GB，V8做一次小的垃圾回收需要50ms以上，做一次非增量式的垃圾回收甚至要1秒以上。
这样浏览器将在1s内失去对用户的响 应，造成假死现象。如果有动画效果的话，动画的展现也将显著受到影响。                         

## ChromeV8的堆构成                        
V8的堆其实并不只是由老生代和新生代两部分构成，可以将堆分为几个不同的区域：                                                 
*　新生代内存区：大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁                                       
*　老生代指针区：属于老生代，这里包含了大多数可能存在指向其他对象的指针的对象，大多数从新生代晋升的对象会被移动到这里                                     
*　老生代数据区：属于老生代，这里只保存原始数据对象，这些对象没有指向其他对象的指针                                      
*　大对象区：这里存放体积超越其他区大小的对象，每个对象有自己的内存，垃圾回收其不会移动大对象                                     
*　代码区：代码对象，也就是包含JIT之后指令的对象，会被分配在这里。唯一拥有执行权限的内存区                                     
*　Cell区、属性Cell区、Map区：存放Cell、属性Cell和Map，每个区域都是存放相同大小的元素，结构简单                                     

每个区域都是由一组内存页构成，内存页是V8申请内存的最小单位，除了大对象区的内存页较大以外，
其他区的内存页都是1MB大小，而且按照1MB对 齐。
内存页除了存储的对象，还有一个包含元数据和标识信息的页头，以及一个用于标记哪些对象是活跃对象的位图区。
另外每个内存页还有一个单独分配在另外内 存区的槽缓冲区，里面放着一组对象，这些对象可能指向其他存储在该页的对象。
垃圾回收器只会针对新生代内存区、老生代指针区以及老生代数据区进行垃圾回收

## ChromeV8的垃圾回收机制
### 如何判断回收内容                        
如何确定哪些内存需要回收，哪些内存不需要回收，这是垃圾回收期需要解决的最基本问题。                           
我们可以这样假定，一个对象为活对象当且仅当它被一个根对象 或另一个活对象指向。根对象永远是活对象，它是被浏览器或V8所引用的对象。                       


### 如何识别指针和数据
垃圾回收器需要面临一个问题，它需要判断哪些是数据，哪些是指针。由于很多垃圾回收算法会将对象在内存中移动（紧凑，减少内存碎片），所以经常需要进行指针的改写。                           

目前主要有三种方法来识别指针：                             
1. 保守法：
    将所有堆上对齐的字都认为是指针，那么有些数据就会被误认为是指针。
    于是某些实际是数字的假指针，会背误认为指向活跃对象，
    导致内存泄露（假指针指向的对象可能是死对象，但依旧有指针指向——这个假指针指向它）同时我们不能移动任何内存区域。                                            
2. 编译器提示法：
    如果是静态语言，编译器能够告诉我们每个类当中指针的具体位置，
    而一旦我们知道对象时哪个类实例化得到的，就能知道对象中所有指针。
    这是JVM实现垃圾回收的方式，但这种方式并不适合JS这样的动态语言                                               
3. 标记指针法：
    这种方法需要在每个字末位预留一位来标记这个字段是指针还是数据。
    这种方法需要编译器支持，但实现简单，而且性能不错。
    V8采用的是这种方式。V8将所有数据以32bit字宽来存储，其中最低一位保持为0，而指针的最低两位为01
    
### V8的回收策略
自动垃圾回收算法的演变过程中出现了很多算法，但是由于不同对象的生存周期不同，没有一种算法适用于所有的情况。
所以V8采用了一种分代回收的策 略，将内存分为两个生代：新生代和老生代。
新生代的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。
分别对新生代和老生代使用 不同的垃圾回收算法来提升垃圾回收的效率。
对象起初都会被分配到新生代，当新生代中的对象满足某些条件（后面会有介绍）时，会被移动到老生代（晋升）                          

### V8的分代内存
默认情况下，64位环境下的V8引擎的新生代内存大小32MB、老生代内存大小为1400MB，而32位则减半，分别为16MB和700MB。
V8内存的最大保留空间分别为1464MB（64位）和732MB（32位）。
具体的计算公式是4*reserved_semispace_space_ + max_old_generation_size_，
新生代由两块reserved_semispace_space_组成，每块16MB（64位）或8MB（32位）

## 新生代
### 新生代的特点                      
大多数的对象被分配在这里，这个区域很小但是垃圾回特别频繁。
在新生代分配内存非常容易，我们只需要保存一个指向内存区的指针，不断根据新对象的大小进行递增即可。
当该指针到达了新生代内存区的末尾，就会有一次清理（仅仅是清理新生代）                      

### 新生代的垃圾回收算法                      
新生代使用Scavenge算法进行回收。在Scavenge算法的实现中，主要采用了Cheney算法。

具体的执行过程大致是这样：                                       
首先将From空间中所有能从根对象到达的对象复制到To区，
然后维护两个To区的指针scanPtr和allocationPtr，分别指向即将 扫描的活跃对象和即将为新对象分配内存的地方，开始循环。
循环的每一轮会查找当前scanPtr所指向的对象，确定对象内部的每个指针指向哪里。
如果指向 老生代我们就不必考虑它了。
如果指向From区，我们就需要把这个所指向的对象从From区复制到To区，具体复制的位置就是allocationPtr 所指向的位置。
复制完成后将scanPtr所指对象内的指针修改为新复制对象存放的地址，并移动allocationPtr。
如果一个对象内部的所有指针 都被处理完，scanPtr就会向前移动，进入下一个循环。
若scanPtr和allocationPtr相遇，则说明所有的对象都已被复制完，From 区剩下的都可以被视为垃圾，可以进行清理了。                              

举个栗子(以及凑篇幅)，如果有类似如下的引用情况：
```
          +----- A对象
          |
根对象----+----- B对象 ------ E对象
          |
          +----- C对象 ----+---- F对象 
                           |
                           +---- G对象 ----- H对象

    D对象
```

在执行Scavenge之前，From区长这幅模样                        
```
+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+
```

那么首先将根对象能到达的ABC对象复制到To区，于是乎To区就变成了这个样子：
```
          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
 ↑
scanPtr  
```

接下来进入循环，扫描scanPtr所指的A对象，发现其没有指针，于是乎scanPtr移动，变成如下这样                 
```
          allocationPtr
             ↓ 
+---+---+---+----------------------------+
| A | B | C |                            |
+---+---+---+----------------------------+
     ↑
  scanPtr  
```

接下来扫描B对象，发现其有指向E对象的指针，且E对象在From区，那么我们需要将E对象复制到allocationPtr所指的地方并移动allocationPtr指针：
```
            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
     ↑
  scanPtr  
```

B对象里所有指针都已被复制完，所以移动scanPtr：                 
```
            allocationPtr
                 ↓ 
+---+---+---+---+------------------------+
| A | B | C | E |                        |
+---+---+---+---+------------------------+
         ↑
      scanPtr  
```

接下来扫描C对象，C对象中有两个指针，分别指向F对象和G对象，且都在From区，先复制F对象到To区：
```
                allocationPtr
                     ↓ 
+---+---+---+---+---+--------------------+
| A | B | C | E | F |                    |
+---+---+---+---+---+--------------------+
         ↑
      scanPtr  
```
然后复制G对象到To区
```
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
         ↑
      scanPtr  
```

这样C对象内部的指针已经复制完成了，移动scanPtr：
```
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
             ↑
          scanPtr  
```

逐个扫描E，F对象，发现其中都没有指针，移动scanPtr：
```
                    allocationPtr
                         ↓ 
+---+---+---+---+---+---+----------------+
| A | B | C | E | F | G |                |
+---+---+---+---+---+---+----------------+
                     ↑
                  scanPtr  
```

扫描G对象，发现其中有一个指向H对象的指针，且H对象在From区，复制H对象到To区，并移动allocationPtr：
```
                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                     ↑
                  scanPtr  
```

完成后由于G对象没有其他指针，且H对象没有指针移动scanPtr：                   
```
                        allocationPtr
                             ↓ 
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
                             ↑
                           scanPtr  
```

此时scanPtr和allocationPtr重合，说明复制结束                            
可以对比一下From区和To区在复制完成后的结果：
```
//From区
+---+---+---+---+---+---+---+---+--------+
| A | B | C | D | E | F | G | H |        |
+---+---+---+---+---+---+---+---+--------+
//To区
+---+---+---+---+---+---+---+------------+
| A | B | C | E | F | G | H |            |
+---+---+---+---+---+---+---+------------+
```
D对象没有被复制，它将被作为垃圾进行回收                                

### 写屏障
如果新生代中的一个对象只有一个指向它的指针，而这个指针在老生代中，
我们如何判断这个新生代的对象是否存活？
为了解决这个问题，需要建立一个列表用来记录所有老生代对象指向新生代对象的情况。
每当有老生代对象指向新生代对象的时候，我们就记录下来

### 对象的晋升                                                                       
当一个对象经过多次新生代的清理依旧幸存，这说明它的生存周期较长，也就会被移动到老生代，这称为对象的晋升。具体移动的标准有两种：                                     
1. 对象从From空间复制到To空间时，会检查它的内存地址来判断这个对象是否已经经历过一个新生代的清理，如果是，则复制到老生代中，否则复制到To空间中                                        
2. 对象从From空间复制到To空间时，如果To空间已经被使用了超过25%，那么这个对象直接被复制到老生代                                      


## 老生代
### 老生代的特点                      
老生代所保存的对象大多数是生存周期很长的甚至是常驻内存的对象，而且老生代占用的内存较多

### 老生代的垃圾回收算法                      
老生代占用内存较多（64位为1.4GB，32位为700MB），如果使用Scavenge算法，
浪费一半空间不说，复制如此大块的内存消耗时间将 会相当长。所以Scavenge算法显然不适合。
V8在老生代中的垃圾回收策略采用 **Mark-Sweep和Mark-Compact** 相结合

### Mark-Sweep（标记清除）
标记清除分为标记和清除两个阶段。
在标记阶段需要遍历堆中的所有对象，并标记那些活着的对象，然后进入清除阶段。
在清除阶段总，只清除没有被标记的对象。
由于标记清除只清除死亡对象，而死亡对象在老生代中占用的比例很小，所以效率较高

标记清除有一个问题就是进行一次标记清楚后，内存空间往往是不连续的，会出现很多的内存碎片。
如果后续需要分配一个需要内存空间较多的对象时，如果所有的内存碎片都不够用，将会使得V8无法完成这次分配，提前触发垃圾回收。

### Mark-Compact（标记整理）
标记整理正是为了解决标记清除所带来的内存碎片的问题。
标记整理在标记清除的基础进行修改，将其的清除阶段变为紧缩极端。
在整理的过程中，将活着的 对象向内存区的一段移动，移动完成后直接清理掉边界外的内存。
紧缩过程涉及对象的移动，所以效率并不是太好，但是能保证不会生成内存碎片。

### 算法思路                        
标记清除和标记整理都分为两个阶段：标记阶段、清除或紧缩阶段                   

在标记阶段，所有堆上的活跃对象都会被标记。
每个内存页有一个用来标记对象的位图，位图中的每一位对应内存页中的一个字。
这个位图需要占据一定的空 间（32位下为3.1%，64位为1.6%）。
另外有两位用来标记对象的状态，这个状态一共有三种（所以要两位）——白，灰，黑：                                     
* 如果一个对象为白对象，它还没未被垃圾回收器发现
* 如果一个对象为灰对象，它已经被垃圾回收器发现，但其邻接对象尚未全部处理
* 如果一个对象为黑对象，说明他步进被垃圾回收器发现，其邻接对象也全部被处理完毕了

### 结合使用标记清除和标记整理
Chrome V8的老生代使用标记清除和标记整理结合的方式，主要采用标记清除算法，如果空间不足以分配从新生代晋升过来的对象时，才使用标记整理


参考文章：                   
- [V8 内存浅析](https://zhuanlan.zhihu.com/p/33816534)                      
- [浅谈Chrome V8引擎中的垃圾回收机制](https://www.cnblogs.com/liangdaye/p/4654734.html)

           

## 92.如何给自己团队的大型前端项目设计单元测试？【JavaScript】
**回答:**      
## 基本原则和步骤

1. 调研基本的前端测试框架有哪些， 有哪些优劣
2. 需要分别针对 utils 静态方法测试与 UI 交互测试（2E2测试）
3. 针对测试， 产出衡量指标与实践规范
4. 针对项目产出最佳实践
5. 通过 CI 工具进行测试检查、覆盖、定时回归


## 参考文档
- https://juejin.cn/post/7039108357554176037
           

## 93.如何做一个前端项目工程的自动化部署， 有哪些规范和流程设计？【JavaScript】
**回答:**      
// TODO 待补充
           

