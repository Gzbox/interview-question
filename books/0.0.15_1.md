> 2023.03.09 - 2023.03.15 更新收集面试问题（45道题）【第1部分】           
获取更多面试问题可以访问            
github 地址: https://github.com/pro-collection/interview-question/issues            
gitee 地址: https://gitee.com/yanleweb/interview-question/issues          



目录：



- 中级开发者相关问题【共计 3 道题】
  - 98.HTTP 1.0 和 HTTP 1.1 有以下区别？【网络】
  - 99.了解 BFC 吗？【CSS】
  - 103.箭头函数和普通函数的区别？【JavaScript】


- 高级开发者相关问题【共计 2 道题】
  - 100.flex 布局了解多少？【CSS】
  - 102.map 和 weakMap 的区别 ?【JavaScript】







    




# 中级开发者相关问题【共计 3 道题】

## 98.HTTP 1.0 和 HTTP 1.1 有以下区别？【网络】
      
- **连接方面**，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。
  
- **资源请求方面**，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
  
- **缓存方面**，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。
  
- http1.1 中新**增了 host 字段**，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。
  
- http1.1 相对于 http1.0 还新**增了很多请求方法**，如 PUT、HEAD、OPTIONS 等。

           

## 99.了解 BFC 吗？【CSS】
      
> 小提示：先聊一聊BFC是什么；
然后再说说触发BFC的条件；
再说一说BFC的一些作用

BFC是块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。(俗称：**脱离文档流**)

**触发条件**

- position: absolute/fixed：绝对定位
- display: inline-block / table / flex
- float 设置除none以外的值；（只要设置了浮动，当前元素就创建了BFC）
- ovevflow !== visible (可为：hidden、auto、scroll)

**特性和应用**

- 阻止margin重叠：同一个 BFC 下外边距（margin）会发生折叠
- 清除浮动 ：清除内部浮动(清除浮动的原理是两个div都位于同一个 BFC 区域之中)
- 自适应两栏布局：左float+右BFC，是利用了BFC 的区域不会与 float 的元素区域重叠的机制


           

## 103.箭头函数和普通函数的区别？【JavaScript】
      
箭头函数和普通函数是 JavaScript 中两种不同的函数定义方式，它们有以下的区别：

- **语法不同**：箭头函数使用箭头 => 来定义函数，而普通函数使用 function 关键字来定义函数。

- **箭头函数没有自己的 this**，它会继承其所在作用域的 this 值。而普通函数的 this 则由函数调用时的上下文所决定，可以通过 call、apply、bind 方法来改变。

- **箭头函数没有自己的 arguments 对象**，它可以通过 rest 参数语法来接收不定数量的参数。而普通函数则有自己的 arguments 对象，它可以接收任意数量的参数。

- **箭头函数不能作为构造函数使用**，不能使用 new 来实例化，因为它没有自己的 this，而普通函数可以用 new 来创建新的对象。

- **箭头函数不能使用 yield 关键字**来定义生成器函数，而普通函数可以。



           



# 高级开发者相关问题【共计 2 道题】

## 100.flex 布局了解多少？【CSS】
      
## flex 布局的学习

- [Flex 布局教程：语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)
- [Flex 布局教程：实例篇](http://www.ruanyifeng.com/blog/2015/07/flex-examples.html)
- [Flex 布局教程：实例篇代码](https://github.com/JailBreakC/flex-box-demo)


## 容器属性
以下6个属性设置在容器上。                   
```
flex-direction
flex-wrap
flex-flow
justify-content
align-items
align-content
```

### flex-direction属性
属性决定主轴的方向（即项目的排列方向）。
```css
.box {
  flex-direction: row | row-reverse | column | column-reverse;
}
```
- row（默认值）：主轴为水平方向，起点在左端。
- row-reverse：主轴为水平方向，起点在右端。
- column：主轴为垂直方向，起点在上沿。
- column-reverse：主轴为垂直方向，起点在下沿。


### flex-wrap属性
默认情况下，项目都排在一条线（又称"轴线"）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。                       
```
.box{
  flex-wrap: nowrap | wrap | wrap-reverse;
}
```
它可能取三个值。                        
（1）nowrap（默认）：不换行。                      
（2）wrap：换行，第一行在上方。                      
（3）wrap-reverse：换行，第一行在下方。                      


### flex-flow
flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。                   
```css
.box {
  flex-flow: <flex-direction> || <flex-wrap>;
}
```

### justify-content属性
属性定义了项目在主轴上的对齐方式。                       
```
.box {
  justify-content: flex-start | flex-end | center | space-between | space-around;
}
```

它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。

    flex-start（默认值）：左对齐
    flex-end：右对齐
    center： 居中
    space-between：两端对齐，项目之间的间隔都相等。
    space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。


### align-items属性
定义项目在交叉轴上如何对齐。                  
```
.box {
  align-items: flex-start | flex-end | center | baseline | stretch;
}
```

它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。

    flex-start：交叉轴的起点对齐。
    flex-end：交叉轴的终点对齐。
    center：交叉轴的中点对齐。
    baseline: 项目的第一行文字的基线对齐。
    stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。
    

### align-content属性
定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。
```
.box {
  align-content: flex-start | flex-end | center | space-between | space-around | stretch;
}
```

    flex-start：与交叉轴的起点对齐。
    flex-end：与交叉轴的终点对齐。
    center：与交叉轴的中点对齐。
    space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。
    space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。
    stretch（默认值）：轴线占满整个交叉轴。
    
    
## 项目的属性
以下6个属性设置在项目上。

    order
    flex-grow
    flex-shrink
    flex-basis
    flex
    align-self

### order属性
定义项目的排列顺序。数值越小，排列越靠前，默认为0。
```
.item {
  order: <integer>;
}
```

### flex-grow
定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。

如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。
如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。


### flex-shrink属性
flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。

如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。
如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。

### flex-basis 
定义了在分配多余空间之前，项目占据的主轴空间（main size）。
浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
```
.item {
  flex-basis: <length> | auto; /* default auto */
}
```
它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。

### flex属性
是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。
```
.item {
  flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]
}
```
该属性有两个快捷值：`auto (1 1 auto) 和 none (0 0 auto)`。
建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。

### align-self属性
align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。
默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。

```
.item {
  align-self: auto | flex-start | flex-end | center | baseline | stretch;
}
```
该属性可能取6个值，除了auto，其他都与align-items属性完全一致。


### 参考文章
- [lex 布局中固定宽度不起作用，被压缩了](https://www.jianshu.com/p/4a8825a17181)
- [Flex弹性布局（附超Q小demo）](https://juejin.im/post/5cba07005188251b960f56eb)






           

## 102.map 和 weakMap 的区别 ?【JavaScript】
      
Map 和 WeakMap 都是 JavaScript 中的键值对数据结构，它们的主要区别在于其键的存储方式和内存管理。

Map 对象中的键可以是任何类型的值，包括基本类型和引用类型，而 WeakMap 对象中的键必须是对象。在 Map 中，如果一个键不再被引用，它仍然会被 Map 对象保留，因为 Map 对象对其进行了强引用。这会导致内存泄漏的问题。而 WeakMap 对象只会对其键进行弱引用，也就是说，如果一个键不再被引用，它会被垃圾回收器回收，因此不会导致内存泄漏的问题。

此外，WeakMap 没有 Map 中的一些方法，比如 size、keys、values 和 forEach 等方法，因为 WeakMap 的键不是强引用，所以无法确定其大小。

总之，如果需要存储对象键值对，并且不需要保留键的引用，可以考虑使用 WeakMap，否则使用 Map。
           





