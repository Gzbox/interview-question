<div class="markdown-body cache"><style>@charset "UTF-8";.markdown-body{word-break:break-word;font-weight:400;line-height:2;font-size:17px;overflow-x:hidden;color:#000}.markdown-body strong{padding:1px;color:#ee3f4d}.markdown-body em{padding:0 2px;color:#f33b1f}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{position:relative;margin-top:30px;margin-bottom:20px;line-height:1.5;font-weight:700}.markdown-body h1{text-align:center;padding-bottom:5px;font-size:32px;color:#ac1f18}.markdown-body h1:after{content:"";display:block;margin:4px auto 0;width:100px;height:2px;border-bottom:2px solid #f33b1f}.markdown-body h2{font-size:28px;border-bottom:1px solid #f33b1f}.markdown-body h2:before{content:"# "!important;color:#f33b1f}.markdown-body h3{font-size:24px;padding-left:9px;border-left:6px solid #f33b1f}.markdown-body h4{font-size:20px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #bbb;margin:16px 0}.markdown-body code{word-break:break-word;overflow-x:auto;background-color:#f9f1db;color:#ee2746;border-radius:2px;font-size:16px;padding:1px 2px}.markdown-body code,.markdown-body pre{font-family:-apple-system,-apple-system-body,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,PingFang SC,思源黑体 CN,思源黑体,JetBrains Mono,Fira Code,Menlo,Ubuntu Mono,Consolas,sans-serif}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{margin:12px 0!important;border-radius:3px;font-size:15px;padding:16px 12px;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f7f7f7}.markdown-body a{text-decoration:none;color:#1781b5;padding:0 2px;border-bottom:1px solid #1781b5}.markdown-body a:active,.markdown-body a:hover{border-bottom:2px solid #f33b1f;color:#ac1f18}.markdown-body blockquote{color:#3d3d3d;background-color:#fff9f9;padding:6px 16px;margin:16px 0;border-left:3px solid #f07c82}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:6px 0}.markdown-body ol,.markdown-body ul{padding-left:30px}.markdown-body ol li,.markdown-body ul li{margin-bottom:6px}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:6px}.markdown-body ol li{padding-left:6px}.markdown-body ::marker{color:#f33b1f}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}.markdown-body .task-list-item input[type=checkbox]{position:relative}.markdown-body .task-list-item input[type=checkbox]:before{content:"";position:absolute;top:0;left:0;right:0;bottom:0;background:#fff;border:1px solid #f07c82;border-radius:3px;box-sizing:border-box;z-index:1}.markdown-body .task-list-item input[type=checkbox]:checked:after{content:"✓";position:absolute;top:-5px;left:0;right:0;bottom:0;width:0;height:0;color:#f33b1f;font-size:16px;font-weight:700;z-index:2}.markdown-body table{display:inline-block!important;font-size:14px;width:auto;max-width:100%;overflow:auto;border-spacing:0;border-collapse:collapse}.markdown-body table thead{background:#fff9f9;color:#000;text-align:left;font-size:15px}.markdown-body table tr:nth-child(2n){background-color:#fcfcfc}.markdown-body table tr:hover{background-color:#fff9f9}.markdown-body table td,.markdown-body table th{padding:12px 7px;line-height:24px;border:1px solid #f9f1db}.markdown-body table td{min-width:120px}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="a11y-dark">.hljs-comment,.hljs-quote{color:#d4d0ab}.hljs-deletion,.hljs-name,.hljs-regexp,.hljs-selector-class,.hljs-selector-id,.hljs-tag,.hljs-template-variable,.hljs-variable{color:#ffa07a}.hljs-built_in,.hljs-builtin-name,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-type{color:#f5ab35}.hljs-attribute{color:gold}.hljs-addition,.hljs-bullet,.hljs-string,.hljs-symbol{color:#abe338}.hljs-section,.hljs-title{color:#00e0e0}.hljs-keyword,.hljs-selector-tag{color:#dcc6e0}.markdown-body pre,.markdown-body pre>code.hljs{background:#2b2b2b;color:#f8f8f2}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}@media screen and (-ms-high-contrast:active){.hljs-addition,.hljs-attribute,.hljs-built_in,.hljs-builtin-name,.hljs-bullet,.hljs-comment,.hljs-link,.hljs-literal,.hljs-meta,.hljs-number,.hljs-params,.hljs-quote,.hljs-string,.hljs-symbol,.hljs-type{color:highlight}.hljs-keyword,.hljs-selector-tag{font-weight:700}}</style><blockquote>
  <p>阅读使人充实，会谈使人敏捷，写作使人精确</p>
</blockquote>
  <p>大家好，我是<strong>柒八九</strong>。</p>
  <p>今天，我们继续<strong>2023前端面试真题</strong>系列。我们来谈谈关于<strong>前端框架</strong>的相关知识点。</p>
  <p>如果，想了解该系列的文章，可以参考我们已经发布的文章。如下是往期文章。</p>
  <h3 data-id="heading-0">文章list</h3>
  <ol>
    <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FmjSfXevWglT0oVyZLIwHtA" target="_blank" title="https://mp.weixin.qq.com/s/mjSfXevWglT0oVyZLIwHtA" ref="nofollow noopener noreferrer">2023前端面试真题之JS篇</a></li>
    <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FG4nuxRNxZte7tZby7dx66Q" target="_blank" title="https://mp.weixin.qq.com/s/G4nuxRNxZte7tZby7dx66Q" ref="nofollow noopener noreferrer">2023面试真题之CSS篇</a></li>
    <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FviZkYHZWRRhC4dVmjDEM-Q" target="_blank" title="https://mp.weixin.qq.com/s/viZkYHZWRRhC4dVmjDEM-Q" ref="nofollow noopener noreferrer">2023面试真题之浏览器篇</a></li>
    <li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F_pJkOhBt9QbdvqZammUITw" target="_blank" title="https://mp.weixin.qq.com/s/_pJkOhBt9QbdvqZammUITw" ref="nofollow noopener noreferrer">22023面试真题之网络篇</a></li>
  </ol>
  <h3 data-id="heading-1">你能所学到的知识点</h3>
  <blockquote>
    <ol>
      <li><span>React Diff</span>  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>setState同步异步问题</span>  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>React 18新特性</span> <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>React 生命周期</span> <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>Hook的相关知识点</span> <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li>ref能否拿到函数组件的实例  <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
      <li>useCallbck vs useMemo的区别  <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
      <li>React.memo <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li>类组件和函数组件的区别  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li>componentWillUnmount在浏览器刷新后，会执行吗  <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
      <li><span>React 组件优化</span> <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>React-Router实现原理</span>  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>XXR</span> <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>WebComponents</span>  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li>Lit <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li>npm <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li>yarn <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li>pnpm <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li>yarn PnP <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li><span>npm install 发生了啥</span>  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li>使用 history 模式的前端路由时静态资源服务器配置详解 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>webpack 优化</span>   <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li>Redux内部实现  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️
        24.Vue和 React的区别 <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li>Webpack有哪些常用的loader和plugin <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️</li>
      <li><span>Babel</span>  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li><span>Fiber 实现时间切片的原理</span>  <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
      <li>devServer进行跨域处理 <strong>推荐阅读指数</strong>⭐️⭐️⭐️</li>
      <li><span>React-Hook 实现原理</span>   <strong>推荐阅读指数</strong>⭐️⭐️⭐️⭐️⭐️</li>
    </ol>
  </blockquote>
  <p>好了，天不早了，干点正事哇。</p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4f18dd7d7922428682e2dd539a5ad8f0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <h1 data-id="heading-2">React Diff</h1>
  <p>在<code>React</code>中，<code>diff算法</code>需要与<code>虚拟DOM</code>配合才能发挥出真正的威力。<code>React</code>会使用<code>diff</code>算法计算出<code>虚拟DOM</code>中<span>真正发生变化的部分</span>，并且只会针对该部分进行<code>dom</code>操作，从而<strong>避免了对页面进行大面积的更新渲染，减小性能的开销</strong>。</p>
  <h2 data-id="heading-3">React diff算法</h2>
  <p>在<code>传统的diff算法</code>中复杂度会达到<code>O(n^3)</code>。<code>React</code>中定义了<span>三种策略</span>，在对比时，根据策略<strong>只需遍历一次树就可以完成对比</strong>，将复杂度降到了<code>O(n)</code>：</p>
  <ol>
    <li>
      <p><strong>tree diff</strong>：在两个树对比时，只会比较<span>同一层级的节点，会忽略掉跨层级的操作</span></p>
      <ul>
        <li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/445dbbc9af424a67a1f5a138b1b4825f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></li>
      </ul>
    </li>
    <li>
      <p><strong>component diff</strong>：在对比两个组件时，首先会判断它们两个的<span>类型是否相同</span></p>
      <ul>
        <li>如果不是，则将该组件判断为 <code>dirty component</code>，从而<strong>替换整个组件下的所有子节点</strong></li>
        <li><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/35611a55bac2459e9bf4017ba0bfed09~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></li>
      </ul>
    </li>
    <li>
      <p><strong>element diff</strong>：对于<strong>同一层级的一组节点</strong>，会使用具有<code>唯一性的key</code>来区分是否需要创建，删除，或者是移动。</p>
    </li>
  </ol>
  <h2 data-id="heading-4">Element Diff</h2>
  <p>当节点处于同一层级时,<code>React diff</code> 提供了三种节点操作，分别为：</p>
  <ol>
    <li><code>INSERT_MARKUP</code>（插入）
      <ul>
        <li>新的 <code>component</code> 类型不在老集合里， 即是<span>全新的节点</span>，需要对新节点执行<strong>插入操作</strong></li>
      </ul>
    </li>
    <li><code>MOVE_EXISTING</code>（移动）
      <ul>
        <li>在老集合有新 <code>component</code> 类型，且 <code>element</code> 是可更新的类型,这种情况下 <code>prevChild</code>=<code>nextChild</code>，就需要做移动操作，可以<span>复用以前的 DOM 节点</span>。</li>
      </ul>
    </li>
    <li><code>REMOVE_NODE</code>（删除）
      <ul>
        <li>老 <code>component</code> 类型，在新集合里也有，但<strong>对应的 <code>element</code> 不同</strong>则不能直接复用和更新，需要执行<strong>删除操作</strong>，</li>
        <li>或者老 <code>component</code> 不在新集合里的，也需要执行<strong>删除操作</strong></li>
      </ul>
    </li>
  </ol>
  <p>存在如下结构：
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5b9c79f39e704e0db7e35bc223e681b9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>新老集合进行 <code>diff</code> 差异化对比，<span>通过 <code>key</code> 发现新老集合中的节点都是相同的节点</span>，因此无需进行节点<code>删除和创建</code>，只需要将老集合中节点的位置进行移动，更新为新集合中节点的位置，此时 <code>React</code> 给出的 <code>diff</code> 结果为：<strong>B、D 不做任何操作，A、C 进行移动操作</strong></p>
  <ul>
    <li>首先对<span>新集合的节点</span>进行循环遍历，<code>for (name in nextChildren)</code>，</li>
    <li>通过<strong>唯一 key</strong> 可以判断新老集合中<strong>是否存在相同的节点</strong>，<code>if (prevChild === nextChild)</code></li>
    <li>如果存在<strong>相同节点</strong>，则进行<strong>移动操作</strong></li>
    <li>但在移动前需要将<span>当前节点在老集合中的位置</span>与 <code>lastIndex</code> 进行比较，
      <ul>
        <li><code>if (child._mountIndex &lt; lastIndex)</code>，则进行<strong>节点移动操作</strong>，否则不执行该操作。</li>
        <li><code>lastIndex</code> 一直在更新，<span>表示访问过的节点在老集合中最右的位置（即最大的位置）</span>，</li>
        <li>如果<strong>新集合中当前访问的节点</strong>比 <code>lastIndex</code> 大，说明<strong>当前访问节点在老集合中就比上一个节点位置靠后，则该节点不会影响其他节点的位置</strong>，因此不用添加到差异队列中，即不执行移动操作</li>
        <li><strong>只有当访问的节点比 <code>lastIndex</code> 小时，才需要进行移动操作</strong>。</li>
      </ul>
    </li>
  </ul>
  <blockquote>
    <p>当完成<strong>新集合</strong>中所有节点 <code>diff</code> 时，最后还需要<strong>对老集合进行循环遍历</strong>，判断是否存在新集合中没有但老集合中仍存在的节点，发现存在这样的节点 <code>x</code>，因此删除节点 <code>x</code>，到此 <code>diff</code> 全部完成。</p>
  </blockquote>
  <hr>
  <h1 data-id="heading-5">setState同步异步问题</h1>
  <h2 data-id="heading-6">18.x之前版本</h2>
  <p>如果<strong>直接在<code>setState</code>后面获取<code>state</code>的值是获取不到的</strong>。</p>
  <ul>
    <li>在<code>React</code><span>内部机制能检测到的地方</span>， <code>setState</code>就是异步的；</li>
    <li>在<code>React</code>检测不到的地方，例如 原生事件<code>addEventListener</code>,<code>setInterval</code>,<code>setTimeout</code>，<code>setState</code>就是同步更新的</li>
  </ul>
  <blockquote>
    <p><code>setState</code>并不是单纯的异步或同步，这其实与<strong>调用时的环境相关</strong></p>
  </blockquote>
  <ul>
    <li>在<span>合成事件</span> 和 <span>生命周期钩子</span>(除componentDidUpdate) 中，<code>setState</code>是"异步"的；</li>
    <li>在 <span>原生事件</span> 和<code>setTimeout</code> 中，<code>setState</code>是同步的，可以马上获取更新后的值；</li>
  </ul>
  <h3 data-id="heading-7">批量更新</h3>
  <p>多个顺序的<code>setState</code>不是同步地一个一个执行滴，会一个一个加入队列，然后最后一起执行。在 <code>合成事件</code> 和 <code>生命周期钩子</code> 中，<code>setState</code>更新队列时，存储的是 合并状态<code>(Object.assign</code>)。因此<span>前面设置的 <code>key</code> 值会被后面所覆盖，最终只会执行一次更新</span>。</p>
  <h3 data-id="heading-8">异步现象原因</h3>
  <p><code>setState</code> 的“异步”<strong>并不是说内部由异步代码实现</strong>，其实<span>本身执行的过程和代码都是同步的，只是合成事件和生命钩子函数的调用顺序在更新之前</span>，导致在<code>合成事件</code>和<code>钩子函数</code>中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数<code>setState(partialState, callback)</code>中的<code>callback</code>拿到更新后的结果。</p>
  <blockquote>
    <p><code>setState</code> 并非真异步，只是看上去像异步。在源码中，通过 <code>isBatchingUpdates</code> 来判断</p>
  </blockquote>
  <p><code>setState</code>调用流程：</p>
  <ol>
    <li>调用<code>this.setState(newState)</code></li>
    <li>将新状态<code>newState</code>存入<code>pending队列</code></li>
    <li>判断是否处于<code>batch Update</code>（<span>isBatchingUpdates是否为true</span>）
      <ul>
        <li><code>isBatchingUpdates=true</code>，保存组件于<code>dirtyComponents</code>中，<span>走异步更新流程，合并操作，延迟更新</span>；</li>
        <li><code>isBatchingUpdates=false</code>，走<strong>同步过程</strong>。<span>遍历所有的<code>dirtyComponents</code>，调用<code>updateComponent</code>，更新<code>pending state or props</code></span></li>
      </ul>
    </li>
  </ol>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cc82c00a27e749e79019e0102192fcdb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <h3 data-id="heading-9">为什么直接修改this.state无效</h3>
  <p><code>setState</code>本质是通过一个<span>队列机制</span>实现<code>state</code>更新的。 执行<code>setState</code>时，会将需要更新的<code>state</code>合并后放入<strong>状态队列</strong>，而不会立刻更新<code>state</code>，队列机制可以批量更新<code>state</code>。</p>
  <p>如果不通过<code>setState</code>而直接修改<code>this.state</code>，那么这个<code>state</code>不会放入状态队列中，下次调用<code>setState</code>时对状态队列进行合并时，会<span>忽略之前直接被修改</span>的<code>state</code>，这样我们就无法合并了，而且实际也没有把你想要的<code>state</code>更新上去</p>
  <h2 data-id="heading-10">React18</h2>
  <p>在 <code>v18</code> 之前<strong>只在事件处理函数中实现了批处理</strong>，在 <code>v18</code> 中所有更新都将<strong>自动批处理</strong>，包括 <code>promise链</code>、<code>setTimeout</code>等异步代码以及<code>原生事件处理函数</code></p>
  <hr>
  <h1 data-id="heading-11">React 18新特性</h1>
  <p><code>React</code> 从 <code>v16</code> 到 <code>v18</code> 主打的特性包括三个变化：</p>
  <ul>
    <li>v16: <code>Async Mode</code> (异步模式)</li>
    <li>v17: <code>Concurrent Mode</code> (并发模式)</li>
    <li>v18: <code>Concurrent Render</code> (并发更新)</li>
  </ul>
  <p><code>React</code> 中 <code>Fiber</code> 树的更新流程分为两个阶段 <code>render</code> 阶段和 <code>commit</code> 阶段。</p>
  <ol>
    <li>组件的 <code>render</code> 函数执行时称为 <code>render</code>（本次更新需要做哪些变更），<span>纯 js 计算</span>；</li>
    <li>而将 <code>render</code> 的结果渲染到页面的过程称为 <code>commit</code> （变更到真实的宿主环境中，在浏览器中就是操作<code>DOM</code>）。</li>
  </ol>
  <p>在 <code>Sync</code> 模式下，<code>render</code> 阶段是<span>一次性执行完成</span>；而在 <code>Concurrent</code> 模式下 <code>render</code> 阶段可以被拆解，<span>每个时间片内执行一部分，直到执行完毕</span>。由于 <code>commit</code> 阶段有 <code>DOM</code> 的更新，不可能让 <code>DOM</code> 更新到一半中断，必须一次性执行完毕。</p>
  <h2 data-id="heading-12">React 并发新特性</h2>
  <blockquote>
    <p>并发渲染机制<code>concurrent rendering</code>的目的：根据用户的<strong>设备性能</strong>和<strong>网速</strong>对渲染过程进行适当的调整， 保证 <code>React</code> 应用在<span>长时间的渲染过程中依旧保持可交互性，避免页面出现卡顿或无响应的情况，从而提升用户体验</span>。</p>
  </blockquote>
  <ol>
    <li>新 root API
      <ul>
        <li>通过 <code>createRoot</code> Api 手动创建 <code>root</code> 节点。</li>
      </ul>
    </li>
    <li><strong>自动批处理</strong>优化 Automatic batching
      <ul>
        <li><code>React</code> 将多个状态更新分组到一个重新渲染中以获得更好的性能。（将多次 <code>setstate</code> 事件合并）</li>
        <li>在 <code>v18</code> 之前<strong>只在事件处理函数中实现了批处理</strong>，在 <code>v18</code> 中所有更新都将自动批处理，包括 <code>promise链</code>、<code>setTimeout</code>等异步代码以及<code>原生事件处理函数</code>。</li>
        <li>想退出自动批处理<strong>立即更新</strong>的话，可以使用 <code>ReactDOM.flushSync()</code> 进行包裹</li>
      </ul>
    </li>
    <li><code>startTransition</code>
      <ul>
        <li>可以用来<span>降低渲染优先级</span>。分别用来<strong>包裹计算量大的 <code>function</code> 和 <code>value</code>，降低优先级，减少重复渲染次数</strong>。</li>
        <li><code>startTransition</code> 可以指定 UI 的渲染优先级，哪些需要实时更新，哪些需要延迟更新</li>
        <li>hook 版本的 <code>useTransition</code>，接受传入一个<strong>毫秒的参数</strong>用来修改最迟更新时间，返回一个过渡期的<code>pending</code> 状态和<code>startTransition</code>函数。</li>
      </ul>
    </li>
    <li><code>useDefferdValue</code>
      <ul>
        <li>通过 <code>useDefferdValue</code> 允许<span>变量延时更新</span>，同时接受一个可选的延迟更新的最大值。<code>React</code> 将尝试尽快更新延迟值，如果在给定的 <code>timeoutMs</code> 期限内未能完成，它将强制更新</li>
        <li><code>const defferValue = useDeferredValue(value, { timeoutMs: 1000 })</code></li>
        <li><code>useDefferdValue</code> 能够很好的<strong>展现并发渲染时优先级调整的特性</strong>，可以用于<strong>延迟计算逻辑比较复杂的状态</strong>，让其他组件优先渲染，等待这个状态更新完毕之后再渲染。</li>
      </ul>
    </li>
  </ol>
  <hr>
  <h1 data-id="heading-13">React 生命周期</h1>
  <p>生命周期
    <code>React</code> 的 生命周期主要有两个比较大的版本，分别是</p>
  <ol>
    <li><strong><code>v16.0</code>前</strong></li>
    <li><code>v16.4</code>两个版本</li>
  </ol>
  <p>的生命周期。</p>
  <h2 data-id="heading-14">v16.0前</h2>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6a908ad6ebd249a98b97ac4afd223900~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>总共分为<strong>四大阶段</strong>：</p>
  <ol>
    <li><span>{初始化| Intialization}</span></li>
    <li><span>{挂载| Mounting}</span></li>
    <li><span>{更新| Update}</span></li>
    <li><span>{卸载| Unmounting}</span></li>
  </ol>
  <hr>
  <h3 data-id="heading-15">Intialization(初始化）</h3>
  <p>在初始化阶段,会用到 <code>constructor()</code> 这个构造函数，如：</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) {
  <span class="hljs-variable language_">super</span>(props);
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <ul>
    <li><code>super</code>的作用
      <ul>
        <li>用来调用<em>基类</em>的构造方法( <code>constructor()</code> ),</li>
        <li>也<strong>将父组件的<code>props</code>注入给子组件，供子组件读取</strong></li>
      </ul>
    </li>
    <li>初始化操作，定义<code>this.state</code>的初始内容</li>
    <li><strong>只会执行一次</strong></li>
  </ul>
  <hr>
  <h3 data-id="heading-16">Mounting(挂载）（3个）</h3>
  <ol>
    <li><code>componentWillMount</code>：<strong>在组件挂载到<code>DOM</code>前调用</strong>
      <ul>
        <li>这里面的调用的<code>this.setState</code>不会引起组件的重新渲染，也可以把写在这边的内容提到<code>constructor()</code>，所以在项目中很少。</li>
        <li><strong>只会调用一次</strong></li>
      </ul>
    </li>
    <li><code>render</code>: 渲染
      <ul>
        <li>只要<code>props</code>和<code>state</code>发生改变（无论值是否有变化,两者的重传递和重赋值，都可以引起组件重新<code>render</code>），<code>都会重新渲染render</code>。</li>
        <li><code>return</code>：<strong>是必须的，是一个React元素</strong>，不负责组件实际渲染工作，由<code>React</code>自身根据此元素去渲染出<code>DOM</code>。</li>
        <li><code>render</code> 是<strong>纯函数</strong>，不能执行<code>this.setState</code>。</li>
      </ul>
    </li>
    <li><code>componentDidMount</code>：<strong>组件挂载到<code>DOM</code>后调用</strong>
      <ul>
        <li><strong>调用一次</strong></li>
      </ul>
    </li>
  </ol>
  <hr>
  <h3 data-id="heading-17">Update(更新)（5个）</h3>
  <ol>
    <li>
      <p><code>componentWillReceiveProps(nextProps)</code>:<span>调用于<code>props</code>引起的组件更新过程中</span></p>
      <ul>
        <li><code>nextProps</code>：父组件传给当前组件新的<code>props</code></li>
        <li>可以用<code>nextProps</code>和<code>this.props</code>来查明重传<code>props</code>是否发生改变（原因：不能保证父组件重传的<code>props</code>有变化）</li>
        <li><span>只要<code>props</code>发生变化就会，引起调用</span></li>
      </ul>
    </li>
    <li>
      <p><code>shouldComponentUpdate(nextProps, nextState)</code>：<span>用于性能优化</span></p>
      <ul>
        <li><code>nextProps</code>：当前组件的<code>this.props</code></li>
        <li><code>nextState</code>：当前组件的<code>this.state</code></li>
        <li>通过比较<code>nextProps</code>和<code>nextState</code>,来判断当前组件是否有必要继续执行更新过程。</li>
        <li><span>返回<code>false</code>：表示停止更新，用于减少组件的不必要渲染，优化性能</span></li>
        <li><span>返回<code>true</code>：继续执行更新</span></li>
        <li>像<code>componentWillReceiveProps（）</code>中执行了<code>this.setState</code>，更新了<code>state</code>，但<strong>在<code>render</code>前</strong>(如<code>shouldComponentUpdate</code>，<code>componentWillUpdate</code>)，<code>this.state</code>依然<span>指向更新前的state</span>，不然<code>nextState</code>及当前组件的<code>this.state</code>的对比就一直是<code>true</code>了</li>
      </ul>
    </li>
    <li>
      <p><code>componentWillUpdate(nextProps, nextState)</code>：<span>组件更新前调用</span></p>
      <ul>
        <li>在<code>render</code>方法前执行</li>
        <li>由于组件更新就会调用，所以一般很少使用</li>
      </ul>
    </li>
    <li>
      <p><code>render</code>：重新渲染</p>
    </li>
    <li>
      <p><code>componentDidUpdate(prevProps, prevState)</code>：<span>组件更新后被调用</span></p>
      <ul>
        <li><code>prevProps</code>：组件更新前的<code>props</code></li>
        <li><code>prevState</code>：组件更新前的<code>state</code></li>
        <li>可以<span>操作组件更新的DOM</span></li>
      </ul>
    </li>
  </ol>
  <hr>
  <h3 data-id="heading-18">Unmounting(卸载)（1个）</h3>
  <p><code>componentWillUnmount</code>：<span>组件被卸载前调用</span></p>
  <p>可以在这里执行一些<strong>清理工作</strong>，比如清除组件中使用的<em>定时器</em>，清除<code>componentDidMount</code>中<em>手动创建的DOM元素</em>等，以避免引起内存泄漏</p>
  <hr>
  <h2 data-id="heading-19">React v16.4</h2>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afdea83ba9fc49e88cbb5eebe84a9bff~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>与 <code>v16.0</code>的生命周期相比</p>
  <ul>
    <li><span>新增</span>了 -- （两个<code>getXX</code>）
      <ol>
        <li><code>getDerivedStateFromProps</code></li>
        <li><code>getSnapshotBeforeUpdate</code></li>
      </ol>
    </li>
    <li><span>取消</span>了 -- (三个<code>componmentWillXX</code>)
      <ol>
        <li><code>componentWillMount</code>、</li>
        <li><code>componentWillReceiveProps</code>、</li>
        <li><code>componentWillUpdate</code></li>
      </ol>
    </li>
  </ul>
  <h3 data-id="heading-20">getDerivedStateFromProps</h3>
  <p><code>getDerivedStateFromProps(prevProps, prevState)</code>：组件<span>创建和更新时</span>调用的方法</p>
  <ul>
    <li><code>prevProps</code>：组件更新前的<code>props</code></li>
    <li><code>prevState</code>：组件更新前的<code>state</code></li>
  </ul>
  <blockquote>
    <p>在<code>React v16.3</code>中，在创建和更新时，只能是由父组件引发才会调用这个函数，在<code>React v16.4</code>改为无论是<code>Mounting</code>还是<code>Updating</code>，全部都会调用。</p>
  </blockquote>
  <p>是一个<span>静态函数</span>，也就是这个函数不能通过<code>this</code>访问到<code>class</code>的属性。</p>
  <blockquote>
    <p>如果<code>props</code>传入的内容不需要影响到你的<code>state</code>，那么就需要返回一个<code>null</code>，这个<strong>返回值是必须的</strong>，所以尽量将其写到函数的末尾。</p>
  </blockquote>
  <p>在组件创建时和更新时的<span>render方法之前调用</span>，它应该</p>
  <ul>
    <li>返回一个对象来更新状态</li>
    <li>或者返回<code>null</code>来不更新任何内容</li>
  </ul>
  <h3 data-id="heading-21">getSnapshotBeforeUpdate</h3>
  <p><code>getSnapshotBeforeUpdate(prevProps,prevState)</code>:<code>Updating</code>时的函数，<span>在render之后调用</span></p>
  <ul>
    <li><code>prevProps</code>：组件更新前的<code>props</code></li>
    <li><code>prevState</code>：组件更新前的<code>state</code></li>
  </ul>
  <p><span>可以读取，但无法使用DOM的时候</span>，在组件可以在可能更改之前从<code>DOM</code>捕获一些信息（例如滚动位置）</p>
  <blockquote>
    <p><strong>返回的任何值都将作为参数传递给<code>componentDidUpdate（)</code></strong></p>
  </blockquote>
  <hr>
  <h2 data-id="heading-22">Note</h2>
  <p>在<code>17.0</code>的版本，官方彻底废除</p>
  <ul>
    <li><code>componentWillMount</code>、</li>
    <li><code>componentWillReceiveProps</code>、</li>
    <li><code>componentWillUpdate</code></li>
  </ul>
  <hr>
  <h1 data-id="heading-23">Hook的相关知识点</h1>
  <blockquote>
    <p><code>react-hooks</code>是<code>React 16.8</code>的产物，<span>给函数式组件赋上了生命周期</span>。</p>
  </blockquote>
  <h2 data-id="heading-24">React v16.8中的hooks</h2>
  <h3 data-id="heading-25">useState</h3>
  <p><code>useState</code>：定义变量，可以理解为他是类组件中的<code>this.state</code>
    使用：</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(initialState);
<span class="copy-code-btn">复制代码</span></code></pre>
  <ul>
    <li><code>state</code>：目的是提供给 UI，作为<strong>渲染视图的数据源</strong></li>
    <li><code>setState</code>：改变 <code>state</code> 的函数，可以理解为<code>this.setState</code></li>
    <li><code>initialState</code>：初始默认值</li>
  </ul>
  <blockquote>
    <p><code>useState</code> 有点类似于<code>PureComponent</code>,会进行一个<span>比较浅的比较</span>，如果是<strong>对象的时候直接传入并不会更新</strong>。</p>
  </blockquote>
  <h4 data-id="heading-26">解决传入对象的问题</h4>
  <p>使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fimmerjs%2Fuse-immer" target="_blank" title="https://github.com/immerjs/use-immer" ref="nofollow noopener noreferrer">useImmer</a> 替代 useState。</p>
  <p><code>immer.js</code> 这个库，是基于 <code>proxy</code> 拦截 <code>getter</code> 和 <code>setter</code> 的能力，让我们可以很方便的通过修改对象本身，创建新的对象。</p>
  <p><code>React</code> 通过 <code>Object.is</code> 函数比较 <code>props</code>，也就是说<strong>对于引用一致的对象，react是不会刷新视图的</strong>，这也是为什么我们不能<strong>直接修改调用</strong> <code>useState</code> 得到的 state 来更新视图，而是要通过 <code>setState</code> 刷新视图，通常，为了方便，我们会使用 <code>es6</code> 的 <code>spread</code> 运算符构造新的对象（浅拷贝）。</p>
  <blockquote>
    <p>对于<strong>嵌套层级多的对象</strong>，使用 <code>spread</code> 构造新的对象写起来心智负担很大，也不易于维护</p>
  </blockquote>
  <p>常规的处理方式是对数据进行<code>deepClone</code>，但是这种处理方式针对结构简单的数据来讲还算OK，但是遇到大数据的话，就不够优雅了。</p>
  <p>所以，我们可以直接使用 <code>useImmer</code> 这个语法糖来进一步简化调用方式</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> [state,setState] = <span class="hljs-title function_">useImmer</span>({
   <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
   <span class="hljs-attr">b</span>: {
     <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>]
     <span class="hljs-attr">d</span>: <span class="hljs-number">2</span>
   },
});

<span class="hljs-title function_">setState</span>(<span class="hljs-function"><span class="hljs-params">prev</span> =&gt;</span> {
  prev.<span class="hljs-property">b</span>.<span class="hljs-property">c</span>.<span class="hljs-title function_">push</span>(<span class="hljs-number">3</span>);
}))
<span class="copy-code-btn">复制代码</span></code></pre>
  <hr>
  <h3 data-id="heading-27">useEffect</h3>
  <p><code>useEffect</code>：<strong>副作用</strong>，你可以理解为是类组件的生命周期，也是我们最常用的钩子</p>
  <blockquote>
    <p>副作用（<code>Side Effect</code>)：是<span>指 <code>function</code> 做了和本身运算返回值无关的事</span>，如请求数据、修改全局变量，打印、数据获取、设置订阅以及手动更改 <code>React</code> 组件中的 <code>DOM</code> 都属于副作用操作</p>
  </blockquote>
  <ol>
    <li>不断执行
      <ul>
        <li>当<code>useEffect</code>不设立第二个参数时，无论什么情况，都会执行</li>
      </ul>
    </li>
    <li>根据依赖值改变
      <ul>
        <li>设置<code>useEffect</code>的第二个值</li>
      </ul>
    </li>
  </ol>
  <hr>
  <h3 data-id="heading-28">useContext</h3>
  <p><code>useContext</code>：<strong>上下文</strong>，类似于<code>Context</code>：其本意就是设置全局共享数据，<span>使所有组件可跨层级实现数据共享</span></p>
  <p><code>useContent</code>的<strong>参数</strong>一般是由<code>createContext</code>的创建，通过 <code>xxContext.Provider</code> 包裹的组件，才能通过 <code>useContext</code> 获取对应的值</p>
  <h4 data-id="heading-29">存在的问题及解决方案</h4>
  <p><code>useContext</code> 是 <code>React</code> 官方推荐的共享状态的方式，然而在需要<strong>共享状态的组件非常多的情况下，这有着严重的性能问题</strong>，例如有A/B组件， A 组件只更新 <code>state.a</code>，并没有用到 <code>state.b</code>，B 组件更新 <code>state.b</code> 的时候 A 组件也会刷新，在组件非常多的情况下，就卡死了，用户体验非常不好。</p>
  <p>解决上述问题，可以使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Freact-tracked.js.org%2F" target="_blank" title="https://react-tracked.js.org/" ref="nofollow noopener noreferrer">react-tracked</a> 这个库，它拥有和 <code>useContext</code> 差不多的 api，但基于 <code>proxy</code> 和组件内部的 <code>useForceUpdate</code> 做到了<strong>自动化的追踪，可以精准更新每个组件，不会出现修改大的 state，所有组件都刷新的情况</strong>。</p>
  <hr>
  <h3 data-id="heading-30">useReducer</h3>
  <p><code>useReducer</code>：它类似于<code>redux</code>功能的api</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> [state, dispatch] = <span class="hljs-title function_">useReducer</span>(reducer, initialArg, init);
<span class="copy-code-btn">复制代码</span></code></pre>
  <ul>
    <li><code>state</code>：更新后的<code>state</code>值</li>
    <li><code>dispatch</code>：可以理解为和<code>useState</code>的<code>setState</code>一样的效果</li>
    <li><code>reducer</code>：可以理解为<code>redux</code>的<code>reducer</code></li>
    <li><code>initialArg</code>：初始值</li>
    <li><code>init</code>：惰性初始化</li>
  </ul>
  <hr>
  <h3 data-id="heading-31">useMemo</h3>
  <p><code>useMemo</code>:与<code>memo</code>的理念上差不多，都是判断是否满足<span>当前的限定条件</span>来决定是否执行<code>callback</code>函数，而<code>useMemo</code>的第二个参数是一个<strong>数组</strong>，通过这个数组来判定是否执行回调函数</p>
  <blockquote>
    <p>当一个父组件中调用了一个子组件的时候，父组件的 <code>state</code> 发生变化，会导致父组件更新，而子组件虽然没有发生改变，但也会进行更新。</p>
  </blockquote>
  <p>只要父组件的状态更新，<strong>无论有没有对子组件进行操作，子组件都会进行更新</strong>，<code>useMemo</code>就是为了防止这点而出现的。</p>
  <hr>
  <h3 data-id="heading-32">useCallback</h3>
  <p><code>useCallback</code>与<code>useMemo</code>极其类似,唯一不同的是</p>
  <ul>
    <li><code>useMemo</code>返回的是<strong>函数运行的结果</strong></li>
    <li>而<code>useCallback</code>返回的是<strong>函数</strong>
      <ul>
        <li>这个函数是父组件传递子组件的一个函数，<strong>防止做无关的刷新</strong>，</li>
        <li>其次，这个<em>子组件</em>必须配合<code>React.memo</code>,否则不但不会提升性能，还有可能降低性能</li>
      </ul>
    </li>
  </ul>
  <h4 data-id="heading-33">存在的问题及解决方案</h4>
  <p>一个很常见的误区是为了心理上的性能提升把函数通通使用 <code>useCallback</code> 包裹，在大多数情况下，<code>javascript</code> <strong>创建一个函数的开销是很小</strong>的，哪怕每次渲染都重新创建，也不会有太大的性能损耗，<span>真正的性能损耗在于，很多时候 callback 函数是组件 props 的一部分，因为每次渲染的时候都会重新创建 callback 导致函数引用不同，所以触发了组件的重渲染</span>。然而一旦函数使用 <code>useCallback</code> 包裹，则要面对声明依赖项的问题，对于一个内部捕获了很多 state 的函数，写依赖项非常容易写错，因此引发 bug。</p>
  <p>所以，<strong>在大多数场景下，我们应该只在需要维持函数引用的情况下使用 useCallback</strong>。</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> [userText, setUserText] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">""</span>);
<span class="hljs-keyword">const</span> handleUserKeyPress = <span class="hljs-title function_">useCallback</span>(<span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
    <span class="hljs-comment">// do something here</span>
}, []);

<span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">"keydown"</span>, handleUserKeyPress);
    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
        <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEventListener</span>(<span class="hljs-string">"keydown"</span>, handleUserKeyPress);
    };
}, [handleUserKeyPress]);

  <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          {userText}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
<span class="copy-code-btn">复制代码</span></code></pre>
  <blockquote>
    <p>在组件卸载的时候移除 <code>event listener callback</code>，因此需要保持 <code>event handler</code> 的引用，所以这里需要使用 <code>useCallback</code> 来保持引用不变。</p>
  </blockquote>
  <p>使用 <code>useCallback</code>，我们又会<strong>面临声明依赖项的问题</strong>，这里我们可以使用 <code>ahook</code> 中的 <a href="https://link.juejin.cn?target=https%3A%2F%2Fahooks.js.org%2Fzh-CN%2Fhooks%2Fuse-memoized-fn" target="_blank" title="https://ahooks.js.org/zh-CN/hooks/use-memoized-fn" ref="nofollow noopener noreferrer">useMemoizedFn</a> 的方式，既能保持引用，又不用声明依赖项。</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> [state, setState] = <span class="hljs-title function_">useState</span>(<span class="hljs-string">''</span>);
<span class="hljs-comment">// func 地址永远不会变化</span>
<span class="hljs-keyword">const</span> func = <span class="hljs-title function_">useMemoizedFn</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state);
});
<span class="copy-code-btn">复制代码</span></code></pre>
  <hr>
  <h3 data-id="heading-34">useRef</h3>
  <p><code>useRef</code>： 可以获取当前元素的<strong>所有属性</strong>，并且返回一个可变的<code>ref对象</code>，并且这个对象只有<code>current属性</code>，可设置<code>initialValue</code></p>
  <ol>
    <li>通过<code>useRef</code>获取对应的<code>React元素</code>的属性值</li>
    <li>缓存数据</li>
  </ol>
  <hr>
  <h3 data-id="heading-35">useImperativeHandle</h3>
  <p><code>useImperativeHandle</code>：可以让你在使用 <code>ref</code> 时<strong>自定义暴露给父组件的实例值</strong></p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-title function_">useImperativeHandle</span>(ref, createHandle, [deps])
<span class="copy-code-btn">复制代码</span></code></pre>
  <ul>
    <li><code>ref</code>：<code>useRef</code>所创建的<code>ref</code></li>
    <li><code>createHandle</code>：<strong>处理的函数</strong>，返回值作为暴露给父组件的 <code>ref</code> 对象。</li>
    <li><code>deps</code>：<strong>依赖项</strong>，依赖项更改形成新的 <code>ref</code> 对象。</li>
  </ul>
  <blockquote>
    <p><code>useImperativeHandle</code> 和<code>forwardRef</code>配合使用</p>
  </blockquote>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">FancyInput</span>(<span class="hljs-params">props, ref</span>) {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();
  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> ({
    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> {
      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();
    }
  }));
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> <span class="hljs-attr">...</span> /&gt;</span></span>;
}
<span class="hljs-title class_">FancyInput</span> = <span class="hljs-title function_">forwardRef</span>(<span class="hljs-title class_">FancyInput</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>在父组件中，可以渲染<code>&lt;FancyInput ref={inputRef} /&gt;</code>并可以通过父组件的<code>inputRef</code>对子组件中的<code>input</code>进行处理。</p>
  <ul>
    <li><code>inputRef.current.focus()</code></li>
  </ul>
  <hr>
  <h3 data-id="heading-36">useLayoutEffect</h3>
  <p><code>useLayoutEffect</code>： 与<code>useEffect</code>基本一致，不同的地方时，<code>useLayoutEffect</code>是<span>同步</span></p>
  <p>要注意的是<code>useLayoutEffect</code>在 <span>DOM 更新之后，浏览器绘制之前</span>，这样做的好处是可以更加方便的<strong>修改 DOM，获取 DOM 信息</strong>,这样浏览器只会绘制一次，所以<span>useLayoutEffect在useEffect之前执行</span></p>
  <p>如果是 <code>useEffect</code> 的话 ，<code>useEffect</code> <span>执行在浏览器绘制视图之后，如果在此时改变DOM，有可能会导致浏览器再次回流和重绘</span>。</p>
  <p>除此之外<code>useLayoutEffect</code>的 <code>callback</code> 中代码执行会<span>阻塞浏览器绘制</span></p>
  <hr>
  <h3 data-id="heading-37">useDebugValue</h3>
  <p><code>useDebugValue</code>：可用于在 <code>React</code> 开发者工具中显示自定义 <code>hook</code> 的标签</p>
  <hr>
  <h2 data-id="heading-38">React v18中的hooks</h2>
  <h3 data-id="heading-39">useSyncExternalStore</h3>
  <p><code>useSyncExternalStore</code>:是一个推荐用于<strong>读取和订阅外部数据源</strong>的 <code>hook</code>，其方式与选择性的 <code>hydration</code> 和时间切片等并发渲染功能兼容</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">useSyncExternalStore</span>(
    subscribe,
    getSnapshot[, getServerSnapshot]
)
<span class="copy-code-btn">复制代码</span></code></pre>
  <ul>
    <li><code>subscribe</code>: 订阅函数，用于注册一个回调函数，<strong>当存储值发生更改时被调用</strong>。此外， <code>useSyncExternalStore</code> 会通过带有记忆性的 <code>getSnapshot</code> 来判别数据是否发生变化，如果发生变化，那么会<strong>强制更新数据</strong>。</li>
    <li><code>getSnapshot</code>: 返回当前存储值的函数。必须返回缓存的值。如果 <code>getSnapshot</code> 连续多次调用，则必须返回相同的确切值，除非中间有存储值更新。</li>
    <li><code>getServerSnapshot</code>：返回服务端(hydration模式下)渲染期间使用的存储值的函数</li>
  </ul>
  <hr>
  <h3 data-id="heading-40">useTransition</h3>
  <blockquote>
    <p><code>useTransition</code>：</p>
    <ul>
      <li>返回一个<strong>状态值</strong>表示过渡任务的等待状态，</li>
      <li>以及一个<span>启动该过渡任务的函数</span>。</li>
    </ul>
  </blockquote>
  <p><strong>过渡任务</strong>
    在一些场景中，如：<code>输入框</code>、<code>tab切换</code>、<code>按钮</code>等，这些任务需要视图上<span>立刻做出响应</span>，这些任务可以称之为<strong>立即更新的任务</strong></p>
  <p>但有的时候，更新任务并不是那么紧急，或者来说要去请求数据等，导致新的状态不能立马更新，需要用一个<code>loading...</code>的等待状态，这类任务就是过度任务</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> [isPending, startTransition] = <span class="hljs-title function_">useTransition</span>();
<span class="copy-code-btn">复制代码</span></code></pre>
  <ul>
    <li><code>isPending</code>：<strong>过渡状态的标志</strong>，为<code>true</code>时是等待状态</li>
    <li><code>startTransition</code>：可以<strong>将里面的任务变成过渡任务</strong></li>
  </ul>
  <hr>
  <h3 data-id="heading-41">useDeferredValue</h3>
  <blockquote>
    <p><code>useDeferredValue</code>：接受一个值，并返回该值的<span>新副本</span>，该副本将<strong>推迟</strong>到更紧急地更新之后。</p>
  </blockquote>
  <p>如果当前渲染是一个紧急更新的结果，比如用户输入，<code>React</code> 将<strong>返回之前的值</strong>，然后<strong>在紧急渲染完成后渲染新的值</strong>。</p>
  <p>也就是说<code>useDeferredValue</code>可以让<span>状态滞后派生</span>。</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">const</span> deferredValue = <span class="hljs-title function_">useDeferredValue</span>(value);
<span class="copy-code-btn">复制代码</span></code></pre>
  <ul>
    <li><code>value</code>：可变的值，如<code>useState</code>创建的值</li>
    <li><code>deferredValue</code>: 延时状态</li>
  </ul>
  <blockquote>
    <p><strong>useTransition和useDeferredValue做个对比</strong></p>
    <ul>
      <li>相同点：<code>useDeferredValue</code> 和 <code>useTransition</code> 一样，都是<strong>过渡更新任务</strong></li>
      <li>不同点：<code>useTransition</code> 给的是一个<strong>状态</strong>，而<code>useDeferredValue</code>给的是一个<strong>值</strong></li>
    </ul>
  </blockquote>
  <hr>
  <h3 data-id="heading-42">useInsertionEffect</h3>
  <p><code>useInsertionEffect</code>：与 <code>useLayoutEffect</code> 一样，但它在所有 DOM 突变之前<strong>同步触发</strong></p>
  <p>在执行顺序上 <code>useInsertionEffect</code> &gt; <code>useLayoutEffect</code>  &gt; <code>useEffect</code></p>
  <blockquote>
    <p><code>seInsertionEffect</code>&nbsp;应仅限于 <code>css-in-js</code> 库作者使用。<br>优先考虑使用&nbsp;<code>useEffect</code>&nbsp;或&nbsp;<code>useLayoutEffect</code>&nbsp;来替代。</p>
  </blockquote>
  <hr>
  <h3 data-id="heading-43">useId</h3>
  <p><code>useId</code> ： 是一个<strong>用于生成横跨服务端和客户端的稳定的唯一 ID</strong> 的同时避免<code>hydration</code>不匹配的 hook。</p>
  <hr>
  <h1 data-id="heading-44">ref能否拿到函数组件的实例</h1>
  <h2 data-id="heading-45">使用<code>forwordRef</code></h2>
  <p>将<code>input</code>单独封装成一个组件<code>TextInput</code>。</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TextInput</span> =  <span class="hljs-title class_">React</span>.<span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props,ref</span>) =&gt;</span> {
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{ref}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">input</span>&gt;</span></span>
})
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>用<code>TextInputWithFocusButton</code>调用它</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 关键代码</span>
  <span class="hljs-keyword">const</span> inputEl = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onButtonClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-comment">// 关键代码，`current` 指向已挂载到 DOM 上的文本输入元素</span>
    inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();
  };
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      // 关键代码
      <span class="hljs-tag">&lt;<span class="hljs-name">TextInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputEl}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextInput</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onButtonClick}</span>&gt;</span>Focus the input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <h2 data-id="heading-46">useImperativeHandle</h2>
  <p>有时候，我们可能<strong>不想将整个子组件暴露给父组件</strong>，而只是暴露出父组件需要的值或者方法，这样可以让代码更加明确。而<code>useImperativeHandle</code> Api就是帮助我们做这件事的。</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">TextInput</span> =  <span class="hljs-title function_">forwardRef</span>(<span class="hljs-function">(<span class="hljs-params">props,ref</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> inputRef = <span class="hljs-title function_">useRef</span>();
  <span class="hljs-comment">// 关键代码</span>
  <span class="hljs-title function_">useImperativeHandle</span>(ref, <span class="hljs-function">() =&gt;</span> ({
    <span class="hljs-attr">focus</span>: <span class="hljs-function">() =&gt;</span> {
      inputRef.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();
    }
  }));
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputRef}</span> /&gt;</span></span>
})


<span class="hljs-keyword">function</span> <span class="hljs-title function_">TextInputWithFocusButton</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 关键代码</span>
  <span class="hljs-keyword">const</span> inputEl = <span class="hljs-title function_">useRef</span>(<span class="hljs-literal">null</span>);
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onButtonClick</span> = (<span class="hljs-params"></span>) =&gt; {
    <span class="hljs-comment">// 关键代码，`current` 指向已挂载到 DOM 上的文本输入元素</span>
    inputEl.<span class="hljs-property">current</span>.<span class="hljs-title function_">focus</span>();
  };
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      // 关键代码
      <span class="hljs-tag">&lt;<span class="hljs-name">TextInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">{inputEl}</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">TextInput</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{onButtonClick}</span>&gt;</span>
          Focus the input
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}

<span class="copy-code-btn">复制代码</span></code></pre>
  <p>也可以使用<code>current.focus()</code>来做<code>input</code>聚焦。</p>
  <blockquote>
    <p>这里要注意的是，子组件<code>TextInput</code>中的<code>useRef</code>对象，只是用来获取<code>input</code>元素的，大家不要和父组件的<code>useRef</code>混淆了。</p>
  </blockquote>
  <h1 data-id="heading-47">useCallbck vs useMemo的区别</h1>
  <h2 data-id="heading-48">useMemo</h2>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(
  <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">computeExpensiveValue</span>(a, b),
  [a, b]
);
<span class="copy-code-btn">复制代码</span></code></pre>
  <p><code>useMemo</code>:与<code>memo</code>的理念上差不多，都是判断是否满足<strong>当前的限定条件</strong>来决定是否执行<code>callback</code>函数，而<code>useMemo</code>的第二个参数是一个<strong>数组</strong>，通过这个数组来判定是否执行回调函数</p>
  <blockquote>
    <p>当一个父组件中调用了一个子组件的时候，父组件的 <code>state</code> 发生变化，会导致<strong>父组件更新</strong>，而子组件虽然没有发生改变，但也会进行更新。</p>
  </blockquote>
  <p>只要父组件的状态更新，<span>无论有没有对子组件进行操作，子组件都会进行更新</span>，<code>useMemo</code>就是为了防止这点而出现的。</p>
  <hr>
  <h2 data-id="heading-49">useCallback</h2>
  <blockquote>
    <p><span>useCallback 可以理解为 useMemo 的语法糖</span></p>
  </blockquote>
  <pre><code class="hljs language-diff copyable" lang="diff">const memoizedCallback = useCallback(
<span class="hljs-addition">+  () =&gt; {</span>
    doSomething(a, b);
<span class="hljs-addition">+  },</span>
  [a, b],
);
<span class="copy-code-btn">复制代码</span></code></pre>
  <p><code>useCallback</code>与<code>useMemo</code>极其类似,唯一不同的是</p>
  <blockquote>
    <ul>
      <li><code>useMemo</code>返回的是<strong>函数运行的结果</strong></li>
      <li>而<code>useCallback</code>返回的是<strong>函数</strong>
        <ul>
          <li><strong>这个函数是父组件传递子组件的一个函数</strong>，防止做无关的刷新，</li>
          <li>其次，这个<em>子组件</em>必须配合<code>React.memo</code>,否则不但不会提升性能，还有可能降低性能</li>
        </ul>
      </li>
    </ul>
  </blockquote>
  <hr>
  <h1 data-id="heading-50">React.memo</h1>
  <p><code>memo</code>：结合了 <code>pureComponent</code> 纯组件和 <code>componentShouldUpdate()</code>功能，会对传入的 <span>props</span> 进行一次对比，然后根据<strong>第二个函数返回值</strong>来进一步判断哪些<code>props</code>需要更新</p>
  <blockquote>
    <p>要注意 <code>memo</code> 是一个<span>高阶组件</span>，函数式组件和类组件都可以使用。</p>
  </blockquote>
  <p><code>memo</code> 接收两个参数:</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyComponent</span>(<span class="hljs-params">props</span>) {

}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">areEqual</span>(<span class="hljs-params">prevProps, nextProps</span>) {

}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-title class_">MyComponent</span>, areEqual);
<span class="copy-code-btn">复制代码</span></code></pre>
  <ol>
    <li>第一个参数：<strong>组件本身</strong>，也就是要优化的组件</li>
    <li>第二个参数：<code>(pre, next) =&gt; boolean</code>,
      <ul>
        <li><code>pre</code>：之前的数据</li>
        <li><code>next</code>：现在的数据</li>
        <li>返回一个布尔值</li>
        <li>若<span>为 true 则不更新</span></li>
        <li>为 <code>false</code> 更新</li>
      </ul>
    </li>
  </ol>
  <h2 data-id="heading-51">memo的注意事项</h2>
  <p><code>React.memo</code> 与 <code>PureComponent</code> 的区别：</p>
  <ul>
    <li><strong>服务对象不同</strong>：
      <ul>
        <li><code>PureComponent</code> 服务于<strong>类组件</strong>，</li>
        <li><code>React.memo</code>既可以服务于类组件，也可以服务与函数式组件，</li>
        <li><code>useMemo</code> 服务于函数式组件</li>
      </ul>
    </li>
    <li>针对的对象不同：
      <ul>
        <li><code>PureComponent</code> 针对的是<code>props</code>和<code>state</code></li>
        <li><code>React.memo</code><span>只能</span>针对<code>props</code>来决定是否渲染</li>
      </ul>
    </li>
  </ul>
  <blockquote>
    <p><code>React.memo</code> 的第二个参数的返回值与<code>shouldComponentUpdate</code>的返回值是<strong>相反的</strong></p>
    <ul>
      <li><code>React.memo</code>:返回&nbsp;<code>true</code>&nbsp;组件不渲染 ， 返回&nbsp;<code>false</code>&nbsp;组件重新渲染。</li>
      <li><code>shouldComponentUpdate</code>: 返回&nbsp;<code>true</code>&nbsp;组件渲染 ， 返回&nbsp;<code>false</code>&nbsp;组件不渲染</li>
    </ul>
  </blockquote>
  <hr>
  <h1 data-id="heading-52">类组件和函数组件的区别</h1>
  <h2 data-id="heading-53">相同点</h2>
  <p><span>组件是 <code>React</code> 可复用的最小代码片段</span>，它们会返回要在页面中渲染 <code>React</code> 元素，也正是基于这一点，所以<strong>在 <code>React</code> 中无论是函数组件，还是类组件，其实它们最终呈现的效果都是一致的</strong>。</p>
  <h2 data-id="heading-54">不同点</h2>
  <h3 data-id="heading-55">设计思想</h3>
  <ol>
    <li>类组件的根基是 <code>OOP</code>(<span>面向对象编程</span>)，所以它会有<strong>继承</strong>，有<strong>内部状态管理</strong>等</li>
    <li>函数组件的根基是 <code>FP</code>(<span>函数式编程</span>)</li>
  </ol>
  <h2 data-id="heading-56">未来的发展趋势</h2>
  <p><code>React</code> 团队从 <code>Facebook</code> 的实际业务场景触发，通过探索<span>时间切片</span>和<span>并发模式</span>，以及考虑性能的进一步优化和组件间<strong>更合理的代码拆分</strong>后，认为 类组件的模式并不能很好地适应未来的趋势，它们给出了以下3个原因：</p>
  <blockquote>
    <ol>
      <li><code>this</code> 的模糊性</li>
      <li><span>业务逻辑耦合在生命周期中</span></li>
      <li><code>React</code> 的组件代码缺乏标准的<strong>拆分方式</strong></li>
    </ol>
  </blockquote>
  <hr>
  <h1 data-id="heading-57">componentWillUnmount在浏览器刷新后，会执行吗</h1>
  <p><strong>不会</strong>。</p>
  <p>如果想实现，在刷新页面时进行数据处理。使用<code>beforeunload</code>事件。</p>
  <p>还有一个<code>navigator.sendBeacon()</code></p>
  <hr>
  <h1 data-id="heading-58">React 组件优化</h1>
  <blockquote>
    <ol>
      <li>父组件刷新，而不波及子组件</li>
      <li>组件自己控制自己是否刷新</li>
      <li>减少波及范围，无关刷新数据不存入<code>state</code>中</li>
      <li>合并 <code>state</code>,减少重复 <code>setState</code> 的操作</li>
    </ol>
  </blockquote>
  <h2 data-id="heading-59">父组件刷新，而不波及子组件</h2>
  <ol>
    <li><strong>子组件</strong>自己判断是否需要更新 ,典型的就是
      <ul>
        <li><code>PureComponent</code>，</li>
        <li><code>shouldComponentUpdate</code>，</li>
        <li><code>React.memo</code></li>
      </ul>
    </li>
    <li>父组件对子组件做个缓冲判断</li>
  </ol>
  <h3 data-id="heading-60">使用PureComponent注意点</h3>
  <ol>
    <li>父组件是<strong>函数组件</strong>，子组件用<code>PureComponent</code>时，<strong>匿名函数</strong>，<strong>箭头函数</strong>和<strong>普通函数</strong>都会重新声明
      <ul>
        <li>可以使用<code>useMemo</code>或者 <code>useCallback</code>，利用他们缓冲一份函数，保证不会出现重复声明就可以了。</li>
      </ul>
    </li>
    <li>类组件中不使用箭头函数，匿名函数
      <ul>
        <li><code>class</code> 组件中每一次刷新都会重复调用<code>render</code>函数，<strong>那么<code>render</code>函数中使用的匿名函数，箭头函数就会造成重复刷新的问题</strong></li>
        <li><strong>处理方式</strong>- 换成普通函数</li>
      </ul>
    </li>
    <li>在 <code>class</code> 组件的<code>render</code>函数中调用<code>bind</code> 函数
      <ul>
        <li>把<code>bind</code>操作放在<code>constructor</code>中</li>
      </ul>
    </li>
  </ol>
  <h3 data-id="heading-61">shouldComponentUpdate</h3>
  <p><code>class</code> 组件中 使用 <code>shouldComponentUpdate</code> 是主要的优化方式，它不仅仅可以判断来自父组件的<code>nextprops</code>，还可以根据<code>nextState</code>和最新的<code>nextContext</code>来决定是否更新。</p>
  <h3 data-id="heading-62">React.memo</h3>
  <p><code>React.memo</code>的规则是如果想要<span>复用最后一次渲染结果</span>，就返回<code>true</code>，不想复用就返回<code>false</code>。所以它和<code>shouldComponentUpdate</code>的正好相反，<code>false</code>才会更新，<code>true</code>就返回缓冲。</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Children</span> = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">memo</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">{count}</span>){
    <span class="hljs-keyword">return</span> (
        <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
            只有父组件传入的值是偶数的时候才会更新
            {count}
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    )
},<span class="hljs-function">(<span class="hljs-params">prevProps, nextProps</span>)=&gt;</span>{
    <span class="hljs-keyword">if</span>(nextProps.<span class="hljs-property">count</span> % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>){
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }<span class="hljs-keyword">else</span>{
        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
    }
})
<span class="copy-code-btn">复制代码</span></code></pre>
  <hr>
  <h2 data-id="heading-63">使用 React.useMemo来实现对子组件的缓冲</h2>
  <p>子组件<strong>只关心<code>count</code>数据</strong>，当我们刷新<code>name</code>数据的时候，并不会触发刷新 <code>Children子组件</code>，实现了我们对组件的缓冲控制。</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Father</span> (){
  <span class="hljs-keyword">let</span> [count,setCount] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">let</span> [name,setName] = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);
  <span class="hljs-keyword">const</span> render = <span class="hljs-title class_">React</span>.<span class="hljs-title function_">useMemo</span>(
          <span class="hljs-function">()=&gt;</span>
              <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Children</span> <span class="hljs-attr">count</span> = <span class="hljs-string">{count}/</span>&gt;</span></span>
              ,[count]
          )
  <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=&gt;</span>setCount(++count)}&gt;
              点击刷新count
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span>=&gt;</span>setName(++name)}&gt;
              点击刷新name
          <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
          {"count"+count}
          <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
          {"name"+name}
          <span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>
          {render}
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  )
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <h2 data-id="heading-64">减少波及范围，无关刷新数据不存入state中</h2>
  <ol>
    <li>无意义重复调用<code>setState</code>，<strong>合并相关的<code>state</code></strong></li>
    <li>和<strong>页面刷新无关的数据</strong>，不存入<code>state</code>中</li>
    <li>通过存入<code>useRef</code>的数据中，避免父子组件的重复刷新</li>
    <li>合并 <code>state</code>,减少重复 <code>setState</code> 的操作
      <ul>
        <li><code>ReactDOM.unstable_batchedUpdates</code>;</li>
        <li>多个<code>setState</code>会合并执行一次。</li>
      </ul>
    </li>
  </ol>
  <hr>
  <h1 data-id="heading-65">React-Router实现原理</h1>
  <h2 data-id="heading-66">react-router-dom和react-router和history库三者什么关系</h2>
  <ol>
    <li><code>history</code> 可以理解为<code>react-router</code>的核心，也是<span>整个路由原理的核心</span>，里面集成了<code>popState</code>,<code>history.pushState</code>等<span>底层路由实现</span>的原理方法</li>
    <li><code>react-router</code>可以理解为是<code>react-router-dom</code>的核心，里面封装了<code>Router</code>，<code>Route</code>，<code>Switch</code>等核心组件,实现了<span>从路由的改变到组件的更新的核心功能</span></li>
    <li><code>react-router-dom</code>,在<code>react-router</code>的核心基础上，添加了用于跳转的<code>Link</code>组件，和<code>histoy</code>模式下的<code>BrowserRouter</code>和<code>hash</code>模式下的<code>HashRouter</code>组件等。
      <ul>
        <li>所谓<code>BrowserRouter</code>和<code>HashRouter</code>，也只不过用了<code>history</code>库中<code>createBrowserHistory</code>和<code>createHashHistory</code>方法</li>
      </ul>
    </li>
  </ol>
  <h2 data-id="heading-67">单页面实现核心原理</h2>
  <blockquote>
    <p>单页面应用路由实现原理是，<span>切换<code>url</code>，监听<code>url</code>变化，从而渲染不同的页面组件</span>。</p>
  </blockquote>
  <p>主要的方式有<code>history</code>模式和<code>hash</code>模式。</p>
  <h3 data-id="heading-68">history模式原理</h3>
  <ol>
    <li>改变路由
      <ul>
        <li><code>history.pushState(state,title,path)</code></li>
      </ul>
    </li>
    <li>监听路由
      <ul>
        <li><code>window.addEventListener('popstate',function(e){  /* 监听改变 */})</code></li>
      </ul>
    </li>
  </ol>
  <h3 data-id="heading-69">hash模式原理</h3>
  <ol>
    <li>改变路由
      <ul>
        <li>通过<code>window.location.hash</code> 属性获取和设置 <code>hash</code> 值</li>
      </ul>
    </li>
    <li>监听路由
      <ul>
        <li><code>window.addEventListener('hashchange',function(e){  /* 监听改变 */})</code></li>
      </ul>
    </li>
  </ol>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/47ef14c7cdae4e53b7474e7e7125aaa5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <hr>
  <h1 data-id="heading-70">XXR</h1>
  <p>根据不同的构建、渲染过程有不同的优劣势和适用情况。</p>
  <ul>
    <li>现代 UI 库加持下常用的 <code>CSR</code>、</li>
    <li>具有更好 <code>SEO</code> 效果的 <code>SSR</code> (<code>SPR</code>)、</li>
    <li>转换思路主打<strong>构建时生成</strong>的 <code>SSG</code>、</li>
    <li>大架构视野之上的 <code>ISR</code>、<code>DPR</code>，</li>
    <li>还有更少听到的 <code>NSR</code>、<code>ESR</code>。</li>
  </ul>
  <h2 data-id="heading-71">CSR(Client Side Rendering)</h2>
  <blockquote>
    <p>页面托管服务器只需要对页面的<strong>访问请求响应</strong>一个如下的<strong>空页面</strong></p>
  </blockquote>
  <pre><code class="hljs language-html copyable" lang="html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>
    <span class="hljs-comment">&lt;!-- metas --&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"shortcut icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"xxx.png"</span> /&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"xxx.css"</span> /&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"root"</span>&gt;</span><span class="hljs-comment">&lt;!-- page content --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx/filterXss.min.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx/x.chunk.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"xxx/main.chunk.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>页面中留出一个<span>用于填充渲染内容的视图节点</span> (<code>div#root</code>)，并插入指向项目<strong>编译压缩后</strong>的</p>
  <ul>
    <li><code>JS Bundle</code> 文件的 <code>script</code> 节点</li>
    <li>指向 <code>CSS</code> 文件的 <code>link.stylesheet</code> 节点等。</li>
  </ul>
  <p>浏览器接收到这样的文档响应之后，会<span>根据文档内的链接加载脚本与样式资源</span>，并完成以下几方面主要工作：</p>
  <blockquote>
    <ol>
      <li><strong>执行脚本</strong></li>
      <li>进行<strong>网络访问以获取在线数据</strong></li>
      <li>使用 DOM API <strong>更新页面结构</strong></li>
      <li><strong>绑定交互事件</strong></li>
      <li><strong>注入样式</strong></li>
    </ol>
  </blockquote>
  <p>以此完成整个渲染过程。</p>
  <p>CSR 模式有以下几方面优点：</p>
  <ul>
    <li>UI 库支持</li>
    <li><strong>前后端分离</strong></li>
    <li><strong>服务器负担轻</strong></li>
  </ul>
  <hr>
  <h2 data-id="heading-72">SSR (Server Side Rendering)</h2>
  <p>SSR 的概念，即与 <code>CSR</code> 相对地，<span>在服务端完成大部分渲染工作</span>，--- 服务器在响应站点访问请求的时候，就已经<span>渲染好可供呈现的页面</span>。</p>
  <p>像 <code>React</code>、<code>Vue</code> 这样的 UI 生态巨头，其实都有一个关键的 <code>Virtual DOM</code> (or VDOM) 概念,先自己<strong>建模处理视图表现与更新</strong>、再批量调 <code>DOM API</code> 完成视图渲染更新。这就带来了一种 <code>SSR</code> 方案：</p>
  <p><code>VDOM</code> 是<strong>自建模型</strong>，是一种<span>抽象的嵌套数据结构</span>，也就可以在 <code>Node</code> 环境（或者说一切服务端环境）下跑起来，<strong>把原来的视图代码拿来在服务端跑</strong>，通过 <code>VDOM</code> 维护，再在最后<strong>拼接好字符串作为页面响应</strong>，生成文档作为响应页面，此时的页面内容已经基本生成完毕，把逻辑代码、样式代码附上，则可以实现完整的、可呈现页面的响应。</p>
  <h3 data-id="heading-73">SSR优点</h3>
  <ul>
    <li>呈现速度和用户体验佳</li>
    <li><code>SEO</code> 友好</li>
  </ul>
  <h3 data-id="heading-74">SSR缺点</h3>
  <ol>
    <li>引入成本高
      <ul>
        <li>将视图渲染的工作交给了服务器做，引入了新的概念和技术栈（如 Node）</li>
      </ul>
    </li>
    <li>响应时间长
      <ul>
        <li>SSR 在完成访问响应的时候需要做更多的计算和生成工作</li>
        <li>关键指标 <code>TTFB</code> (<code>Time To First Byte</code>) 将变得更大</li>
      </ul>
    </li>
    <li>首屏交互不佳
      <ul>
        <li>虽然 SSR 可以让页面请求响应后更快在浏览器上渲染出来</li>
        <li>但在首帧出现，需要客户端加载激活的逻辑代码（如事件绑定）还没有初始化完毕的时候，其实是不可交互的状态</li>
      </ul>
    </li>
  </ol>
  <hr>
  <h3 data-id="heading-75">SSR-React 原理</h3>
  <ol>
    <li>VDOM</li>
    <li>同构</li>
    <li>双端对比</li>
  </ol>
  <h4 data-id="heading-76">VDOM</h4>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3d052082765947a38922d92d2a96965f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <h4 data-id="heading-77">同构</h4>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c09dd079ae444cfeb4d368def0874376~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c75da06489054600a6803d94c3e0933b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <h4 data-id="heading-78">双端对比</h4>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/423e3fefb8f64fe6ae0a050aa0ff73d7~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <h5 data-id="heading-79">renderToString()</h5>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/057226c98dfa49f6b4c6bc8b5d4d99aa~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <h5 data-id="heading-80">renderToStaticMarkup()</h5>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-title class_">ReactDOMServer</span>.<span class="hljs-title function_">renderToStaticMarkup</span>(element)
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>仅仅是为了将组件渲染为html字符串，不会带有<code>data-react-checksum</code>属性</p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c913278ed284d75a846692bbc0f19bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <hr>
  <h3 data-id="heading-81">SPR (Serverless Pre-Rendering)</h3>
  <p>无服务预渲染，这是 <code>Serverless</code> 话题之下的一项渲染技术。<code>SPR</code> 是指在 <code>SSR</code> 架构下<span>通过预渲染与缓存能力，将部分页面转化为静态页面</span>，以避免其在服务器接收到请求的时候频繁被渲染的能力，同时一些框架还支持<strong>设置静态资源过期时间</strong>，以确保这部分“静态页面”也能有一定的即时性。</p>
  <hr>
  <h2 data-id="heading-82">SSG (Static Site Generation)</h2>
  <ul>
    <li>它与 <code>CSR</code> 一样，只需要<strong>页面托管</strong>，不需要真正编写并部署服务端，<span>页面资源在编译完成部署之前就已经确定</span>；</li>
    <li>但它又与 <code>SSR</code> 一样，属于一种 <code>Prerender</code> 预渲染操作，即在用户浏览器得到页面响应之前，页面内容和结构就已经渲染好了。</li>
    <li>当然形式和特征来看，它更接近 SSR。</li>
  </ul>
  <blockquote>
    <p><code>SSG</code> 模式，把原本日益动态化、交互性增强的页面，变成了大部分已经填充好，托管在页面服务 / CDN 上的<strong>静态页面</strong></p>
  </blockquote>
  <hr>
  <h2 data-id="heading-83">NSR (Native Side Rendering)</h2>
  <p><code>Native</code> 就是客户端，万物皆可<strong>分布式</strong>，可以理解为这就是一种分布式的 <code>SSR</code>，不过这里的<span>渲染工作交给了客户端去做而不是远端服务器</span>。在用户即将访问页面的<strong>上级页面预取页面数据，由客户端缓存 HTML 结构，以达到用户真正访问时快速响应的效果</strong>。</p>
  <p>NSR 见于各种移动端 + <code>Webview</code> 的 <code>Hybrid</code> 场景，是需要页面与客户端研发协作的一种优化手段。</p>
  <hr>
  <h2 data-id="heading-84">ESR (Edge Side Rendering)</h2>
  <p><code>Edge</code> 就是边缘，类比前面的各种 <code>XSR</code>，<code>ESR</code> 就是将渲染工作交给<span>边缘服务器节点</span>，常见的就是 <code>CDN</code> 的边缘节点。这个方案主打的是<strong>边缘节点相比核心服务器与用户的距离优势</strong>，利用了 <code>CDN</code> 分级缓存的概念，渲染和内容填充也可以是分级进行并缓存下来的。</p>
  <p><code>ESR</code> 之下<span>静态内容与动态内容是分流的</span>，</p>
  <ol>
    <li>边缘 CDN 节点可以将静态页面内容先响应给用户</li>
    <li>然后再自己发起动态内容请求，得到核心服务器响应之后再返回给用户</li>
  </ol>
  <p>是在大型网络架构下非常极致的一种优化，但这也就依赖更庞大的技术基建体系了。</p>
  <hr>
  <h2 data-id="heading-85">ISR (Incremental Site Rendering)</h2>
  <p><strong>增量式网站渲染</strong>，就是对待页面内容小刀切，<strong>有更细的差异化渲染粒度</strong>，能渐进、分层地进行渲染。</p>
  <p>常见的选择是：</p>
  <ul>
    <li>对于重要页面如首屏、访问量较大的直接落地页，进行<strong>预渲染并添加缓存</strong>，保证最佳的访问性能；</li>
    <li>对于次要页面，则确保有兜底内容可以即时 <code>fallback</code>，再将其实时数据的渲染留到 CSR 层次完成，同时触发异步缓存更新。</li>
  </ul>
  <p>对于“异步缓存更新”，则需要提到一个常见的内容缓存策略：<code>Stale While Revalidate</code>，CDN 对于数据请求始终首先响应缓存内容，如果这份内容已经过期，则<strong>在响应之后再触发异步更新</strong>——这也是对于次要元素或页面的缓存处理方式。</p>
  <hr>
  <h1 data-id="heading-86">WebComponents</h1>
  <p><code>Web Components</code> 是一套不同的技术，允许您创建可重用的定制元素并且在您的 web 应用中使用它们</p>
  <h2 data-id="heading-87">三要素</h2>
  <ol>
    <li><code>Custom elements</code>（自定义元素）： 一组 <code>JavaScript</code> API，允许您定义 <code>custom elements</code> 及其行为，然后可以在您的用户界面中按照需要使用它们。
      <ul>
        <li>通过 <code>class A extends HTMLElement {}</code> 定义组件，</li>
        <li>通过 <code>window.customElements.define('a-b', A)</code> 挂载已定义组件。</li>
      </ul>
    </li>
    <li><code>Shadow DOM</code>（影子 DOM ）：一组 <code>JavaScript</code> API，用于将封装的“影子” DOM 树附加到元素（<strong>与主文档 DOM 分开呈现</strong>）并控制其关联的功能。
      <ul>
        <li>通过这种方式，您可以<strong>保持元素的功能私有</strong>，这样它们就可以被<span>脚本化</span>和<span>样式化</span>，而不用担心与文档的其他部分发生冲突。</li>
        <li>使用 <code>const shadow = this.attachShadow({mode : 'open'})</code> 在 <code>WebComponents</code> 中开启。</li>
      </ul>
    </li>
    <li><code>HTML templates</code>（HTML 模板）<code>slot</code> ：<code>template</code> 可以简化生成 <code>dom</code> 元素的操作，不再需要 <code>createElement</code> 每一个节点。</li>
  </ol>
  <p>虽然 <code>WebComponents</code> 有三个要素，但却不是缺一不可的，<code>WebComponents</code></p>
  <blockquote>
    <ul>
      <li>借助 <code>shadow dom</code>  来实现<strong>样式隔离</strong>，</li>
      <li>借助 <code>templates</code> 来<strong>简化标签</strong>的操作。</li>
    </ul>
  </blockquote>
  <hr>
  <h2 data-id="heading-88">内部生命周期函数（4个）</h2>
  <ol>
    <li><code>connectedCallback</code>: 当 <code>WebComponents</code> <strong>第一次</strong>被挂在到 <code>dom</code> 上是触发的钩子，并且只会触发一次。
      <ul>
        <li>类似  <code>React</code> 中的 <code>useEffect(() =&gt; {}, [])</code>，<code>componentDidMount</code>。</li>
      </ul>
    </li>
    <li><code>disconnectedCallback</code>: 当自定义元素与文档 <code>DOM</code> <strong>断开连接</strong>时被调用。</li>
    <li><code>adoptedCallback</code>: 当自定义元素被<strong>移动</strong>到新文档时被调用。</li>
    <li><code>attributeChangedCallback</code>: <span>当自定义元素的被监听属性变化时被调用</span>。</li>
  </ol>
  <hr>
  <h2 data-id="heading-89">组件通信</h2>
  <h3 data-id="heading-90">传入复杂数据类型</h3>
  <ul>
    <li>
      <p>传入一个 <code>JSON</code> 字符串配饰<code>attribute</code></p>
      <ul>
        <li><code>JSON.stringify</code>配置指定属性</li>
        <li>在组件<code>attributeChangedCallback</code>中判断对应属性，然后用<code>JSON.parse()</code>获取</li>
      </ul>
    </li>
    <li>
      <p>配置DOM的<code>property</code>属性</p>
      <ul>
        <li><code>xx.dataSource = [{ name: 'xxx', age: 19 }]</code></li>
        <li>但是，<span>自定义组件中没有办法监听到这个属性的变化</span></li>
        <li>如果想实现，复杂的结构，不是通过配置，而是在定义组件时候，就确定</li>
      </ul>
    </li>
  </ul>
  <h3 data-id="heading-91">状态的双向绑定</h3>
  <pre><code class="hljs language-kotlin copyable" lang="kotlin">&lt;wl-input id=<span class="hljs-string">"ipt"</span>
          :value=<span class="hljs-string">"data"</span>
          <span class="hljs-meta">@change</span>=<span class="hljs-string">"(e) =&gt; { data = e.detail }"</span>&gt;
&lt;/wl-input&gt;

<span class="hljs-comment">// js</span>
(function () {
  <span class="hljs-keyword">const</span> template = document.createElement(<span class="hljs-string">'template'</span>)
  template.innerHTML = `
  &lt;style&gt;
    .wl-input {

    }
  &lt;/style&gt;
  &lt;input type=<span class="hljs-string">"text"</span> id=<span class="hljs-string">"wlInput"</span>&gt;
  `
  <span class="hljs-keyword">class</span> <span class="hljs-title class_">WlInput</span> <span class="hljs-title">extends</span> <span class="hljs-title">HTMLElement</span> {
    <span class="hljs-keyword">constructor</span>() {
      <span class="hljs-keyword">super</span>()
      <span class="hljs-keyword">const</span> shadow = <span class="hljs-keyword">this</span>.attachShadow({
        mode: <span class="hljs-string">'closed'</span>
      })
      <span class="hljs-keyword">const</span> content = template.content.cloneNode(<span class="hljs-literal">true</span>)
      <span class="hljs-keyword">this</span>._input = content.querySelector(<span class="hljs-string">'#wlInput'</span>)
      <span class="hljs-keyword">this</span>._input.value = <span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">'value'</span>)
      shadow.appendChild(content)
      <span class="hljs-keyword">this</span>._input.addEventListener(<span class="hljs-string">"input"</span>, ev =&gt; {
        <span class="hljs-keyword">const</span> target = ev.target;
        <span class="hljs-keyword">const</span> value = target.value;
        <span class="hljs-keyword">this</span>.value = value;
        <span class="hljs-keyword">this</span>.dispatchEvent(
            new CustomEvent(<span class="hljs-string">"change"</span>, { detail: value })
            );
      });
    }
    <span class="hljs-keyword">get</span> value() {
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">"value"</span>);
    }
    <span class="hljs-keyword">set</span> value(value) {
      <span class="hljs-keyword">this</span>.setAttribute(<span class="hljs-string">"value"</span>, value);
    }
  }
  window.customElements.define(<span class="hljs-string">'wl-input'</span>, WlInput)
})()
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>监听了这个表单的 <code>input</code> 事件，并且在每次触发 <code>input</code> 事件的时候触发自定义的 <code>change</code> 事件，并且把输入的参数回传。</p>
  <hr>
  <h2 data-id="heading-92">样式设置</h2>
  <h3 data-id="heading-93">直接给自定义标签添加样式</h3>
  <pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">
    wl-<span class="hljs-selector-tag">input</span>{
        <span class="hljs-attribute">display</span>: block;
        <span class="hljs-attribute">margin</span>: <span class="hljs-number">20px</span>;
        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;
    }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">wl-input</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">wl-input</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"./index.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <h3 data-id="heading-94">定义元素内部子元素设置样式</h3>
  <p>分为两种场景：</p>
  <ol>
    <li>在主 DOM 使用 JS</li>
    <li>在 Custom Elements 构造函数中使用 JS</li>
  </ol>
  <h4 data-id="heading-95">在主 DOM 使用 JS 给 Shadow DOM 增加 style 标签：</h4>
  <pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WlInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {
        <span class="hljs-title function_">constructor</span> () {
            <span class="hljs-variable language_">super</span>();
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({<span class="hljs-attr">mode</span>: <span class="hljs-string">"open"</span>});

            <span class="hljs-keyword">let</span> headerEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
            headerEle.<span class="hljs-property">className</span> = <span class="hljs-string">"input-header"</span>;
            headerEle.<span class="hljs-property">innerText</span> = <span class="hljs-string">"北宸南蓁"</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span>.<span class="hljs-title function_">appendChild</span>(headerEle);
        }
    }

    <span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">"wl-input"</span>, <span class="hljs-title class_">WlInput</span>);

    <span class="hljs-comment">// 给 Shadow DOM 增加 style 标签</span>
    <span class="hljs-keyword">let</span> styleEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"style"</span>);
    styleEle.<span class="hljs-property">textContent</span> = <span class="hljs-string">`
        .input-header{
            padding:10px;
            background-color: yellow;
            font-size: 16px;
            font-weight: bold;
        }
    `</span>;
    <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">"wl-input"</span>).<span class="hljs-property">shadowRoot</span>.<span class="hljs-title function_">appendChild</span>(styleEle);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <h4 data-id="heading-96">在 Custom Elements 构造函数中使用 JS 增加 style 标签：</h4>
  <pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WlInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {
        <span class="hljs-title function_">constructor</span> () {
            <span class="hljs-variable language_">super</span>();
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({<span class="hljs-attr">mode</span>: <span class="hljs-string">"open"</span>});
            <span class="hljs-keyword">let</span> styleEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"style"</span>);
            styleEle.<span class="hljs-property">textContent</span> = <span class="hljs-string">`
                .input-header{
                    padding:10px;
                    background-color: yellow;
                    font-size: 16px;
                    font-weight: bold;
                }
            `</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span>.<span class="hljs-title function_">appendChild</span>(styleEle);


            <span class="hljs-keyword">let</span> headerEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
            headerEle.<span class="hljs-property">className</span> = <span class="hljs-string">"input-header"</span>;
            headerEle.<span class="hljs-property">innerText</span> = <span class="hljs-string">"北宸南蓁"</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span>.<span class="hljs-title function_">appendChild</span>(headerEle);
        }
    }
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">"wl-input"</span>, <span class="hljs-title class_">WlInput</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <h3 data-id="heading-97">引入 CSS 文件</h3>
  <p>使用 JS 创建 link 标签，然后引入 CSS 文件给自定义元素内部的子元素设置样式</p>
  <pre><code class="hljs language-html copyable" lang="html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">class</span> <span class="hljs-title class_">WlInput</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">HTMLElement</span> {
        <span class="hljs-title function_">constructor</span> () {
            <span class="hljs-variable language_">super</span>();
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">attachShadow</span>({<span class="hljs-attr">mode</span>: <span class="hljs-string">"open"</span>});
            <span class="hljs-keyword">let</span> linkEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"link"</span>);
            linkEle.<span class="hljs-property">rel</span> = <span class="hljs-string">"stylesheet"</span>;
            linkEle.<span class="hljs-property">href</span> = <span class="hljs-string">"./my_input.css"</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span>.<span class="hljs-title function_">appendChild</span>(linkEle);


            <span class="hljs-keyword">let</span> headerEle = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">"div"</span>);
            headerEle.<span class="hljs-property">className</span> = <span class="hljs-string">"input-header"</span>;
            headerEle.<span class="hljs-property">innerText</span> = <span class="hljs-string">"北宸南蓁"</span>;
            <span class="hljs-variable language_">this</span>.<span class="hljs-property">shadow</span>.<span class="hljs-title function_">appendChild</span>(headerEle);
        }
    }
    <span class="hljs-variable language_">window</span>.<span class="hljs-property">customElements</span>.<span class="hljs-title function_">define</span>(<span class="hljs-string">"wl-input"</span>, <span class="hljs-title class_">WlInput</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>样式文件</p>
  <pre><code class="hljs language-css copyable" lang="css"><span class="hljs-selector-class">.input-header</span>{
    <span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span>;
    <span class="hljs-attribute">background-color</span>: yellow;
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;
    <span class="hljs-attribute">font-weight</span>: bold;
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <hr>
  <h1 data-id="heading-98">Lit</h1>
  <p><code>Lit</code> 的核心是一个组件基类，它提供<strong>响应式</strong>、<strong>scoped 样式</strong>和一个小巧、快速且富有表现力的声明性<strong>模板系统</strong>，且支持 <code>TypeScript</code> 类型声明。</p>
  <blockquote>
    <p>Lit 在开发过程中<span>不需要编译或构建</span>，几乎可以在无工具的情况下使用。</p>
  </blockquote>
  <p>我们知道 <code>HTMLElement</code> 是浏览器内置的类，<code>LitElement</code> 基类则是 <code>HTMLElement</code> 的子类，因此 <code>Lit</code> 组件继承了所有标准 <code>HTMLElement</code> 属性和方法。更具体来说，<code>LitElement</code> 继承自 <code>ReactiveElement</code>，后者实现了响应式属性，而后者又继承自 <code>HTMLElement</code>。</p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fed5ae5877d94e2ea77312e2b1a91cf2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>而 <code>LitElement</code> 框架则是基于 <code>HTMLElement</code> 类二次封装了 <code>LitElement</code> 类。</p>
  <pre><code class="hljs language-js copyable" lang="js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LitButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LitElement</span> { <span class="hljs-comment">/* ... */</span>  }
customElements.<span class="hljs-title function_">define</span>(<span class="hljs-string">'lit-button'</span>, <span class="hljs-title class_">LitButton</span>);
<span class="copy-code-btn">复制代码</span></code></pre>
  <h2 data-id="heading-99">渲染</h2>
  <p>组件具有 <code>render</code> 方法，该方法被调用以渲染组件的内容。</p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LitButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">LitElement</span> {
 <span class="hljs-comment">/* ... */</span>

 <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 使用模板字符串，可以包含表达式</span>
    <span class="hljs-keyword">return</span> html`<span class="xml">
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"btnText"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    `</span>;
  }
}

<span class="copy-code-btn">复制代码</span></code></pre>
  <p>组件的 <code>render()</code> 方法返回单个 <code>TemplateResult</code> 对象</p>
  <hr>
  <h2 data-id="heading-100">响应式 properties</h2>
  <blockquote>
    <p>DOM 中 <code>property</code> 与 <code>attribute</code> 的区别：</p>
    <ul>
      <li><code>attribute</code> 是 <code>HTML</code> 标签上的特性，可以理解为<span>标签属性</span>，它的值只能够是 <code>String</code> 类型，并且会<span>自动添加同名 DOM 属性作为 property 的初始值</span>；</li>
      <li><code>property</code> 是 <code>DOM</code> 中的属性，是 <code>JavaScript</code> 里的对象，有同名 <code>attribiute</code> 标签属性的 <code>property</code> 属性值的改变也并<span>不会同步引起 <code>attribute</code> 标签属性值的改变</span>；</li>
    </ul>
  </blockquote>
  <p><code>Lit</code> 组件接收标签属性 <code>attribute</code> 并将其状态存储为 <code>JavaScript</code> 的 <code>class</code> 字段属性或 <code>properties</code>。<strong>响应式 <code>properties</code> 是可以在更改时触发响应式更新周期、重新渲染组件以及可选地读取或重新写入 <code>attribute</code> 的属性</strong>。每一个 <code>properties</code> 属性都可以配置它的选项对象</p>
  <h3 data-id="heading-101">传入复杂数据类型</h3>
  <p>对于复杂数据的处理，为什么会存在这个问题，根本原因还是因为 <code>attribute</code> 标签属性值只能是 <code>String</code> 类型，其他类型需要进行序列化。在 <code>LitElement</code> 中，只需要在父组件模板的属性值前使用<code>.</code>操作符，这样子组件内部 <code>properties</code> 就可以正确序列化为目标类型。</p>
  <h3 data-id="heading-102">优点</h3>
  <p><code>LitElement</code> 在 <code>Web Components</code> 开发方面有着很多比原生的优势，它具有以下特点：</p>
  <blockquote>
    <ol>
      <li>简单：在 <code>Web Components</code> 标准之上构建，<code>Lit</code> 添加了<strong>响应式、声明性模板</strong>和一些周到的功能，<strong>减少了模板文件</strong>。</li>
      <li>快速：更新速度很快，因为 <code>Lit</code> 会跟踪 <code>UI</code> 的动态部分，并且<span>只在底层状态发生变化时更新那些部分——无需重建整个虚拟树并将其与 DOM 的当前状态进行比较</span>。</li>
      <li>轻便：<code>Lit</code> 的压缩后大小约为 5 KB，有助于<strong>保持较小的包大小并缩短加载时间</strong>。</li>
      <li>高扩展性：<code>lit-html</code> 基于标记的 <code>template</code>，它结合了 ES6 中的模板字符串语法，使得它<span>无需预编译、预处理，就能获得浏览器原生支持，并且扩展能力强</span>。</li>
      <li>兼容良好：对浏览器兼容性非常好，对主流浏览器都能有非常好的支持。</li>
    </ol>
  </blockquote>
  <hr>
  <h1 data-id="heading-103">npm</h1>
  <h2 data-id="heading-104">嵌套的 node_modules 结构</h2>
  <p><code>npm</code> 在早期采用的是<span>嵌套的 node_modules 结构</span>，<strong>直接依赖</strong>会平铺在 <code>node_modules</code> 下，<strong>子依赖</strong>嵌套在直接依赖的 <code>node_modules</code> 中。</p>
  <p>比如项目依赖了A 和 C，而 A 和 C 依赖了不同版本的 <code>B@1.0</code> 和 <code>B@2.0</code>，<code>node_modules</code> 结构如下：</p>
  <pre><code class="hljs language-kotlin copyable" lang="kotlin">node_modules
├── <span class="hljs-symbol">A@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
│   └── node_modules
│       └── <span class="hljs-symbol">B@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
└── <span class="hljs-symbol">C@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
    └── node_modules
        └── <span class="hljs-symbol">B@</span><span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>如果 D 也依赖 <a href="https://link.juejin.cn?target=mailto%3AB%401.0" target="_blank" title="mailto:B@1.0" ref="nofollow noopener noreferrer">B@1.0</a>，会生成如下的嵌套结构：</p>
  <pre><code class="hljs language-kotlin copyable" lang="kotlin">node_modules
├── <span class="hljs-symbol">A@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
│   └── node_modules
│       └── <span class="hljs-symbol">B@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
├── <span class="hljs-symbol">C@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
│   └── node_modules
│       └── <span class="hljs-symbol">B@</span><span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
└── <span class="hljs-symbol">D@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
    └── node_modules
        └── <span class="hljs-symbol">B@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>可以看到<strong>同版本的 B 分别被 A 和 D 安装了两次</strong>。</p>
  <h2 data-id="heading-105">依赖地狱 Dependency Hell</h2>
  <p>在真实场景下，依赖增多，冗余的包也变多，<code>node_modules</code> 最终会堪比黑洞，很快就能把磁盘占满。而且依赖嵌套的深度也会十分可怕，这个就是依赖地狱。</p>
  <h2 data-id="heading-106">扁平的 node_modules 结构</h2>
  <p>为了将嵌套的依赖尽量打平，避免过深的依赖树和包冗余，<code>npm v3</code> 将<span>子依赖提升</span>(hoist)，采用<strong>扁平的</strong> <code>node_modules</code> 结构，子依赖会<strong>尽量平铺安装在主依赖项所在的目录中</strong>。</p>
  <pre><code class="hljs language-kotlin copyable" lang="kotlin">node_modules
├── <span class="hljs-symbol">A@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
├── <span class="hljs-symbol">B@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
└── <span class="hljs-symbol">C@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
    └── node_modules
        └── <span class="hljs-symbol">B@</span><span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>可以看到 <code>A</code> 的子依赖的 <code>B@1.0</code> 不再放在 A 的 <code>node_modules</code> 下了，而是与 A 同层级。</p>
  <p>而 <code>C</code> 依赖的 <code>B@2.0</code> 因为版本号原因还是嵌套在 C 的 <code>node_modules</code> 下。</p>
  <p>这样不会造成大量包的重复安装，依赖的层级也不会太深，解决了依赖地狱问题，但也形成了新的问题。</p>
  <h2 data-id="heading-107">幽灵依赖 Phantom dependencies</h2>
  <blockquote>
    <p>幽灵依赖是指<strong>在 <code>package.json</code> 中未定义的依赖，但项目中依然可以正确地被引用到</strong>。</p>
  </blockquote>
  <p>比如上方的示例其实我们只安装了 A 和 C：</p>
  <pre><code class="hljs language-json copyable" lang="json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">"dependencies"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"A"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0.0"</span><span class="hljs-punctuation">,</span>
    <span class="hljs-attr">"C"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"^1.0.0"</span>
  <span class="hljs-punctuation">}</span>
<span class="hljs-punctuation">}</span>

<span class="copy-code-btn">复制代码</span></code></pre>
  <p>由于 <code>B</code> 在安装时被提升到了和 <code>A</code> 同样的层级，所以在<strong>项目中引用 B 还是能正常工作的</strong>。</p>
  <p>幽灵依赖是由依赖的声明丢失造成的，如果某天某个版本的 <code>A</code> 依赖不再依赖 <code>B</code> 或者 <code>B</code> 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。</p>
  <h2 data-id="heading-108">不确定性 Non-Determinism</h2>
  <p>不确定性是指：同样的 <code>package.json</code> 文件，<code>install</code> 依赖后可能不会得到同样的 <code>node_modules</code> 目录结构。</p>
  <p>如果有 <code>package.json</code> 变更，本地需要删除 <code>node_modules</code> 重新 <code>install</code>，否则可能会导致生产环境与开发环境 <code>node_modules</code> 结构不同，代码无法正常运行。</p>
  <h2 data-id="heading-109">依赖分身 Doppelgangers</h2>
  <p>假设继续再安装依赖 <code>B@1.0</code> 的 <code>D</code> 模块和依赖 <code>@B2.0</code> 的 <code>E</code> 模块，此时：</p>
  <p><code>A</code> 和 <code>D</code> 依赖 <code>B@1.0</code>
    <code>C</code> 和 <code>E</code> 依赖 <code>B@2.0</code>
    以下是提升 <code>B@1.0</code> 的 <code>node_modules</code> 结构：</p>
  <pre><code class="hljs language-kotlin copyable" lang="kotlin">node_modules
├── <span class="hljs-symbol">A@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
├── <span class="hljs-symbol">B@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
├── <span class="hljs-symbol">D@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
├── <span class="hljs-symbol">C@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
│   └── node_modules
│       └── <span class="hljs-symbol">B@</span><span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
└── <span class="hljs-symbol">E@</span><span class="hljs-number">1.0</span><span class="hljs-number">.0</span>
    └── node_modules
        └── <span class="hljs-symbol">B@</span><span class="hljs-number">2.0</span><span class="hljs-number">.0</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>可以看到 <code>B@2.0</code> 会被安装两次，实际上无论提升 <code>B@1.0</code> 还是 <code>B@2.0</code>，都会存在重复版本的 <code>B</code> 被安装，这两个重复安装的 <code>B</code> 就叫 <code>doppelgangers</code>。</p>
  <hr>
  <h1 data-id="heading-110">yarn</h1>
  <p><code>yarn</code> 也采用<strong>扁平化</strong> <code>node_modules</code> 结构</p>
  <h2 data-id="heading-111">提升安装速度</h2>
  <p>在 <code>npm</code> 中安装依赖时，<strong>安装任务是串行的</strong>，会按包顺序逐个执行安装，这意味着它会等待一个包完全安装，然后再继续下一个。</p>
  <p>为了加快包安装速度，<code>yarn</code> 采用了<span>并行操作</span>，在性能上有显著的提高。而且在<span>缓存机制上</span>，<code>yarn</code> 会<strong>将每个包缓存在磁盘上</strong>，在下一次安装这个包时，可以脱离网络实现从磁盘离线安装。</p>
  <h2 data-id="heading-112">lockfile 解决不确定性</h2>
  <p><code>yarn</code> 更大的贡献是发明了 <code>yarn.lock</code>。</p>
  <p>在依赖安装时，会根据 <code>package.josn</code> 生成一份 <code>yarn.lock</code> 文件。</p>
  <p><code>lockfile</code> 里记录了依赖，以及依赖的子依赖，依赖的版本，获取地址与验证模块完整性的 hash。</p>
  <blockquote>
    <p>即使是不同的安装顺序，相同的依赖关系在任何的环境和容器中，都能得到稳定的 <code>node_modules</code> 目录结构，保证了依赖安装的确定性。</p>
  </blockquote>
  <p>所以 <code>yarn</code> 在出现时被定义为快速、安全、可靠的依赖管理。而 npm 在一年后的 <code>v5</code> 才发布了 <code>package-lock.json</code>。</p>
  <h2 data-id="heading-113">与 npm 一样的弊端</h2>
  <p><code>yarn</code> 依然和 <code>npm</code> 一样是扁平化的 <code>node_modules</code> 结构，没有解决<strong>幽灵依赖</strong>和<strong>依赖分身</strong>问题。</p>
  <hr>
  <h1 data-id="heading-114">pnpm</h1>
  <h2 data-id="heading-115">内容寻址存储 CAS</h2>
  <p>与依赖提升和扁平化的 <code>node_modules</code> 不同，<code>pnpm</code> 引入了另一套依赖管理策略：<span>内容寻址存储</span>。</p>
  <blockquote>
    <p>该策略会将包安装在系统的<strong>全局 store 中</strong>，依赖的每个版本只会在系统中安装一次。</p>
  </blockquote>
  <p>在引用项目 <code>node_modules</code> 的依赖时，会通过<strong>硬链接</strong>与<strong>符号链接</strong>在全局 <code>store</code> 中找到这个文件。为了实现此过程，<code>node_modules</code> 下会多出 <code>.pnpm</code> 目录，而且是非扁平化结构。</p>
  <ul>
    <li>
      <p>硬链接 <code>Hard link</code>：硬链接可以理解为<strong>源文件的副本</strong>，项目里安装的其实是副本，它使得用户可以通过路径引用查找到全局 <code>store</code> 中的源文件，而且这个副本根本不占任何空间。同时，<code>pnpm</code> 会在全局 <code>store</code> 里存储硬链接，不同的项目可以从全局 <code>store</code> 寻找到同一个依赖，大大地节省了磁盘空间。</p>
    </li>
    <li>
      <p>符号链接 <code>Symbolic link</code>：也叫软连接，可以理解为快捷方式，<code>pnpm</code> 可以通过它找到对应磁盘目录下的依赖地址。</p>
    </li>
  </ul>
  <p>由于链接的优势，<code>pnpm</code> 的安装速度在大多数场景都比 <code>npm</code> 和 <code>yarn</code> 快 2 倍，节省的磁盘空间也更多。</p>
  <hr>
  <h1 data-id="heading-116">yarn Plug’n’Play</h1>
  <p><code>Plug’n’Play</code>（Plug'n'Play = Plug and Play = PnP，即插即用）。</p>
  <h2 data-id="heading-117">抛弃 node_modules</h2>
  <p>无论是 <code>npm</code> 还是 <code>yarn</code>，都具备缓存的功能，大多数情况下安装依赖时，其实是将缓存中的相关包复制到项目目录中 <code>node_modules</code> 里。</p>
  <p>而 <code>yarn PnP</code> 则不会进行拷贝这一步，而是在项目里维护一张静态映射表 <code>pnp.cjs</code>。</p>
  <hr>
  <h1 data-id="heading-118">npm install 发生了啥</h1>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dd9dca6498df4e52a42c9d609a6528d4~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <hr>
  <h1 data-id="heading-119">使用 history 模式的前端路由时静态资源服务器配置详解</h1>
  <p>我们一般都是打包以后放在<strong>静态资源服务器</strong>中的，我们访问诸如 <code>example.com/rootpath/</code> 这种形式的资源没问题，是因为，<code>index.html</code> 文件是真实的存在于 <code>rootpath</code> 文件夹中的，可以找到的，返回给前端的。</p>
  <p>但是如果访问<strong>子路由</strong> <code>example.com/rootpath/login</code> 进行登录操作，但是 <code>login/index.html</code> 文件<strong>并非真实存在的文件</strong>，其实我们需要的文件还是 <code>rootpath</code> 目录中的 <code>index.html</code> 。</p>
  <p>再者，如果我们需要 <code>js</code> 文件，比如登陆的时候请求的地址是 <code>example.com/rootpath/login/js/dist.js</code> 其实我们想要的文件，还是 <code>rootpath/js/</code> 目录中的 <code>dist.js</code> 文件而已。</p>
  <blockquote>
    <p>前端路由其实是一种假象，只是用来蒙蔽使用者而已的，无论用什么路由，<span>访问的都是同一套静态资源</span>。</p>
  </blockquote>
  <p>之所以展示的内容不同，只是因为代码里，<span>根据不同的路由，对要显示的视图做了处理而已</span>。</p>
  <p>比如</p>
  <ul>
    <li>要找 <code>example.com/rootpath/login</code> 静态资源服务器找不到，那就返回 <code>example.com/rootpath/</code> 内容；</li>
    <li>要找 <code>example.com/rootpath/login/css/style.css</code> 找不到，那就照着 <code>example.com/rootpath/css/style.css</code> 这个路径去找。</li>
  </ul>
  <blockquote>
    <p>总之就是，请求的是子目录，找不到，那就<strong>返回根目录一级对应的资源文件</strong>就好了。</p>
  </blockquote>
  <h2 data-id="heading-120">在 nginx 中使用</h2>
  <p>如果你打包以后的前端静态资源文件，想要仍在 <code>nginx</code> 中使用，那首先将你打包好的静态资源目录<strong>扔进 <code>www</code> 目录</strong>，比如你打包好的资源的目录叫 <code>rootpath</code> ，那么直接将 <code>rootpath</code> 整个目录丢进 <code>www</code> 目录即可。</p>
  <p>然后打开我们的 <code>nginx</code> 配置文件 <code>nginx.conf</code>，插入以下配置：</p>
  <pre><code class="hljs language-bash copyable" lang="bash">location /rootpath/ {
    root   html;
    index  index.html index.htm;
    try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /rootpath/index.html;
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <ol>
    <li><code>root</code> 的作用
      <ul>
        <li>就是指定一个根目录。默认的是<code>html目录</code></li>
      </ul>
    </li>
    <li><code>try_files</code>
      <ul>
        <li>关键点1：按指定的<code>file</code>顺序查找存在的文件，并使用第一个找到的文件进行请求处理</li>
        <li>关键点2：查找路径是按照给定的<code>root</code>或<code>alias</code>为根路径来查找的</li>
        <li>关键点3：如果给出的<code>file</code>都没有匹配到，则重新请求最后一个参数给定的<code>uri</code>，就是新的<code>location</code>匹配</li>
      </ul>
    </li>
  </ol>
  <hr>
  <h1 data-id="heading-121">webpack 优化</h1>
  <h2 data-id="heading-122">时间方向(8个)</h2>
  <ol>
    <li>开发环境 - <code>EvalSourceMapDevToolPlugin</code><strong>排除第三方模块</strong>
      <ul>
        <li><code>devtool:false</code></li>
        <li><code>EvalSourceMapDevToolPlugin</code>,通过传入 <code>module: true</code> 和 <code>column:false</code>,达到和预设 <code>eval-cheap-module-source-map</code> 一样的质量</li>
      </ul>
    </li>
    <li>缩小<code>loader</code>的搜索范围：<code>test、include、exclude</code></li>
    <li><strong><code>Module.noParse</code></strong>
      <ul>
        <li><code>noParse: /jquery|lodash/</code>,</li>
      </ul>
    </li>
    <li><code>TypeScript</code> 编译优化</li>
    <li><strong><code>Resolve.modules</code>指定查找模块的目录范围</strong></li>
    <li><strong><code>Resolve.alias</code></strong></li>
    <li><strong><code>Resolve.extensions</code>指定查找模块的文件类型范围</strong></li>
    <li><code>HappyPack</code></li>
  </ol>
  <h2 data-id="heading-123">资源大小（9个）</h2>
  <ol>
    <li>按需引入类库模块  (工具类库)
      <ul>
        <li>使用<code>babel-plugin-import</code>对其处理</li>
      </ul>
    </li>
    <li><strong>使用<code>externals</code>优化<code>cdn</code>静态资源</strong></li>
    <li><strong>CSS抽离+剔除无用样式</strong>  -<code>MiniCssExtractPlugin</code> + <code>PurgeCSS</code></li>
    <li><strong>CSS压缩</strong>  - <code>CssMinimizerWebpackPlugin</code></li>
    <li><strong><code>TreeSharking</code></strong>
      <ul>
        <li>CSS 方向 - <code>glob-all</code> <code>purify-css</code> <code>purifycss-webpack</code></li>
        <li>JS方向  - <code>babel-loader</code>版本问题</li>
      </ul>
    </li>
    <li><code>Code Spilt</code> - <code>optimization</code> - <code>splitChunks</code> - <code>chunks:all</code></li>
    <li><strong>魔法注释 - <code>webpackChunkName：’xxx‘</code></strong></li>
    <li><code>Scope Hoisting</code> - <code>optimization</code> - <code>concatenateModules:true</code>
      <ul>
        <li>普通打包只是将一个模块最终放入一个单独的函数中,如果模块很多，就意味着在输出结果中会有很多的模块函数。concatenateModules 配置的作用,尽可能将所有模块合并到一起输出到一个函数中，既提升了运行效率，又减少了代码的体积。</li>
      </ul>
    </li>
    <li><strong>图片压缩</strong> -  <code>image-webpack-loader</code> - 只要在 <code>file-loader</code> 之后加入 <code>image-webpack-loader</code> 即可</li>
  </ol>
  <h2 data-id="heading-124">共同方案</h2>
  <ol>
    <li><code>IgnorePlugin</code></li>
  </ol>
  <hr>
  <h1 data-id="heading-125">Redux内部实现</h1>
  <h2 data-id="heading-126">createStore</h2>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createStore</span>(<span class="hljs-params">
    reducer,
    preloadedState,
    enhancer
    </span>){
  <span class="hljs-keyword">let</span> state;

  <span class="hljs-comment">//  用于存放被 subscribe 订阅的函数（监听函数）</span>
  <span class="hljs-keyword">let</span> listeners = [];

  <span class="hljs-comment">// getState 是一个很简单的函数</span>
  <span class="hljs-keyword">const</span> <span class="hljs-title function_">getState</span> = (<span class="hljs-params"></span>) =&gt; state;

  <span class="hljs-keyword">return</span> {
    dispatch,
    getState,
    subscribe,
    replaceReducer
  }
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <h2 data-id="heading-127">dispatch</h2>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">action</span>) {
  <span class="hljs-comment">// 通过 reducer 返回新的 state</span>
  <span class="hljs-comment">// 这个 reducer 就是 createStore 函数的第一个参数</span>
  state = <span class="hljs-title function_">reducer</span>(state, action);
  <span class="hljs-comment">// 每一次状态更新后，都需要调用 listeners 数组中的每一个监听函数</span>
  listeners.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">listener</span> =&gt;</span> <span class="hljs-title function_">listener</span>());
  <span class="hljs-keyword">return</span> action;    <span class="hljs-comment">// 返回 action</span>
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <h2 data-id="heading-128">subscribe</h2>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">subscribe</span>(<span class="hljs-params">listener</span>){
  listeners.<span class="hljs-title function_">push</span>(listener);
  <span class="hljs-comment">// 函数取消订阅函数</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> {
    listeners = listeners.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn !== listener);
  }
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <h2 data-id="heading-129">combineReducers</h2>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">combineReducers</span>(<span class="hljs-params">reducers</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">state = {},action</span>) =&gt;</span> {
        <span class="hljs-comment">// 返回的是一个对象，reducer 就是返回的对象</span>
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(reducers).<span class="hljs-title function_">reduce</span>(
            <span class="hljs-function">(<span class="hljs-params">accum,currentKey</span>) =&gt;</span> {
                accum[currentKey] = reducers[currentKey](state[currentKey],action);
                <span class="hljs-keyword">return</span> accum;
            },{}        <span class="hljs-comment">// accum 初始值是空对象</span>
        );
    }
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <h2 data-id="heading-130">applyMiddleware</h2>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyMiddleware</span>(<span class="hljs-params">...middlewares</span>){
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">createStore</span>){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">reducer,initialState</span>){
      <span class="hljs-keyword">var</span> store = <span class="hljs-title function_">createStore</span>(reducer,initialState);
      <span class="hljs-keyword">var</span> dispatch = store.<span class="hljs-property">dispatch</span>;
      <span class="hljs-keyword">var</span> chain = [];

      <span class="hljs-keyword">var</span> middlewareAPI = {
        <span class="hljs-attr">getState</span>: store.<span class="hljs-property">getState</span>,
        <span class="hljs-attr">dispatch</span>: <span class="hljs-function">(<span class="hljs-params">action</span>) =&gt;</span> <span class="hljs-title function_">dispatch</span>(action)
      };

      chain = middlewares.<span class="hljs-title function_">map</span>(
          <span class="hljs-function"><span class="hljs-params">middleware</span> =&gt;</span> <span class="hljs-title function_">middleware</span>(middlewareAPI)
          );

      dispatch = <span class="hljs-title function_">compose</span>(...chain)(store.<span class="hljs-property">dispatch</span>);
      <span class="hljs-keyword">return</span> { ...store, dispatch };
    }
  }
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <p><code>applyMiddleware</code> 函数是一个三级柯里化函数</p>
  <hr>
  <h1 data-id="heading-131">Vue和 React的区别</h1>
  <h2 data-id="heading-132">共同点</h2>
  <ol>
    <li>数据驱动视图</li>
    <li>组件化</li>
    <li>都使用 <code>Virtual DOM</code></li>
  </ol>
  <h2 data-id="heading-133">不同点</h2>
  <ol>
    <li>核心思想
      <ul>
        <li><code>Vue</code>灵活易用的渐进式框架，进行<strong>数据拦截/代理</strong>，它对侦测数据的变化更敏感、更精确</li>
        <li><code>React</code>推崇<strong>函数式编程</strong>（纯组件），<strong>数据不可变以及单向数据流</strong></li>
      </ul>
    </li>
    <li>组件写法差异
      <ul>
        <li><code>React</code>推荐的做法是<code>JSX + inline style</code>, 也就是把 <code>HTML</code> 和 <code>CSS</code> 全都写进 JavaScript 中,即 <code>all in js</code>;</li>
        <li><code>Vue</code> 推荐的做法是 <code>template</code> 的<strong>单文件组件格式</strong>即 <code>html</code>,<code>css</code>,<code>JS</code> 写在同一个文件</li>
      </ul>
    </li>
    <li><code>diff</code>算法不同
      <ul>
        <li>两者流程思路上是类似的：不同的组件产生不同的 DOM 结构。<strong>当type不相同时，对应DOM操作就是直接销毁老的DOM，创建新的DOM</strong>。 <strong>同一层次的一组子节点，可以通过唯一的 key 区分</strong>。</li>
        <li><code>Vue-Diff</code>算法采用了<strong>双端比较的算法</strong>，同时从新旧<code>children</code>的两端开始进行比较，借助<code>key</code>值找到可复用的节点，再进行相关操作。相比<code>React</code>的<code>Diff</code>算法，同样情况下可以减少移动节点次数，减少不必要的性能损耗，更加的优雅。</li>
      </ul>
    </li>
    <li>响应式原理不同
      <ul>
        <li><code>Vue</code> 依赖收集，自动优化，<strong>数据可变</strong>, 当数据改变时，自动找到引用组件重新渲染</li>
        <li><code>React</code>基于<strong>状态机</strong>，手动优化，<strong>数据不可变</strong>，需要<code>setState</code>驱动新的<code>state</code>替换老的<code>state</code>。 当数据改变时，以组件为根目录，默认全部重新渲染。</li>
      </ul>
    </li>
  </ol>
  <hr>
  <h1 data-id="heading-134">Webpack有哪些常用的loader和plugin</h1>
  <h2 data-id="heading-135">Webpack Loader vs Plugin</h2>
  <ul>
    <li><code>loader</code> 是<strong>文件加载器</strong>，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中</li>
    <li><code>plugin</code> 赋予了 <code>webpack</code> 各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是<strong>解决 loader 无法实现的其他事</strong></li>
  </ul>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2a9d4af5a00143a189f1964ec5af4dd1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <ul>
    <li><code>loader</code> 运行在<strong>打包文件之前</strong></li>
    <li><code>plugins</code> 在整个编译周期都起作用</li>
  </ul>
  <h2 data-id="heading-136">常用loader</h2>
  <ul>
    <li>样式：<code>style-loader</code>、<code>css-loader</code>、<code>less-loader</code>、<code>sass-loader</code>、<code>MiniCssExtractPlugin</code> + <code>PurgeCSS</code> + <code>CssMinimizerWebpackPlugin</code></li>
    <li>js: <code>bable-loader</code>/<code>ts-loader</code></li>
    <li>图片：<code>url-loader</code>（<code>limit</code>）、<code>file-loader</code> 、<code>image-webpack-loader</code></li>
    <li>代码校验：<code>eslint-loader</code></li>
  </ul>
  <h2 data-id="heading-137">常用plugin</h2>
  <ol>
    <li><code>HtmlWebpackPlugin</code>：会在打包结束之后自动创建一个<code>index.html</code>, 并将打包好的JS自动引入到这个文件中</li>
    <li><code>MiniCssExtractPlugin</code></li>
    <li><code>IgnorePlugin</code>：用于<strong>忽略第三方包</strong>指定目录，让指定目录不被打包进去</li>
    <li><code>terser-webpack-plugin</code>：压缩js代码</li>
    <li><code>SplitChunksPlugin</code>：<code>Code-Splitting</code>实现的底层就是通过Split-Chunks-Plugin实现的，其作用就是代码分割。</li>
  </ol>
  <hr>
  <h1 data-id="heading-138">Babel</h1>
  <p><code>Babel</code> 是一个 <code>JavaScript</code> 编译器！</p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba7ef757dea247ffa6630ab5758fcbc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <blockquote>
    <p><code>Babel</code> 的作用就是将<strong>源码</strong>转换为<strong>目标代码</strong></p>
  </blockquote>
  <h2 data-id="heading-139">Babel的作用</h2>
  <p>主要用于将采用 <code>ECMAScript 2015+</code> 语法编写的代码转换为 <code>es5</code> 语法，让开发者<span>无视用户浏览器的差异性</span>，并且能够用<strong>新的 JS 语法</strong>及<strong>特性</strong>进行开发。除此之外，<code>Babel</code> 能够转换 <code>JSX</code> 语法，并且能够支持 <code>TypeScript</code> 转换为 <code>JavaScript</code>。</p>
  <blockquote>
    <p>总结一下：<code>Babel</code> 的作用如下</p>
    <ol>
      <li>语法转换</li>
      <li>通过 <code>Polyfill</code> 方式在目标环境中<strong>添加缺失的特性</strong></li>
      <li>源码转换</li>
    </ol>
  </blockquote>
  <h2 data-id="heading-140">原理</h2>
  <p><code>Babel</code> 的运行原理可以通过以下这张图来概括。整体来看，可以分为三个过程，分别是：</p>
  <ol>
    <li>解析，
      <ol>
        <li>词法解析</li>
        <li>语法解析</li>
      </ol>
    </li>
    <li>转换，</li>
    <li>生成。</li>
  </ol>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/822560fe3587410aa301048a1ce3c00c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <hr>
  <h2 data-id="heading-141">Babel7 的使用</h2>
  <p><code>Babel</code> 支持多种形式的配置文件，根据使用场景不同可以选择不同的配置文件。</p>
  <ul>
    <li>如果配置中需要<strong>书写 js 逻辑</strong>，可以选择<strong>babel.config.js</strong>或者 <strong>.babelrc.js</strong>；</li>
    <li>如果只是需要一个简单的 <code>key-value</code> 配置，那么可以选择<code>.babelrc</code>，甚至可以直接在 <strong>package.json</strong> 中配置。</li>
  </ul>
  <p>所有 <code>Babel</code> 的包都发布在 <code>npm</code> 上，并且名称以 <code>@babel</code> 为前缀（自从版本 7.0 之后）,接下来，我们一起看下 <code>@babel/core</code> 和 <code>@babel/cli</code> 这两个 <code>npm</code> 包。</p>
  <ul>
    <li><code>@babel/core</code> - 核心库，封装了 <code>Babel</code> 的核心能力</li>
    <li><code>@babel/cli</code> - 命令行工具， 提供了 <code>babel</code> 这个命令</li>
  </ul>
  <blockquote>
    <p><code>Babel</code> 构建在插件之上的。默认情况下，<code>Babel</code> 不做任何处理，需要<span>借助插件来完成语法的解析，转换，输出</span>。</p>
  </blockquote>
  <p>插件的<strong>配置形式</strong>常见有两种，分别是</p>
  <ol>
    <li>字符串格式</li>
    <li>数组格式，并且可以<strong>传递参数</strong></li>
  </ol>
  <p>如果插件名称为 <code>@babel/plugin-XXX</code>，可以使用简写成<code>@babel/XXX</code>，</p>
  <ul>
    <li>例如 <code>@babel/plugin-transform-arrow-functions</code> 便可以简写成 <code>@babel/transform-arrow-functions</code>。</li>
  </ul>
  <blockquote>
    <p>插件的执行顺序是<span>从前往后</span>。</p>
  </blockquote>
  <pre><code class="hljs language-ruby copyable" lang="ruby">/<span class="hljs-regexp">/ .babelrc
/</span>*
* 以下三个插件的执行顺序是：
    <span class="hljs-variable">@babel</span>/proposal-<span class="hljs-keyword">class</span>-properties -&gt;
    <span class="hljs-variable">@babel</span>/syntax-dynamic-import -&gt;
    <span class="hljs-variable">@babel</span>/plugin-transform-arrow-functions
*<span class="hljs-regexp">/
{
    "plugins": [
        /</span><span class="hljs-regexp">/ 同 "@babel/plugin</span>-proposal-<span class="hljs-keyword">class</span>-properties<span class="hljs-string">"
        "</span><span class="hljs-variable">@babel</span>/proposal-<span class="hljs-keyword">class</span>-properties<span class="hljs-string">",
        // 同 ["</span><span class="hljs-variable">@babel</span>/plugin-syntax-dynamic-import<span class="hljs-string">"]
        ["</span><span class="hljs-variable">@babel</span>/syntax-dynamic-import<span class="hljs-string">"],
        [
            "</span><span class="hljs-variable">@babel</span>/plugin-transform-arrow-functions<span class="hljs-string">",
            {
                "</span>loose<span class="hljs-string">": true
            }
        ]
    ]
}

</span><span class="copy-code-btn">复制代码</span></code></pre>
  <h3 data-id="heading-142">预设</h3>
  <blockquote>
    <p>预设是一组<span>插件的集合</span>。</p>
  </blockquote>
  <p>与插件类似，预设的配置形式也是<strong>字符串</strong>和<strong>数组</strong>两种，预设也可以将 <code>@babel/preset-XXX</code> 简写为 <code>@babel/XXX</code> 。</p>
  <blockquote>
    <p>预设的执行顺序是<span>从后往前</span>，并且<strong>插件在预设之前执行</strong>。</p>
  </blockquote>
  <p>我们常见的预设有以下几种：</p>
  <ul>
    <li><code>@babel/preset-env</code>： 可以<strong>无视浏览器环境的差异</strong>而尽情地使用 ES6+ 新语法和新特性；
      <ul>
        <li>注：语法和特性不是一回事，语法上的迭代是让我们书写代码更加简单和方便，如展开运算符、类，结构等，因此这些语法称为语法糖；特性上的迭代是为了扩展语言的能力，如 <code>Map</code>、<code>Promise</code> 等，</li>
        <li>事实上，<code>Babel</code> 对新语法和新特性的处理也是不一样的，<span>对于新语法，Babel 通过插件直接转换，而对于新特性，Babel 还需要借助 polyfill 来处理和转换</span>。</li>
      </ul>
    </li>
    <li><code>@babe/preset-react</code>： 可以书写 <code>JSX</code> 语法，将 <code>JSX</code> 语法转换为 <code>JS</code> 语法；</li>
    <li><code>@babel/preset-typescript</code>：可以使用 <code>TypeScript</code> 编写程序，将 <code>TS</code> 转换为 <code>JS</code>；
      <ul>
        <li>注：<strong>该预设只是将 TS 转为 JS，不做任何类型检查</strong></li>
      </ul>
    </li>
    <li><code>@babel/preset-flow</code>：可以使用 <code>Flow</code> 来控制类型，将 <code>Flow</code> 转换为 <code>JS</code>；</li>
  </ul>
  <pre><code class="hljs language-json copyable" lang="json"><span class="hljs-comment">// .babelrc</span>
<span class="hljs-comment">/*
*  预设的执行顺序为：
    @babel/preset-react -&gt;
    @babel/preset-typescript -&gt;
    @babel/preset-env
*/</span>
<span class="hljs-punctuation">{</span>
    <span class="hljs-attr">"presets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
        <span class="hljs-punctuation">[</span>
            <span class="hljs-string">"@babel/preset-env"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"useBuiltIns"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"usage"</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"corejs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
                    <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span>
                    <span class="hljs-attr">"proposals"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-comment">// 使用尚在提议阶段特性的 polyfill</span>
                <span class="hljs-punctuation">}</span>
            <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span>
        <span class="hljs-string">"@babel/preset-typescript"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-comment">// 同 @babel/preset-react</span>
        <span class="hljs-string">"@babel/react"</span>
    <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>对于 <code>@babel/preset-env</code> ，我们通常需要设置目标浏览器环境，可以在根目录下的 <code>.browserslistrc</code> 文件中设置，也可以在该预设的参数选项中通过 <code>targets</code>(<strong>优先级最高</strong>) 或者在 <code>package.json</code> 中通过 <code>browserslist</code> 设置。</p>
  <p>如果我们不设置的话，该预设默认会将所有的 ES6+ 的<strong>新语法</strong>全部做转换，否则，该预设只会对目标浏览器环境<strong>不兼容的新语法做转换</strong>。</p>
  <blockquote>
    <p>推荐设置目标浏览器环境，这样在中大型项目中可以明显缩小编译后的代码体积，因为<strong>有些新语法的转换需要引入一些额外定义的 helper 函数的，比如 class</strong>。</p>
  </blockquote>
  <h4 data-id="heading-143">.babelrc</h4>
  <pre><code class="hljs language-perl copyable" lang="perl">{
    <span class="hljs-string">"presets"</span>: [
        [
            <span class="hljs-string">"@babel/preset-env"</span>,
            {
                <span class="hljs-string">"targets"</span>: <span class="hljs-string">"&gt; 0.25%, not dead"</span>
            }
        ]
    ]
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <h4 data-id="heading-144">.browserslistrc</h4>
  <pre><code class="hljs language-markdown copyable" lang="markdown">
<span class="hljs-quote">&gt; 0.25%</span>
not dead
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>对于新特性，<code>@babel/preset-env</code> 也是能转换的。但是需要通过 <code>useBuiltIns</code> 这个参数选项实现，值需要设置为 <code>usage</code>，这样的话，只会转换我们使用到的<strong>新语法和新特性</strong>，能够有效减小编译后的包体积，并且还要设置 <code>corejs: { version: 3, proposals }</code> 选项，因为转换新特性需要用到 <code>polyfill</code>，而 <code>corejs</code> 就是一个 <code>polyfill</code> 包。如果不显示指定 <code>corejs</code> 的版本的话，默认使用的是 <code>version 2</code> ，而 version 2 已经停更，诸如一些更新的特性的 <code>polyfill</code> 只会更行与 <code>version 3</code> 里，如 <code>Array.prototype.flat()</code>。</p>
  <pre><code class="hljs language-json copyable" lang="json"><span class="hljs-comment">// .babelrc</span>
<span class="hljs-attr">"presets"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-punctuation">[</span>
        <span class="hljs-string">"@babel/preset-env"</span><span class="hljs-punctuation">,</span>
        <span class="hljs-punctuation">{</span>
            <span class="hljs-attr">"useBuiltIns"</span><span class="hljs-punctuation">:</span> <span class="hljs-string">"usage"</span><span class="hljs-punctuation">,</span>
            <span class="hljs-attr">"corejs"</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span>
                <span class="hljs-attr">"version"</span><span class="hljs-punctuation">:</span> <span class="hljs-number">3</span><span class="hljs-punctuation">,</span>
                <span class="hljs-attr">"proposals"</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-comment">// 使用尚在提议阶段特性的 polyfill</span>
            <span class="hljs-punctuation">}</span>
        <span class="hljs-punctuation">}</span>
    <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">]</span>

<span class="copy-code-btn">复制代码</span></code></pre>
  <p>虽然 <code>@babel/env</code> 可以帮我们做新语法和新特性的<strong>按需转换</strong>，但是依然存在 2 个问题：</p>
  <ol>
    <li>从 <code>corejs</code> 引入的 <code>polyfill</code> 是<strong>全局范围</strong>的，不是模块作用域返回的，可能存在污染全局变量的风险；</li>
    <li>对于某些新语法，如 <code>class</code>，会在编译后的文件中注入很多 <code>helper</code> 函数声明，而不是从某个地方 <code>require</code> 进来的函数引用，从而增大编译后的包体积；</li>
  </ol>
  <hr>
  <h3 data-id="heading-145">runtime</h3>
  <p><code>runtime</code> 是 <code>babel7</code> 提出来的概念，旨在解决如上提出的性能问题的。</p>
  <p>实践一下 <code>@babel/plugin-transform-runtime</code> 插件配合 <code>@babel/preset-env</code> 使用</p>
  <pre><code class="hljs language-bash copyable" lang="bash">npm install --save-dev @babel/plugin-transform-runtime
// @babel/runtime 是要安装到生产依赖的，因为新特性的编译需要从这个包里引用 polyfill
// 它就是一个封装了 corejs 的 polyfill 包
npm install --save @babel/runtime
<span class="copy-code-btn">复制代码</span></code></pre>
  <pre><code class="hljs language-perl copyable" lang="perl">// .babelrc
{
  <span class="hljs-string">"presets"</span>: [
    <span class="hljs-string">"@babel/env"</span>
  ],
  <span class="hljs-string">"plugins"</span>: [
    [
      <span class="hljs-string">"@babel/plugin-transform-runtime"</span>,{
          <span class="hljs-string">"corejs"</span>: <span class="hljs-number">3</span>
      }
    ]
  ],
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>编译后，可以明显看到，</p>
  <ul>
    <li>引入的 <code>polyfill</code> 不再是全局范围内的了，而是模块作用域范围内的；</li>
    <li>并且不再是往编译文件中直接注入 <code>helper</code> 函数了，而是通过引用的方式，</li>
  </ul>
  <p>既解决了全局变量污染的问题，又减小了编译后包的体积</p>
  <hr>
  <h1 data-id="heading-146">Fiber 实现时间切片的原理</h1>
  <h2 data-id="heading-147">React15  架构缺点</h2>
  <p><code>React16之前</code>的版本比对<span>更新虚拟DOM的过程是采用循环递归方式来实现的</span>，这种比对方式有一个问题，就是一旦任务开始进行就<strong>无法中断</strong>，如果应用中数组数量庞大，<span>主线程被长期占用</span>，直到整颗虚拟DOM树比对更新完成之后主线程才被释放，主线程才能执行其他任务，这就会<strong>导致一些用户交互或动画等任务无法立即得到执行，页面就会产生卡顿，非常的影响用户体验</strong>。</p>
  <p>主要原因就是<span>递归无法中断</span>，执行重的任务耗时较长，<code>javascript</code>又是单线程的，无法同时执行其他任务，导致任务延迟页面卡顿用户体验差。</p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b1d3f2d692f3413faeb50cdf7653e78d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <hr>
  <h2 data-id="heading-148">Fiber架构</h2>
  <p>界面通过 <code>vdom</code> 描述，但是不是直接手写 <code>vdom</code>，而是 <code>jsx</code> 编译产生的 <code>render</code> function 之后以后生成的。这样就可以加上 <code>state</code>、<code>props</code> 和一些<strong>动态逻辑</strong>，动态产生 <code>vdom</code>。</p>
  <blockquote>
    <p><code>vdom</code> 生成之后<span>不再是直接渲染，而是先转成 fiber</span>，这个 <code>vdom</code> 转 <code>fiber</code> 的过程叫做 <code>reconcile</code>。</p>
  </blockquote>
  <p><code>fiber</code> 是一个<span>链表结构</span>，可以打断，这样就可以通过 <code>requestIdleCallback</code> 来空闲调度 <code>reconcile</code>，这样不断的循环，直到处理完所有的 <code>vdom</code> 转 <code>fiber</code> 的 <code>reconcile</code>，就开始 <code>commit</code>，也就是更新到 <code>dom</code>。</p>
  <p><code>reconcile</code> 的过程会提前创建好 <code>dom</code>，还会<strong>标记出增删改</strong>，那么 <code>commit</code> 阶段就很快了。</p>
  <blockquote>
    <p><span>从之前递归渲染时做 <code>diff</code> 来确定增删改以及创建 <code>dom</code>，提前到了可打断的 <code>reconcile</code> 阶段，让 <code>commit</code> 变得非常快，这就是 <code>fiber</code> 架构的目的和意义。</span></p>
  </blockquote>
  <h3 data-id="heading-149">并发&amp;调度(Concurrency &amp; Scheduler)</h3>
  <ul>
    <li><code>Concurrency</code> 并发:  <strong>有能力优先处理更高优事务</strong>，同时对正在执行的中途任务可暂存，待高优完成后，再去执行。</li>
    <li><code>Scheduler</code> 协调调度: 暂存未执行任务，等待时机成熟后，再去<strong>安排执行剩下未完成任务</strong>。</li>
  </ul>
  <p>考虑到可中断渲染，并可重回构造。<code>React</code>自行实现了一套体系叫做 <code>React fiber</code> 架构。</p>
  <blockquote>
    <p><code>React Fiber</code> 核心: <span>自行实现 虚拟栈帧</span>。</p>
  </blockquote>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/22d448ada65d4c42895d5b362dbba972~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <blockquote>
    <p>schedule 就是通过<strong>空闲调度</strong>每个 <code>fiber</code> 节点的 <code>reconcile</code>（<code>vdom</code> 转 <code>fiber</code>），全部 <code>reconcile</code> 完了就执行 <code>commit</code>。</p>
  </blockquote>
  <p><code>Fiber</code>的数据结构有三层信息: （<strong>采用链表结构</strong>）</p>
  <ol>
    <li>实例属性
      <ul>
        <li>该Fiber的基本信息，例如组件类型等。</li>
      </ul>
    </li>
    <li>构建属性
      <ul>
        <li>构建属性 (<code>return</code>、<code>child</code>、<code>sibling</code>)</li>
      </ul>
    </li>
    <li>工作属性
      <ul>
        <li>数据的变更会导致UI层的变更</li>
        <li>为了减少对<code>DOM</code>的直接操作，通过<code>Reconcile</code>进行<code>diff</code>查找，并将需要变更节点，打上标签，<strong>变更路径保留在<code>effectList</code>里</strong></li>
        <li><strong>待变更内容要有<code>Scheduler</code>优先级处理</strong></li>
        <li>涉及到<code>diff</code>等查找操作，是需要有个高效手段来处理前后变化，即<strong>双缓存机制</strong>。</li>
      </ul>
    </li>
  </ol>
  <blockquote>
    <p>链表结构即可<strong>支持随时随时中断</strong>的诉求</p>
  </blockquote>
  <h3 data-id="heading-150">Scheduler 运行核心点</h3>
  <ol>
    <li>有个任务队列 <code>queue</code>，该<strong>队列存放可中断的任务</strong>。</li>
    <li><code>workLoop</code>对队列里取第一个任务<code>currentTask</code>，进入循环开始执行。
      <ul>
        <li>当该任务<strong>没有时间</strong> 或 需要中断 (渲染任务 或 其他高优任务插入等)，则让出主线程。</li>
      </ul>
    </li>
    <li><code>requestAnimationFrame</code> 计算一帧的空余时间；</li>
    <li>使用<code>new MessageChannel ()</code> 执行宏任务;</li>
  </ol>
  <hr>
  <h1 data-id="heading-151">devServer进行跨域处理</h1>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">devServer</span>: {
        <span class="hljs-comment">/* 运行代码的目录 */</span>
        <span class="hljs-attr">contentBase</span>: <span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">"dist"</span>),
        <span class="hljs-comment">/* 监视 contentBase 目录下的所有文件,一旦文件发生变化就会 reload (重载+刷新浏览器)*/</span>
        <span class="hljs-attr">watchContentBase</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-comment">/* 监视文件时 配合 watchContentBase */</span>
        <span class="hljs-attr">watchOptions</span>: {
            <span class="hljs-comment">/* 忽略掉的文件(不参与监视的文件) */</span>
            <span class="hljs-attr">ignored</span>: <span class="hljs-regexp">/node_modules/</span>
        },
        <span class="hljs-comment">/* 启动gzip压缩 */</span>
        <span class="hljs-attr">compress</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-comment">/* 运行服务时自动打开服务器 */</span>
        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-comment">/* 启动HMR热更新 */</span>
        <span class="hljs-attr">hot</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-comment">/* 启动的端口号 */</span>
        <span class="hljs-attr">port</span>: <span class="hljs-number">5000</span>,
        <span class="hljs-comment">/* 启动的IP地址或域名 */</span>
        <span class="hljs-attr">host</span>: <span class="hljs-string">"localhost"</span>,
        <span class="hljs-comment">/* 关闭服务器启动日志 */</span>
        <span class="hljs-attr">clientLogLevel</span>: <span class="hljs-string">"none"</span>,
        <span class="hljs-comment">/* 除了一些启动的基本信息,其他内容都不要打印 */</span>
        <span class="hljs-attr">quiet</span>: <span class="hljs-literal">true</span>,
        <span class="hljs-comment">/* 如果出错不要全屏提示 */</span>
        <span class="hljs-attr">overlay</span>: <span class="hljs-literal">false</span>,
        <span class="hljs-comment">/* 服务器代理 --&gt; 解决开发环境跨域问题 */</span>
        <span class="hljs-attr">proxy</span>: {
            <span class="hljs-comment">/* 一旦devServer(port:5000)服务器接收到 ^/api/xxx 的请求,就会把请求转发到另外一个服务器(target)上 */</span>
            <span class="hljs-string">"/api"</span>: {
                <span class="hljs-attr">target</span>: <span class="hljs-string">"http://localhost:3000"</span>,
                <span class="hljs-comment">/* 路径重写(代理时发送到target的请求去掉/api前缀) */</span>
                <span class="hljs-attr">pathRewrite</span>: {
                    <span class="hljs-string">"^/api"</span>: <span class="hljs-string">""</span>
                }
            }
        }
    },
}

<span class="copy-code-btn">复制代码</span></code></pre>
  <hr>
  <h1 data-id="heading-152">React 实现原理</h1>
  <h2 data-id="heading-153">React-Hook为什么不能放到条件语句中</h2>
  <blockquote>
    <p><span>每一次渲染都是完全独立的</span>。</p>
  </blockquote>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7ea1372f383941ac8a253267819e11a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>每次渲染具有独立的状态值（每次渲染都是完全独立的）。也就是说，<span>每个函数中的 <code>state</code> 变量只是一个简单的常量</span>，每次渲染时从钩子中获取到的常量，并没有附着数据绑定之类的神奇魔法。</p>
  <p>这也就是老生常谈的 <code>Capture Value</code> 特性。可以看下面这段经典的计数器代码</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleAlertClick</span>(<span class="hljs-params"></span>) {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">alert</span>(<span class="hljs-string">'You clicked on: '</span> + count);
    }, <span class="hljs-number">3000</span>);
  }

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>You clicked {count} times<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(count + 1)}&gt;
        Click me
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{handleAlertClick}</span>&gt;</span>
        Show alert
      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>按如下步骤操作：</p>
  <ul>
    <li>1）点击 <code>Click me</code> 按钮，把数字增加到 3；</li>
    <li>2）点击 <code>Show alert</code> 按钮；</li>
    <li>3）在 <code>setTimeout</code> 触发之前点击 <code>Click me</code>，把数字增加到 5。</li>
  </ul>
  <p>结果是 <code>Alert</code> 显示 3！</p>
  <p>来简单解释一下：</p>
  <ul>
    <li>每次<strong>渲染相互独立</strong>，因此<span>每次渲染时组件中的状态、事件处理函数等等都是独立的，或者说只属于所在的那一次渲染</span></li>
    <li>我们在 <code>count</code> 为 3 的时候触发了 <code>handleAlertClick</code> 函数，这个函数所记住的 <code>count</code> 也为 3</li>
    <li>三秒种后，刚才函数的 <code>setTimeout</code> 结束，输出当时记住的结果：3</li>
  </ul>
  <h2 data-id="heading-154">深入useState本质</h2>
  <h3 data-id="heading-155">当组件初次渲染（挂载）时</h3>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d031187a4592464599a78737d3f15da1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <ol>
    <li>在<strong>初次渲染</strong>时，我们通过 <code>useState</code> 定义了多个状态；</li>
    <li>每<strong>调用一次</strong> <code>useState</code> ，都会<strong>在组件之外生成一条 Hook 记录</strong>，同时包括状态值（用 <code>useState</code> 给定的初始值初始化）和修改状态的 <code>Setter</code> 函数；</li>
    <li><strong>多次调用</strong> <code>useState</code> 生成的 <code>Hook</code> 记录<strong>形成了一条链表</strong>；</li>
    <li>触发 <code>onClick</code> 回调函数，<strong>调用 <code>setS2</code> 函数修改 <code>s2</code> 的状态</strong>，不仅修改了 <code>Hook</code> 记录中的状态值，还即将<strong>触发重渲染</strong>。</li>
  </ol>
  <h3 data-id="heading-156">组件重渲染时</h3>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/53eef022f4f94a47a8c0958164d4e8c6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>在<span>初次渲染结束之后、重渲染之前</span>，<code>Hook</code> 记录链表依然存在。当我们<strong>逐个调用</strong> <code>useState</code> 的时候，<code>useState</code> 便<strong>返回了 <code>Hook</code> 链表中存储的状态</strong>，以及修改状态的 <code>Setter</code>。</p>
  <hr>
  <h2 data-id="heading-157">深入useEffect本质</h2>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/efe2295fa1d34660ad527081fa3d235f~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>注意其中一些细节：</p>
  <ul>
    <li><code>useState</code> 和 <code>useEffect</code> 在每次调用时都被添加到 <code>Hook</code> 链表中；</li>
    <li><code>useEffect</code> 还会<strong>额外</strong>地在一个队列中添加一个等待执行的 <code>Effect</code> 函数；</li>
    <li>在<strong>渲染完成后</strong>，依次调用 <code>Effect</code> 队列中的每一个 <code>Effect</code> 函数。</li>
  </ul>
  <p><code>React</code> 官方文档 <code>Rules of Hooks</code> 中强调过一点：</p>
  <blockquote>
    <p>Only call hooks at the top level. 只在最顶层使用 Hook。</p>
  </blockquote>
  <p>具体地说，不要在循环、嵌套、条件语句中使用 <code>Hook</code>——</p>
  <blockquote>
    <p>因为这些<span>动态的语句很有可能会导致每次执行组件函数时调用 Hook 的顺序不能完全一致，导致 Hook 链表记录的数据失效</span>。</p>
  </blockquote>
  <hr>
  <h2 data-id="heading-158">自定义Hook实现原理</h2>
  <h3 data-id="heading-159">组件初次渲染</h3>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/daab8683d74e49f09fa70366139e28ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>在 <code>App</code> 组件中调用了 <code>useCustomHook</code> 钩子。可以看到，即便我们切换到了<strong>自定义 Hook 中，Hook 链表的生成依旧没有改变</strong>。</p>
  <h3 data-id="heading-160">组件重新渲染</h3>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/26c5979d361f4f159610841d07947cf6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image">
    即便代码的执行进入到自定义 Hook 中，依然可以从 Hook 链表中读取到相应的数据，<strong>这个”配对“的过程总能成功</strong>。</p>
  <p>而<code>Rules of Hook</code>。它规定<strong>只有</strong>在两个地方能够使用 React Hook：</p>
  <ol>
    <li>React 函数组件</li>
    <li>自定义 Hook</li>
  </ol>
  <p>第一点毋庸置疑，第二点通过刚才的两个动画你也可以轻松的得出一个结论：</p>
  <blockquote>
    <p><strong>自定义 Hook 本质上只是把调用内置 Hook 的过程封装成一个个可以复用的函数，并不影响 Hook 链表的生成和读取</strong>。</p>
  </blockquote>
  <hr>
  <h2 data-id="heading-161">useCallback</h2>
  <blockquote>
    <p>依赖数组在判断元素是否发生改变时使用了 <code>Object.is</code> 进行比较，因此当 <code>deps</code> 中某一元素为<strong>非原始类型</strong>时（例如函数、对象等），每次渲染都会发生改变，从而每次都会触发 <code>Effect</code>，失去了 <code>deps</code> 本身的意义。</p>
  </blockquote>
  <h3 data-id="heading-162">Effect 无限循环</h3>
  <p>来看一下这段”永不停止“的计数器：</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">EndlessCounter</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">setCount</span>(count + <span class="hljs-number">1</span>), <span class="hljs-number">1000</span>);
  });

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">"App"</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>{count}<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>如果你去运行这段代码，会发现数字永远在增长。我们来通过一段动画来演示一下这个”无限循环“到底是怎么回事：
    <img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/77f89499d6eb4bbb9fbc31e333f9793c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image">
    组件陷入了：<strong>渲染 =&gt; 触发 Effect =&gt; 修改状态 =&gt; 触发重渲染</strong>的无限循环</p>
  <h3 data-id="heading-163">关于记忆化缓存（Memoization）</h3>
  <p><code>Memoization</code>，一般称为记忆化缓存（或者“记忆”），它背后的思想很简单：假如我们有一个计算量很大的纯函数（给定相同的输入，一定会得到相同的输出），那么我们在第一次遇到特定输入的时候，把它的输出结果“记”（缓存）下来，那么下次碰到同样的输出，只需要从缓存里面拿出来直接返回就可以了，省去了计算的过程！</p>
  <p>记忆化缓存（Memoization）的两个使用场景：</p>
  <ol>
    <li>通过缓存计算结果，节省费时的计算</li>
    <li>保证相同输入下<strong>返回值的引用相等</strong></li>
  </ol>
  <h3 data-id="heading-164">useCallback使用方法和原理解析</h3>
  <p>为了解决函数在多次渲染中的<strong>引用相等</strong>（Referential Equality）问题，<code>React</code> 引入了一个重要的 <code>Hook</code>—— <code>useCallback</code>。官方文档介绍的使用方法如下：</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> memoizedCallback = <span class="hljs-title function_">useCallback</span>(callback, deps);
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>第一个参数 <code>callback</code> 就是需要记忆的函数，第二个参数是<code>deps</code> 参数，同样也是一个<strong>依赖数组</strong>。在 <code>Memoization</code> 的上下文中，这个 <code>deps</code> 的作用相当于缓存中的键（Key），如果<strong>键没有改变，那么就直接返回缓存中的函数，并且确保是引用相同的函数</strong>。</p>
  <h4 data-id="heading-165">组件初次渲染(deps 为空数组的情况)</h4>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/40a847ccd9904f2e98b02932da78762e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p><strong>调用 <code>useCallback</code> 也是追加到 <code>Hook</code> 链表上</strong>，不过这里着重强调了这个函数 <code>f1</code> 所指向的<strong>内存位置</strong>，从而明确告诉我们：这个 <strong>f1 始终是指向同一个函数。然后返回的 onClick 则是指向 Hook 中存储的 f1</strong>。</p>
  <h4 data-id="heading-166">组件重新渲染</h4>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/039bae2e1b98466aadfabeaad8d46040~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <p>重渲染的时候，再次调用 <code>useCallback</code> 同样返回给我们 <code>f1</code> 函数，并且<strong>这个函数还是指向同一块内存，从而使得 onClick 函数和上次渲染时真正做到了引用相等</strong>。</p>
  <hr>
  <h2 data-id="heading-167">useCallback 和 useMemo 的关系</h2>
  <p>之前我们说<code>Memoization</code> 的两大场景</p>
  <ol>
    <li>通过缓存计算结果，节省费时的计算</li>
    <li>保证相同输入下<strong>返回值的引用相等</strong></li>
  </ol>
  <p>而<code>useCallback</code> 和<code>uesMemo</code>从<code>Memoization</code>角度来说</p>
  <ul>
    <li><code>useCallback</code> 主要是为了解决**函数的”引用相等“**问题，</li>
    <li><code>useMemo</code> 则是一个”全能型选手“，能够<strong>同时胜任引用相等和节约计算</strong>的任务。</li>
  </ul>
  <blockquote>
    <p>实际上，<code>useMemo</code> 的功能是 <code>useCallback</code> 的超集。</p>
  </blockquote>
  <p>与 <code>useCallback</code> 只能缓存函数相比，<code>useMemo</code> 可以缓存任何类型的值（当然也包括函数）。<code>useMemo</code> 的使用方法如下：</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">const</span> memoizedValue = <span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span>
    <span class="hljs-title function_">computeExpensiveValue</span>(a, b),
    [a, b]
);
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>其中第一个参数是一个函数，这个<strong>函数返回值的返回值</strong>（也就是上面 computeExpensiveValue 的结果）将返回给 <code>memoizedValue</code> 。</p>
  <p>因此以下两个钩子的使用是完全等价的：</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-title function_">useCallback</span>(fn, deps);
<span class="hljs-title function_">useMemo</span>(<span class="hljs-function">() =&gt;</span> fn, deps);
<span class="copy-code-btn">复制代码</span></code></pre>
  <hr>
  <h2 data-id="heading-168">useReducer</h2>
  <p>使用 <code>useState</code> 的时候遇到过一个问题：通过 <code>Setter</code> 修改状态的时候，怎么读取上一个状态值，并在此基础上修改呢？如果你看文档足够细致，应该会注意到 <code>useState</code> 有一个<span>{函数式更新|Functional Update}</span>的用法。</p>
  <pre><code class="hljs language-jsx copyable" lang="jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params">{initialCount}</span>) {
  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(initialCount);
  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;&gt;</span>
      Count: {count}
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(initialCount)}&gt;Reset<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(prevCount =&gt; prevCount - 1)}&gt;-<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setCount(prevCount =&gt; prevCount + 1)}&gt;+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/&gt;</span></span>
  );
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>传入 <code>setCount</code> 的是一个<strong>函数</strong>，它的<strong>参数是之前的状态，返回的是新的状态</strong>。熟悉 <code>Redux</code> 的朋友马上就指出来了：这其实就是一个 <code>Reducer</code> 函数。</p>
  <h3 data-id="heading-169">useState底层实现原理</h3>
  <p>在 <code>React</code> 的源码中，<code>useState</code> 的实现使用了 <code>useReducer</code>。在 <code>React</code> 源码中有这么一个关键的函数 <code>basicStateReducer</code></p>
  <pre><code class="hljs language-javascript copyable" lang="javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">basicStateReducer</span>(<span class="hljs-params">state, action</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> action === <span class="hljs-string">'function'</span> ? <span class="hljs-title function_">action</span>(state) : action;
}
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>于是，当我们通过 <code>setCount(prevCount =&gt; prevCount + 1)</code> 改变状态时，传入的 <code>action</code> 就是一个 <code>Reducer</code> 函数，然后调用该函数并传入当前的 <code>state</code>，得到更新后的状态。而我们之前通过<strong>传入具体的值修改状态时</strong>（例如 <code>setCount(5)</code>），由于不是函数，所以<strong>直接取传入的值作为更新后的状态</strong>。</p>
  <h4 data-id="heading-170">传入的 action 是一个具体的值 （setCount(xx)）</h4>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fa7eda4b26da4fab874b6bc96978e7cb~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <h4 data-id="heading-171">当传入 Setter 的是一个 Reducer 函数的时候：(setCount(c =&gt;c+1))</h4>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8c70ed11225144c9ada81606e100d341~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p>
  <hr>
  <h1 data-id="heading-172">后记</h1>
  <p><strong>分享是一种态度</strong>。</p>
  <p><strong>全文完，既然看到这里了，如果觉得不错，随手点个赞和“在看”吧。</strong></p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc034b4279c74625bfa91af96ecd0119~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" loading="lazy" class="medium-zoom-image"></p></div>
