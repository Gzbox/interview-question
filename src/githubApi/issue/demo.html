<div class="markdown-body cache html"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#333}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;margin-bottom:5px}.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{font-size:20px}.markdown-body h2{padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:18px;padding-bottom:0}.markdown-body h6{margin-top:5px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><p>本文来自<a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Fxin-tan.com%2Fpassages%2F2019-10-21-react-hooks%2F" title="https://xin-tan.com/passages/2019-10-21-react-hooks/" ref="nofollow noopener noreferrer">《一文彻底搞懂react hooks的原理和实现》</a>，如果觉得不错，欢迎给<a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fdongyuanxin%2Fblog" title="https://github.com/dongyuanxin/blog" ref="nofollow noopener noreferrer">Github仓库</a>一个star。</p>
  <h2 data-id="heading-0">摘要</h2>
  <p>当使用 Hook 特性编写组件的时候时候，总能感觉到它的简洁和方便。当然，「天下没有免费的午餐」，它牺牲了可读性并且存在内存泄漏风险（最后有提到）。但这并不妨碍探索它的魔力。</p>
  <p>在正式开始前，希望您读过 Hook 的文档或者在项目使用过它。但如果只对函数编程感兴趣，也可能有所收获。</p>
  <p>为了让行文更流畅，我打算先抛出几个问题，这些问题会在源码实现的过程中，逐步解决：</p>
  <ul>
    <li>🤔️ useState 的实现原理</li>
    <li>🤔️ 为什么不能在循环、判断内部使用 Hook</li>
    <li>🤔️ useEffect 的实现原理</li>
    <li>🤔️ useEffect 的应用场景</li>
    <li>🤔️ <code>Class</code> vs <code>Hooks</code></li>
  </ul>
  <p>⚠️ 代码均由<code>TypeScript</code>来实现，文中全部 demos 均在 <a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Fgist.github.com%2Fdongyuanxin%2F4281ee21eafdc0197d6ddea27bfbdbfd" title="https://gist.github.com/dongyuanxin/4281ee21eafdc0197d6ddea27bfbdbfd" ref="nofollow noopener noreferrer">gist.github.com/dongyuanxin…</a></p>
  <h2 data-id="heading-1">useState 的实现原理</h2>
  <p>当调用 useState 的时候，会返回形如 <code>(变量, 函数)</code> 的一个元祖。并且 state 的初始值就是外部调用 useState 的时候，传入的参数。</p>
  <p>理清楚了传参和返回值，再来看下 useState 还做了些什么。正如下面代码所示，当点击按钮的时候，执行<code>setNum</code>，状态 num 被更新，<strong>并且 UI 视图更新</strong>。显然，useState 返回的用于更改状态的函数，自动调用了<code>render</code>方法来触发视图更新。</p>
  <pre><code lang="javascript" class="hljs language-javascript copyable"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, setNum] = useState &lt; number &gt; <span class="hljs-number">0</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>num: {num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(num + 1)}&gt;加 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="copy-code-btn">复制代码</span></code></pre><p>有了上面的探索，借助闭包，封装一个 <code>setState</code> 如下：</p>
  <pre><code lang="javascript" class="hljs language-javascript copyable"><span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"root"</span>));
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">state</span>: any;

<span class="hljs-keyword">function</span> useState&lt;T&gt;(<span class="hljs-attr">initialState</span>: T): [T, <span class="hljs-function">(<span class="hljs-params">newState: T</span>) =&gt;</span> <span class="hljs-keyword">void</span>] {
  state = state || initialState;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">newState: T</span>) {
    state = newState;
    <span class="hljs-title function_">render</span>();
  }

  <span class="hljs-keyword">return</span> [state, setState];
}

<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 首次渲染</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>这是一个简易能用的<code>useState</code>雏形了。它也解决了文章开始提到的「🤔️ useState 的实现原理」这个问题。但如果在函数内声明多个 state，在当前代码中，只有第一个 state 是生效的(请看<code>state = state || initialState;</code>))。</p>
  <h2 data-id="heading-2">为什么不能在循环、判断内部使用 Hook</h2>
  <p>先不要考虑题目提及的问题。思路还是回到如何让 useState 支持多个 state。<a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40ryardley%2Freact-hooks-not-magic-just-arrays-cd4f1857236e" title="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" ref="nofollow noopener noreferrer">《React hooks: not magic, just arrays》</a>中提及，React Hook 看起来非常 Magic 的实现，本质上还是通过 Array 来实现的。</p>
  <p>前面 useState 的简单实现里，初始的状态是保存在一个全局变量中的。以此类推，多个状态，应该是保存在一个专门的全局容器中。这个容器，就是一个朴实无华的 Array 对象。具体过程如下：</p>
  <ul>
    <li>第一次渲染时候，根据 useState 顺序，逐个声明 state 并且将其放入全局 Array 中。每次声明 state，都要将 cursor 增加 1。</li>
    <li>更新 state，触发再次渲染的时候。<strong>cursor 被重置为 0</strong>。按照 useState 的声明顺序，依次拿出最新的 state 的值，视图更新。</li>
  </ul>
  <p>请看下面这张图，每次使用 useState，都会向 STATE 容器中添加新的状态。</p>
  <p></p><figure><img src="https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/22/16df33d45b7c0214~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp" loading="lazy" class="medium-zoom-image"><figcaption></figcaption></figure><p></p>
  <p>实现的代码如下：</p>
  <pre><code lang="typescript" class="hljs language-typescript copyable"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">states</span>: <span class="hljs-built_in">any</span>[] = [];
<span class="hljs-keyword">let</span> <span class="hljs-attr">cursor</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>;

<span class="hljs-keyword">function</span> useState&lt;T&gt;(<span class="hljs-attr">initialState</span>: T): [T, <span class="hljs-function">(<span class="hljs-params">newState: T</span>) =&gt;</span> <span class="hljs-built_in">void</span>] {
  <span class="hljs-keyword">const</span> currenCursor = cursor;
  states[currenCursor] = states[currenCursor] || initialState; <span class="hljs-comment">// 检查是否渲染过</span>

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">setState</span>(<span class="hljs-params">newState: T</span>) {
    states[currenCursor] = newState;
    <span class="hljs-title function_">render</span>();
  }

  ++cursor; <span class="hljs-comment">// update: cursor</span>
  <span class="hljs-keyword">return</span> [states[currenCursor], setState];
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, setNum] = useState &lt; <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> [num2, setNum2] = useState &lt; <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">1</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>num: {num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(num + 1)}&gt;加 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(num - 1)}&gt;减 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>num2: {num2}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum2(num2 * 2)}&gt;扩大一倍<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum2(num2 / 2)}&gt;缩小一倍<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"root"</span>));
  cursor = <span class="hljs-number">0</span>; <span class="hljs-comment">// 重置cursor</span>
}

<span class="hljs-title function_">render</span>(); <span class="hljs-comment">// 首次渲染</span>
<span class="copy-code-btn">复制代码</span></code></pre><p>此时，如果想在循环、判断等不在函数组件顶部的地方使用 Hook，如下所示：</p>
  <pre><code lang="typescript" class="hljs language-typescript copyable"><span class="hljs-keyword">let</span> tag = <span class="hljs-literal">true</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, setNum] = useState &lt; <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">0</span>;

  <span class="hljs-comment">// 只有初次渲染，才执行</span>
  <span class="hljs-keyword">if</span> (tag) {
    <span class="hljs-keyword">const</span> [unusedNum] = useState &lt; <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">1</span>;
    tag = <span class="hljs-literal">false</span>;
  }

  <span class="hljs-keyword">const</span> [num2, setNum2] = useState &lt; <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">2</span>;

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>num: {num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(num + 1)}&gt;加 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(num - 1)}&gt;减 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>num2: {num2}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum2(num2 * 2)}&gt;扩大一倍<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum2(num2 / 2)}&gt;缩小一倍<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="copy-code-btn">复制代码</span></code></pre><p>由于在条件判断的逻辑中，重置了<code>tag=false</code>，因此此后的渲染不会再进入条件判断语句。看起来好像没有问题？但是，由于 useState 是基于 Array+Cursor 来实现的，第一次渲染时候，state 和 cursor 的对应关系如下表：</p>
  <table>
    <thead>
    <tr>
      <th>变量名</th>
      <th>cursor</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>num</td>
      <td>0</td>
    </tr>
    <tr>
      <td>unusedNum</td>
      <td>1</td>
    </tr>
    <tr>
      <td>num2</td>
      <td>2</td>
    </tr>
    </tbody>
  </table>
  <p>当点击事件触发再次渲染，并不会进入条件判断中的 useState。所以，cursor=2 的时候对应的变量是 num2。而其实 num2 对应的 cursor 应该是 3。就会导致<code>setNum2</code>并不起作用。</p>
  <p>到此，解决了文章开头提出的「🤔️ 为什么不能在循环、判断内部使用 Hook」。在使用 Hook 的时候，请在函数组件顶部使用！</p>
  <h2 data-id="heading-3">useEffect 的实现原理</h2>
  <p>在探索 useEffect 原理的时候，一直被一个问题困扰：useEffect 作用和用途是什么？当然，用于函数的副作用这句话谁都会讲。举个例子吧：</p>
  <pre><code lang="scss" class="hljs language-scss copyable">function <span class="hljs-built_in">App</span>() {
  const <span class="hljs-selector-attr">[num, setNum]</span> = <span class="hljs-built_in">useState</span>(<span class="hljs-number">0</span>);

  <span class="hljs-built_in">useEffect</span>(() =&gt; {
    <span class="hljs-comment">// 模拟异步请求后端数据</span>
    <span class="hljs-built_in">setTimeout</span>(() =&gt; {
      <span class="hljs-built_in">setNum</span>(num + <span class="hljs-number">1</span>);
    }, <span class="hljs-number">1000</span>);
  }, <span class="hljs-selector-attr">[]</span>);

  return &lt;<span class="hljs-selector-tag">div</span>&gt;{!num ? "请求后端数据..." : `后端数据是 ${num}`}&lt;/<span class="hljs-selector-tag">div</span>&gt;;
}
<span class="copy-code-btn">复制代码</span></code></pre><p>这段代码，虽然这样组织可读性更高，毕竟可以将这个请求理解为函数的副作用。<strong>但这并不是必要的</strong>。完全可以不使用<code>useEffect</code>，直接使用<code>setTimeout</code>，并且它的回调函数中更新函数组件的 state。</p>
  <p>在阅读<a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F" title="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" ref="nofollow noopener noreferrer">A Complete Guide to useEffect</a>和<a target="_blank" href="https://link.juejin.cn?target=http%3A%2F%2Freact.html.cn%2Fdocs%2Fhooks-custom.html" title="http://react.html.cn/docs/hooks-custom.html" ref="nofollow noopener noreferrer">构建你自己的 Hooks</a>之后，我才理解 useEffect 的存在的必要性和意义。</p>
  <p>在 useEffect 的第二个参数中，我们可以指定一个数组，如果下次渲染时，数组中的元素没变，那么就不会触发这个副作用（可以类比 Class 类的关于 nextprops 和 prevProps 的生命周期）。好处显然易见，<strong>相比于直接裸写在函数组件顶层，useEffect 能根据需要，避免多余的 render</strong>。</p>
  <p>下面是一个不包括销毁副作用功能的 useEffect 的 TypeScript 实现：</p>
  <pre><code lang="ini" class="hljs language-ini copyable">// 还是利用 Array + Cursor的思路
const allDeps: any<span class="hljs-section">[]</span><span class="hljs-section">[]</span> = <span class="hljs-section">[]</span><span class="hljs-comment">;</span>
let effectCursor: <span class="hljs-attr">number</span> = <span class="hljs-number">0</span><span class="hljs-comment">;</span>

function useEffect(callback: () =&gt; void, deps: any<span class="hljs-section">[]</span>) {
  if (!allDeps<span class="hljs-section">[effectCursor]</span>) {
    // 初次渲染：赋值 + 调用回调函数
    allDeps<span class="hljs-section">[effectCursor]</span> = deps<span class="hljs-comment">;</span>
    ++effectCursor<span class="hljs-comment">;</span>
    callback()<span class="hljs-comment">;</span>
    return<span class="hljs-comment">;</span>
  }

  const <span class="hljs-attr">currenEffectCursor</span> = effectCursor<span class="hljs-comment">;</span>
  const <span class="hljs-attr">rawDeps</span> = allDeps[currenEffectCursor]<span class="hljs-comment">;</span>
  // 检测依赖项是否发生变化，发生变化需要重新render
  const <span class="hljs-attr">isChanged</span> = rawDeps.some(
    (dep: any, index: number) =&gt; dep !== deps<span class="hljs-section">[index]</span>
  )<span class="hljs-comment">;</span>
  if (isChanged) {
    callback()<span class="hljs-comment">;</span>
    allDeps<span class="hljs-section">[effectCursor]</span> = deps<span class="hljs-comment">; // 感谢 juejin@carlzzz 的指正</span>
  }
  ++effectCursor<span class="hljs-comment">;</span>
}

function render() {
  ReactDOM.render(&lt;App /&gt;, document.getElementById("root"))<span class="hljs-comment">;</span>
  <span class="hljs-attr">effectCursor</span> = <span class="hljs-number">0</span><span class="hljs-comment">; // 注意将 effectCursor 重置为0</span>
}
<span class="copy-code-btn">复制代码</span></code></pre><p>对于 useEffect 的实现，配合下面案例的使用会更容易理解。当然，你也可以在这个 useEffect 中发起异步请求，并在接受数据后，调用 state 的更新函数，不会发生爆栈的情况。</p>
  <pre><code lang="typescript" class="hljs language-typescript copyable"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, setNum] = useState &lt; <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">const</span> [num2] = useState &lt; <span class="hljs-built_in">number</span> &gt; <span class="hljs-number">1</span>;

  <span class="hljs-comment">// 多次触发</span>
  <span class="hljs-comment">// 每次点击按钮，都会触发 setNum 函数</span>
  <span class="hljs-comment">// 副作用检测到 num 变化，会自动调用回调函数</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"num update: "</span>, num);
  }, [num]);

  <span class="hljs-comment">// 仅第一次触发</span>
  <span class="hljs-comment">// 只会在compoentDidMount时，触发一次</span>
  <span class="hljs-comment">// 副作用函数不会多次执行</span>
  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"num2 update: "</span>, num2);
  }, [num2]);

  <span class="hljs-keyword">return</span> (
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>num: {num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(num + 1)}&gt;加 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setNum(num - 1)}&gt;减 1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
  );
}
<span class="copy-code-btn">复制代码</span></code></pre><p>⚠️ useEffect 第一个回调函数可以返回一个用于销毁副作用的函数，相当于 Class 组件的 unmount 生命周期。这里为了方便说明，没有进行实现。</p>
  <p>在这一小节中，尝试解答了 「🤔️ useEffect 的实现原理」和 「🤔️ useEffect 的应用场景」这两个问题。</p>
  <h2 data-id="heading-4">Class VS Hooks</h2>
  <p>虽然 Hooks 看起来更酷炫，更简洁。但是在实际开发中我更倾向于使用 Class 来声明组件。两种方法的对比如下：</p>
  <table>
    <thead>
    <tr>
      <th>Class</th>
      <th>Hooks</th>
    </tr>
    </thead>
    <tbody>
    <tr>
      <td>代码逻辑清晰（构造函数、componentDidMount 等）</td>
      <td>需要配合变量名和注释</td>
    </tr>
    <tr>
      <td>不容易内存泄漏</td>
      <td>容易发生内存泄漏</td>
    </tr>
    </tbody>
  </table>
  <p>总的来说，Hooks 对代码编写的要求较高，在没有有效机制保证代码可读性、规避风险的情况下，Class 依然是我的首选。关于内存泄漏，下面是一个例子（目前还没找到方法规避这种向全局传递状态更新函数的做法）：</p>
  <pre><code lang="javascript" class="hljs language-javascript copyable"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { useState } <span class="hljs-keyword">from</span> <span class="hljs-string">"react"</span>;
<span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">"react-dom"</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">func</span>: any;
<span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">typeof</span> func === <span class="hljs-string">"function"</span> &amp;&amp; <span class="hljs-title function_">func</span>(<span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>());
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">"interval"</span>);
}, <span class="hljs-number">1000</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> [num, setNum] = useState &lt; number &gt; <span class="hljs-number">0</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> func !== <span class="hljs-string">"function"</span>) {
    func = setNum;
  }
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{num}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">render</span>(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span>, <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">"root"</span>));
}

<span class="hljs-title function_">render</span>();
<span class="copy-code-btn">复制代码</span></code></pre><h2 data-id="heading-5">参考链接</h2>
  <ul>
    <li><a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2F%40ryardley%2Freact-hooks-not-magic-just-arrays-cd4f1857236e" title="https://medium.com/@ryardley/react-hooks-not-magic-just-arrays-cd4f1857236e" ref="nofollow noopener noreferrer">React hooks: not magic, just arrays</a></li>
    <li><a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F" title="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" ref="nofollow noopener noreferrer">A Complete Guide to useEffect</a></li>
    <li><a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Foverreacted.io%2Fzh-hans%2Fa-complete-guide-to-useeffect%2F" title="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/" ref="nofollow noopener noreferrer">useEffect 完整指南</a></li>
    <li><a target="_blank" href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fbrickspert%2Fblog%2Fissues%2F26" title="https://github.com/brickspert/blog/issues/26" ref="nofollow noopener noreferrer">React Hooks 原理</a>: <code>useEffect</code>实现有问题，回调函数调用 state 的更新函数，会爆栈</li>
  </ul>
  <p>文章中多有见解不到当之处，欢迎讨论和指正。</p>
</div>
