<div class="markdown prose w-full break-words dark:prose-invert dark"><p>洋葱模型是一种常用的中间件模型，例如在 Express 框架中就广泛应用了这种模型。这种模型的特点是请求被传递到下一个中间件之前，需要先经过当前中间件处理，然后再逐层返回。</p><p>下面是一个简单的洋葱模型的示例代码：</p><pre><div class="bg-black rounded-md mb-4"><div class="flex items-center relative text-gray-200 bg-gray-800 px-4 py-2 text-xs font-sans justify-between rounded-t-md"><span>javascript</span><button class="flex ml-auto gap-2"><svg stroke="currentColor" fill="none" stroke-width="2" viewBox="0 0 24 24" stroke-linecap="round" stroke-linejoin="round" class="h-4 w-4" height="1em" width="1em" xmlns="http://www.w3.org/2000/svg"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>Copy code</button></div><div class="p-4 overflow-y-auto"><code class="!whitespace-pre hljs language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware1</span>(<span class="hljs-params">next</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'middleware1 before'</span>);
    <span class="hljs-title function_">next</span>(ctx);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'middleware1 after'</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware2</span>(<span class="hljs-params">next</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'middleware2 before'</span>);
    <span class="hljs-title function_">next</span>(ctx);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'middleware2 after'</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">middleware3</span>(<span class="hljs-params">next</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'middleware3 before'</span>);
    <span class="hljs-title function_">next</span>(ctx);
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">'middleware3 after'</span>);
  }
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">compose</span>(<span class="hljs-params">middlewares</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">ctx</span>) {
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">dispatch</span>(<span class="hljs-params">i</span>) {
      <span class="hljs-keyword">if</span> (i === middlewares.<span class="hljs-property">length</span>) {
        <span class="hljs-keyword">return</span>;
      }
      <span class="hljs-keyword">const</span> middleware = middlewares[i];
      <span class="hljs-keyword">const</span> next = dispatch.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, i + <span class="hljs-number">1</span>);
      <span class="hljs-title function_">middleware</span>(next)(ctx);
    }
    <span class="hljs-title function_">dispatch</span>(<span class="hljs-number">0</span>);
  }
}

<span class="hljs-keyword">const</span> middlewares = [middleware1, middleware2, middleware3];
<span class="hljs-keyword">const</span> composed = <span class="hljs-title function_">compose</span>(middlewares);
<span class="hljs-title function_">composed</span>({});
</code></div></div></pre><p>这个示例中有三个中间件函数 <code>middleware1</code>、<code>middleware2</code> 和 <code>middleware3</code>，它们都是接受一个 <code>next</code> 函数作为参数的高阶函数。当这个中间件被执行时，它将接受一个 <code>ctx</code> 对象作为参数，并且调用 <code>next(ctx)</code> 将请求传递给下一个中间件。</p><p><code>compose</code> 函数接受一个中间件函数数组作为参数，返回一个新的函数，这个函数可以将请求传递给第一个中间件函数。每个中间件函数都将接收一个 <code>next</code> 函数作为参数，并返回一个新的函数，这个新的函数将接收 <code>ctx</code> 对象作为参数，并且在调用 <code>next(ctx)</code> 之前和之后都会执行一些操作。当 <code>next(ctx)</code> 被调用时，请求将被传递到下一个中间件函数。</p><p>在 <code>composed</code> 函数中，我们将一个空的 <code>ctx</code> 对象作为参数传递给第一个中间件函数。<code>dispatch</code> 函数递归地调用中间件数组中的每一个中间件函数，并将 <code>ctx</code> 对象和下一个中间件函数作为参数传递。当最后一个中间件函数完成处理时，递归调用结束，请求处理完成。</p><p>这是一个简单的示例，实际的洋葱模型可能更加复杂。</p></div>
