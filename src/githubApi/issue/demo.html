<div class="markdown-body cache"><style>.markdown-body{word-break:break-word;line-height:1.75;font-weight:400;font-size:16px;overflow-x:hidden;color:#252933}.markdown-body h1,.markdown-body h2,.markdown-body h3,.markdown-body h4,.markdown-body h5,.markdown-body h6{line-height:1.5;margin-top:35px;margin-bottom:10px;padding-bottom:5px}.markdown-body h1{font-size:24px;line-height:38px;margin-bottom:5px}.markdown-body h2{font-size:22px;line-height:34px;padding-bottom:12px;border-bottom:1px solid #ececec}.markdown-body h3{font-size:20px;line-height:28px}.markdown-body h4{font-size:18px;line-height:26px}.markdown-body h5{font-size:17px;line-height:24px}.markdown-body h6{font-size:16px;line-height:24px}.markdown-body p{line-height:inherit;margin-top:22px;margin-bottom:22px}.markdown-body img{max-width:100%}.markdown-body hr{border:none;border-top:1px solid #ddd;margin-top:32px;margin-bottom:32px}.markdown-body code{word-break:break-word;border-radius:2px;overflow-x:auto;background-color:#fff5f5;color:#ff502c;font-size:.87em;padding:.065em .4em}.markdown-body code,.markdown-body pre{font-family:Menlo,Monaco,Consolas,Courier New,monospace}.markdown-body pre{overflow:auto;position:relative;line-height:1.75}.markdown-body pre>code{font-size:12px;padding:15px 12px;margin:0;word-break:normal;display:block;overflow-x:auto;color:#333;background:#f8f8f8}.markdown-body a{text-decoration:none;color:#0269c8;border-bottom:1px solid #d1e9ff}.markdown-body a:active,.markdown-body a:hover{color:#275b8c}.markdown-body table{display:inline-block!important;font-size:12px;width:auto;max-width:100%;overflow:auto;border:1px solid #f6f6f6}.markdown-body thead{background:#f6f6f6;color:#000;text-align:left}.markdown-body tr:nth-child(2n){background-color:#fcfcfc}.markdown-body td,.markdown-body th{padding:12px 7px;line-height:24px}.markdown-body td{min-width:120px}.markdown-body blockquote{color:#666;padding:1px 23px;margin:22px 0;border-left:4px solid #cbcbcb;background-color:#f8f8f8}.markdown-body blockquote:after{display:block;content:""}.markdown-body blockquote>p{margin:10px 0}.markdown-body ol,.markdown-body ul{padding-left:28px}.markdown-body ol li,.markdown-body ul li{margin-bottom:0;list-style:inherit}.markdown-body ol li .task-list-item,.markdown-body ul li .task-list-item{list-style:none}.markdown-body ol li .task-list-item ol,.markdown-body ol li .task-list-item ul,.markdown-body ul li .task-list-item ol,.markdown-body ul li .task-list-item ul{margin-top:0}.markdown-body ol ol,.markdown-body ol ul,.markdown-body ul ol,.markdown-body ul ul{margin-top:3px}.markdown-body ol li{padding-left:6px}.markdown-body .contains-task-list{padding-left:0}.markdown-body .task-list-item{list-style:none}@media (max-width:720px){.markdown-body h1{font-size:24px}.markdown-body h2{font-size:20px}.markdown-body h3{font-size:18px}}</style><style data-highlight="" data-highlight-key="juejin">.markdown-body pre,.markdown-body pre>code.hljs{color:#333;background:#f8f8f8}.hljs-comment,.hljs-quote{color:#998;font-style:italic}.hljs-keyword,.hljs-selector-tag,.hljs-subst{color:#333;font-weight:700}.hljs-literal,.hljs-number,.hljs-tag .hljs-attr,.hljs-template-variable,.hljs-variable{color:teal}.hljs-doctag,.hljs-string{color:#d14}.hljs-section,.hljs-selector-id,.hljs-title{color:#900;font-weight:700}.hljs-subst{font-weight:400}.hljs-class .hljs-title,.hljs-type{color:#458;font-weight:700}.hljs-attribute,.hljs-name,.hljs-tag{color:navy;font-weight:400}.hljs-link,.hljs-regexp{color:#009926}.hljs-bullet,.hljs-symbol{color:#990073}.hljs-built_in,.hljs-builtin-name{color:#0086b3}.hljs-meta{color:#999;font-weight:700}.hljs-deletion{background:#fdd}.hljs-addition{background:#dfd}.hljs-emphasis{font-style:italic}.hljs-strong{font-weight:700}</style><p><strong>小知识，大挑战！本文正在参与“</strong> &nbsp;<strong><a href="https://juejin.cn/post/7008476801634680869" title="https://juejin.cn/post/7008476801634680869" target="_blank">程序员必备小知识</a></strong>&nbsp; <strong>”创作活动</strong></p>
  <p><strong>本文同时参与</strong>&nbsp;<strong><a href="https://juejin.cn/post/7012210233804079141" title="https://juejin.cn/post/7012210233804079141" target="_blank">「掘力星计划」</a></strong>&nbsp; <strong>，赢取创作大礼包，挑战创作激励金</strong></p>
  <h3 data-id="heading-0">浏览器进程：</h3>
  <p>浏览器是一个多进程的架构，当我们每开一个tab页面，就会开一个新的进程，所以如果一个页面崩溃也不会影响到别的页面。面试的时候经常会问从输入url到页面显示都发生了什么，这次主要说说针对渲染这块而浏览器具体都做了些什么，都有哪些进程？</p>
  <p>首先浏览器进程有如下几部分：<strong>主进程</strong>，<strong>第三方插件进程，GPU进程，渲染进程</strong>。</p>
  <p>而渲染进程又包含了很多线程：<strong>js引擎线程，事件触发线程，定时器触发线程，异步http请求线程，GUI渲染线程。</strong></p>
  <p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6e40c867849c4911a6c16491a9bcf739~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
  <p>主进程：负责页面的显示与交互，各个页面的管理，创建和销毁其他进程。网络的资源管理和下载。</p>
  <p>GPU进程：
    最多有一个，3d绘制等。</p>
  <p>插件进程：
    每种类型的插件对应一个进程。</p>
  <p>渲染进程：称为浏览器渲染或浏览器内核，内部是多线程的；主要负责页面渲染，脚本执行，事件处理等。</p>
  <p>GUI渲染线程：</p>
  <pre><code class="hljs language-markdown copyable" lang="markdown"><span class="hljs-bullet">1.</span> 负责渲染浏览器界面，解析html，css，构建dom树和render树，布局和绘制。
<span class="hljs-bullet">2.</span> 当重绘和回流的时候就会执行这个线程
<span class="hljs-bullet">3.</span> GUI渲染线程和js引擎线程互斥，当js引擎执行时，GUI线程就会被挂起（相当于冻结了），GUI更新会被保存在一个队列中等到js引擎空闲时立即执行。
<span class="hljs-code">
</span><span class="copy-code-btn">复制代码</span></code></pre>
  <p>js引擎线程：</p>
  <pre><code class="hljs language-markdown copyable" lang="markdown"><span class="hljs-bullet">1.</span> 也称js内核，负责处理js脚本程序，例如v8引擎
<span class="hljs-bullet">2.</span> 负责解析js脚本，运行代码
<span class="hljs-bullet">3.</span> 等待任务队列中的任务，一个tab页只有一个js进程
<span class="hljs-bullet">4.</span> 因为与GUI渲染线程互斥，所以js执行过长时间，就会造成页面渲染不连贯，导致页面渲染阻塞
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>事件触发线程：</p>
  <pre><code class="hljs language-markdown copyable" lang="markdown"><span class="hljs-bullet">1.</span> 归属于浏览器而不是js引擎，用了控制事件循环
<span class="hljs-bullet">2.</span> 当js引擎执行settimeout类似的代码块时，会将对应任务添加到事件线程
<span class="hljs-bullet">3.</span> 当对应的事件符合触发条件时，会被放到任务队列的队尾，等待js引擎线程处理
<span class="hljs-bullet">4.</span> 由于js单线程的关系，这些等待处理的事件都需要排队等待js引擎处理
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>定时器触发线程：</p>
  <pre><code class="hljs language-markdown copyable" lang="markdown"><span class="hljs-bullet">1.</span> settimeout和setinterval所在的线程
<span class="hljs-bullet">2.</span> 浏览器定时计数器不是由js引擎线程计数的，因此通过单独线程来计时触发定时，计时完毕后，添加到事件队列，等待js引擎执行。
<span class="copy-code-btn">复制代码</span></code></pre>
  <p>异步http请求进程：</p>
  <pre><code class="hljs language-markdown copyable" lang="markdown"><span class="hljs-bullet">1.</span> 在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求。
<span class="hljs-bullet">2.</span> 将检测到状态变更时,如果设置有回调函数,异步线程就产生状态变更事件,将这个回调再放入事件队列中。再由 JavaScript 引擎执行
<span class="copy-code-btn">复制代码</span></code></pre>
  <p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e0e27b8d2954ab18ddf0ba13bdf70ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c0bb32540e484bff8c162417e8112154~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
  <p>看图能大致了解渲染流程的七七八八，我按照我的理解重新梳理一下：</p>
  <pre><code class="hljs language-css copyable" lang="css"><span class="hljs-number">1</span>. 构建DOM树。因为浏览器无法理解和直接使用<span class="hljs-selector-tag">html</span>所以需要转换成dom树的形式，对<span class="hljs-selector-tag">html</span>进行解析。
<span class="hljs-number">2</span>. 样式计算，对css进行解析。首先把css文本转化成浏览器可以理解的结构<span class="hljs-attr">--stylesheets</span>，然后对stylesheets进行标准化处理，就是将一些属性值转化为渲染引擎更容易理解，标准化的计算值（例如，<span class="hljs-attribute">color</span>单词形式转化为rgb，<span class="hljs-selector-tag">em</span>单位转化为px），其次计算dom节点的样式属性。
<span class="hljs-number">3</span>. 布局阶段。
	<span class="hljs-selector-tag">a</span>. 首先创建布局：遍历dom中所有节点，并添加到布局树中。
	<span class="hljs-selector-tag">b</span>. 布局计算：通过js和css，计算dom在页面上的位置。
	c. 最后创建布局树。
<span class="hljs-number">4</span>. 分层。根据复杂的<span class="hljs-number">3</span>d转换，页面滚动，还有<span class="hljs-attribute">z-index</span>属性都会形成单独图层，把图层按照正确顺序排列。生成分层树。
<span class="hljs-number">5</span>. 图层绘制，栅格化以及图层显示。对每个图层进行单独的绘制，并提交到合成器线程。
<span class="hljs-number">6</span>. 合成线程将图层分为图块，并在栅格化线程池中将图块转化为位图。
<span class="hljs-number">7</span>. 合成线程发送绘制图块命令drawquads给浏览器进程。
<span class="hljs-number">8</span>. 浏览器根据drawquads消息生成页面展示出来
<span class="copy-code-btn">复制代码</span></code></pre>
  <h3 data-id="heading-1">css阻塞，js阻塞：</h3>
  <p>关于提高页面性能经常听到建议说：把css代码放头部，js代码放底部。还有如果script和link都在头部，应该把script放上面。</p>
  <p>css不会阻塞DOM解析，css阻塞DOM渲染：</p>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6cbba082d94a4241b2c2ab9e1e73c2c5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
  <p>从这个渲染流程图可以看出，dom解析的时候，也可以进行css的解析</p>
  <p>js阻塞DOM解析：</p>
  <p>如果“script”和link都在头部，把link放在头部。就会发生阻塞，浏览器会先去下载css样式，再执行js，再执行dom。
    因为浏览器不知道js脚本会写些什么，如果有删除dom操作，那提前解析dom就是无用功。不过浏览器也会先“偷看”下html中是否有碰到如link、script和img等标签时，它会帮助我们先行下载里面的资源，不会傻等到解析到那里时才下载。</p>
  <p>我们在优化js阻塞的时候经常会用<strong>defer和async异步进行js的解析，那这两个有什么区别呢？</strong></p>
  <h3 data-id="heading-2">async：</h3>
  <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d5baa0a68b84c65b8b9059edf12be5c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
  <p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bde046b1318a4cc2849607734cd6653c~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
  <p>在html解析的时候，async异步的解析js，如果js解析完毕，html还没解析完，就会停止html解析，立即执行js；
    如果html解析完了就正好，直接执行js。所以还是有可能阻塞html。</p>
  <h3 data-id="heading-3">defer：</h3>
  <p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/df533c40559640b78c0806288e60dc48~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="image.png" loading="lazy" class="medium-zoom-image"></p>
  <p>在html解析的时候，defer可以异步的支持解析js，等到html解析完成后，才会执行js。必然不会阻塞html。</p></div>
