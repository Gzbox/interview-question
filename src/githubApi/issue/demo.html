<article class="article fmt article-content "><p>在实现vue双向数据绑定之前，先了解Proxy相关的概念和用法</p><h3 id="item-1">proxy概念</h3><p><code>Proxy</code> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。</p><h3 id="item-2">一些术语</h3><ul><li>handle</li></ul><p>包含捕捉器（trap）的占位符对象，可译为处理器对象</p><ul><li>traps</li></ul><p>提供属性访问的方法。这类似于操作系统中捕获器的概念。</p><ul><li>target</li></ul><p>被 Proxy 代理虚拟化的对象。</p><h3 id="item-3">语法</h3><p><code>const p = new Proxy(target, handler)</code></p><ul><li>target</li></ul><p>要使用 Proxy 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p><ul><li>handle</li></ul><p>一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 p 的行为。</p><h3 id="item-4">使用proxy实现数据劫持</h3><div class="widget-codetool" style="display: none;">
  <div class="widget-codetool--inner">
    <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="let data = {
    name: YoLinDeng,
    height: '176cm'
}

const p = new Proxy(data, {
    get(target, prop) {
        return Reflect.get(...arguments)
    },
    set(target, prop, newValue) {
        return Reflect.set(...arguments)
    }
})" title="" data-bs-original-title="复制" aria-label="复制"></button>
  </div>
</div><pre class="hljs language-javascript"><span class="hljs-keyword">let</span> data = {
    <span class="hljs-attr">name</span>: <span class="hljs-title class_">YoLinDeng</span>,
    <span class="hljs-attr">height</span>: <span class="hljs-string">'176cm'</span>
}

<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, {
    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(...<span class="hljs-variable language_">arguments</span>)
    },
    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, prop, newValue</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(...<span class="hljs-variable language_">arguments</span>)
    }
})</pre><h3 id="item-5">关于vue中数据响应式的原理</h3><h4>对数据进行侦测</h4><ul><li>在vue2.X中，实现一个<code>observe</code>类，对于对象数据，通过<code>Object.defineProperty</code>来劫持对象的属性，实现<code>getter</code>和<code>setter</code>方法，这样就可以在getter的时候知道谁（订阅者）读取了数据，即谁依赖了当前的数据，将它通过<code>Dep类</code>（订阅器）收集统一管理，在setter的时候调用Dep类中的<code>notify</code>方法通知所以相关的订阅者进行更新视图。如果对象的属性也是一个对象的话，则需要递归调用<code>observe</code>进行处理。</li><li>对于数组则需要另外处理，通过实现一个拦截器类，并将它挂载到数组数据的原型上，当调用<code>push/pop/shift/unshift/splice/sort/reverse</code>修改数组数据时候，相当于调用的是拦截器中重新定义的方法，这样在拦截器中就可以侦测到数据改变了，并通知订阅者更新视图。</li><li>vue3中使用Proxy替代了Object.defineProperty，优点在于可以直接监听对象而非属性、可以直接监听数组的变化、多达13种拦截方法。缺点是兼容性还不够好。Proxy作为新标准将受到浏览器厂商重点持续的性能优化。</li></ul><h4>对模板字符串进行编译</h4><ul><li>实现Compile解析器类，将<code>template</code>中的模板字符串通过正则等方式进行处理生成对应的ast（抽象语法树），通过调用定义的不同钩子函数进行处理，包括开始标签（<code>start</code>）并判断是否自闭和以及解析属性、结束标签（<code>end</code>）、文本（<code>chars</code>）、注释（<code>comment</code>）</li><li>将通过html解析与文本解析的ast进行优化处理，在静态节点上打标记，为后面<code>dom-diff</code>算法中性能优化使用，即在对比前后vnode的时候会跳过静态节点不作对比。</li><li>最后根据处理好的ast生产<code>render</code>函数，在组件挂载的时候调用<code>render</code>函数就可以得到虚拟dom。</li></ul><h4>虚拟dom</h4><ul><li>vnode的类型包括注释节点、文本节点、元素节点、组件节点、函数式组件节点、克隆节点，<code>VNode</code>可以描述的多种节点类型，它们本质上都是<code>VNode</code>类的实例，只是在实例化的时候传入的属性参数不同而已。</li><li>通过将模板字符串编译生成虚拟dom并缓存起来，当数据发生变化时，通过对比变化前后虚拟dom，以变化后的虚拟dom为基准，更新旧的虚拟dom，使它和新的一样。把dom-diff过程叫做<code>patch</code>的过程，其主要做了三件事，分别是创建/删除/更新节点。</li><li>对于子节点的更新策略，vue中为了避免双重循环数据量大时候造成时间复杂度高带来的性能问题，而选择先从子节点数组中4个特殊位置进行对比，分别是：新前与旧前，新后与旧后，新后与旧前，新前与旧后。如果四种情况都没有找到相同的节点，则再通过循环方式查找。</li></ul><h3 id="item-6">实现简易的vue双向数据绑定</h3><p>vue的双向数据绑定主要是指，数据变化更新视图变化，视图变化更新数据。<br><strong>实现代码如下</strong></p><div class="widget-codetool" style="display: none;">
  <div class="widget-codetool--inner">
    <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="<!DOCTYPE html>
<html lang=&quot;en&quot;>
<head>
  <meta charset=&quot;UTF-8&quot;>
  <meta name=&quot;viewport&quot; content=&quot;width= , initial-scale=1.0&quot;>
  <title>Document</title>
  <script src=&quot;myVue.js&quot;></script>
</head>
<body>
  <div id=&quot;app&quot;>
    {{name}}
    <div>{{message}}</div>
    <input type=&quot;text&quot; v-model=&quot;test&quot;>
    <span>{{test}}</span>
  </div>
  <script>
    let vm = new vue({
      el: '#app',
      data: {
        name: 'YoLinDeng',
        message: '打篮球',
        test: '双向绑定数据'
      }
    })
    // console.log(vm._data)
  </script>
</body>
</html>" title="" data-bs-original-title="复制" aria-label="复制"></button>
  </div>
</div><pre class="hljs language-handlebars"><span class="language-xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width= , initial-scale=1.0"</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"myVue.js"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"app"</span>&gt;</span>
    </span><span class="hljs-template-variable">{{<span class="hljs-name">name</span>}}</span><span class="language-xml">
    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">{{<span class="hljs-name">message</span>}}</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"test"</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">{{<span class="hljs-name">test</span>}}</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
    <span class="hljs-keyword">let</span> vm = <span class="hljs-keyword">new</span> <span class="hljs-title function_">vue</span>({
      <span class="hljs-attr">el</span>: <span class="hljs-string">'#app'</span>,
      <span class="hljs-attr">data</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">'YoLinDeng'</span>,
        <span class="hljs-attr">message</span>: <span class="hljs-string">'打篮球'</span>,
        <span class="hljs-attr">test</span>: <span class="hljs-string">'双向绑定数据'</span>
      }
    })
    <span class="hljs-comment">// console.log(vm._data)</span>
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></span></pre><div class="widget-codetool" style="display: none;">
  <div class="widget-codetool--inner">
    <button type="button" class="btn btn-dark far fa-copy rounded-0 sflex-center copyCode" data-toggle="tooltip" data-placement="top" data-clipboard-text="class vue extends EventTarget {
  constructor(option) {
    super()
    this.option = option
    this._data = this.option.data
    this.el = document.querySelector(this.option.el)
    this.compileNode(this.el)
    this.observe(this._data)
  }
  // 实现监听器方法
  observe(data) {
    const context = this
    // 使用proxy代理，劫持数据
    this._data = new Proxy(data, {
      set(target, prop, newValue) {
        // 自定义事件
        let event = new CustomEvent(prop, {
          detail: newValue
        })
        // 发布自定义事件
        context.dispatchEvent(event)
        return Reflect.set(...arguments)
      }
    })
  }
  // 实现解析器方法，解析模板
  compileNode(el) {
    let child = el.childNodes
    let childArr = [...child]
    childArr.forEach(node => {
      if (node.nodeType === 3) {
        let text = node.textContent
        let reg = /\{\{\s*([^\s\{\}]+)\s*\}\}/g
        if (reg.test(text)) {
          let $1 = RegExp.$1
          this._data[$1] &amp;&amp; (node.textContent = text.replace(reg, this._data[$1]))
          // 监听数据更改事件
          this.addEventListener($1, e => {
            node.textContent = text.replace(reg, e.detail)
          })
        }
      } else if (node.nodeType === 1) { // 如果是元素节点
        let attr = node.attributes
        // 判断属性中是否含有v-model
        if (attr.hasOwnProperty('v-model')) {
          let keyName = attr['v-model'].nodeValue
          node.value = this._data[keyName]
          node.addEventListener('input', e => {
            this._data[keyName] = node.value
          })
        }
        // 递归调用解析器方法
        this.compileNode(node)
      }
    })
  }
}" title="" data-bs-original-title="复制" aria-label="复制"></button>
  </div>
</div><pre class="hljs language-kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">vue</span> <span class="hljs-title">extends</span> <span class="hljs-title">EventTarget</span> {
  <span class="hljs-keyword">constructor</span>(option) {
    <span class="hljs-keyword">super</span>()
    <span class="hljs-keyword">this</span>.option = option
    <span class="hljs-keyword">this</span>._data = <span class="hljs-keyword">this</span>.option.<span class="hljs-keyword">data</span>
    <span class="hljs-keyword">this</span>.el = document.querySelector(<span class="hljs-keyword">this</span>.option.el)
    <span class="hljs-keyword">this</span>.compileNode(<span class="hljs-keyword">this</span>.el)
    <span class="hljs-keyword">this</span>.observe(<span class="hljs-keyword">this</span>._data)
  }
  <span class="hljs-comment">// 实现监听器方法</span>
  observe(<span class="hljs-keyword">data</span>) {
    <span class="hljs-keyword">const</span> context = <span class="hljs-keyword">this</span>
    <span class="hljs-comment">// 使用proxy代理，劫持数据</span>
    <span class="hljs-keyword">this</span>._data = new Proxy(<span class="hljs-keyword">data</span>, {
      <span class="hljs-keyword">set</span>(target, prop, newValue) {
        <span class="hljs-comment">// 自定义事件</span>
        let event = new CustomEvent(prop, {
          detail: newValue
        })
        <span class="hljs-comment">// 发布自定义事件</span>
        context.dispatchEvent(event)
        <span class="hljs-keyword">return</span> Reflect.<span class="hljs-keyword">set</span>(...arguments)
      }
    })
  }
  <span class="hljs-comment">// 实现解析器方法，解析模板</span>
  compileNode(el) {
    let child = el.childNodes
    let childArr = [...child]
    childArr.forEach(node =&gt; {
      <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">3</span>) {
        let text = node.textContent
        let reg = /\{\{\s*([^\s\{\}]+)\s*\}\}/g
        <span class="hljs-keyword">if</span> (reg.test(text)) {
          let $<span class="hljs-number">1</span> = RegExp.$<span class="hljs-number">1</span>
          <span class="hljs-keyword">this</span>._data[$<span class="hljs-number">1</span>] &amp;&amp; (node.textContent = text.replace(reg, <span class="hljs-keyword">this</span>._data[$<span class="hljs-number">1</span>]))
          <span class="hljs-comment">// 监听数据更改事件</span>
          <span class="hljs-keyword">this</span>.addEventListener($<span class="hljs-number">1</span>, e =&gt; {
            node.textContent = text.replace(reg, e.detail)
          })
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.nodeType === <span class="hljs-number">1</span>) { <span class="hljs-comment">// 如果是元素节点</span>
        let attr = node.attributes
        <span class="hljs-comment">// 判断属性中是否含有v-model</span>
        <span class="hljs-keyword">if</span> (attr.hasOwnProperty(<span class="hljs-string">'v-model'</span>)) {
          let keyName = attr[<span class="hljs-string">'v-model'</span>].nodeValue
          node.value = <span class="hljs-keyword">this</span>._data[keyName]
          node.addEventListener(<span class="hljs-string">'input'</span>, e =&gt; {
            <span class="hljs-keyword">this</span>._data[keyName] = node.value
          })
        }
        <span class="hljs-comment">// 递归调用解析器方法</span>
        <span class="hljs-keyword">this</span>.compileNode(node)
      }
    })
  }
}</pre></article>
