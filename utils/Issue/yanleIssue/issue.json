[
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/41",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/41/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/41/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/41/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/41",
    "id": 1610246580,
    "node_id": "I_kwDOJCCH1M5f-mm0",
    "number": 41,
    "title": "Promise 了解多少？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/3",
      "html_url": "https://github.com/yanlele/interview-question/milestone/3",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/3/labels",
      "id": 9118710,
      "node_id": "MI_kwDOJCCH1M4AiyP2",
      "number": 3,
      "title": "高",
      "description": "高级别面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 3,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:34:04Z",
      "updated_at": "2023-03-05T15:34:46Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 1,
    "created_at": "2023-03-05T15:34:46Z",
    "updated_at": "2023-03-05T15:39:51Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# Promise 对象\r\n\r\n### 1、Promise 的含义\r\nPromise 是异步编程的一种解决方案，比传统的解决方案 —— 回调函数和事件 —— 更合理和更强大。它由社区最早提出和实现， ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。\r\n\r\nPromise对象有以下两个特点。           \r\n\r\n**（ 1 ）对象的状态不受外界影响。**\r\nPromise对象代表一个异步操作，**有三种状态：Pending（进行中）、Resolved（已完成，又称 Fulfilled ）和Rejected（已失败）**。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是 “ 承诺 ” ，表示其他手段无法改变。      \r\n     \r\n**（ 2 ）一旦状态改变，就不会再变，任何时候都可以得到这个结果。**\r\nPromise对象的状态改变，**只有两种可能：从Pending变为Resolved和从Pending变为Rejected**。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（ Event ）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。             \r\n有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。         \r\nPromise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。            \r\n\r\n### 2、基本用法\r\n\r\n实例1：基本用法        \r\n```javascript\r\n    var promise = new Promise(function(resolve, reject) {\r\n    \t// ... some code\r\n        if (/*  异步操作成功 */){\r\n            resolve(value);\r\n        } else {\r\n            reject(error);\r\n        }\r\n    });\r\n```\r\n\r\n实例2：只要一new Promise后就会立即执行。          \r\n```javascript\r\n    let promise = new Promise(function(resolve, reject) {\r\n        console.log('Promise');\r\n        resolve();\r\n    });\r\n    promise.then(function() {\r\n        console.log('Resolved.');\r\n    });\r\n    console.log('Hi!');\r\n    // Promise\r\n    // Hi!\r\n    // Resolved\r\n```\r\n\r\n实例3：下面是一个用 Promise 对象实现的 Ajax 操作的例子。（非常经典）          \r\n```javascript\r\n    var getJSON = function (url) {\r\n        var promise = new Promise(function (resolve, reject) {\r\n            var client = new XMLHttpRequest();\r\n            client.open(\"GET\", url);\r\n            client.onreadystatechange = handler;\r\n            client.responseType = \"json\";\r\n            client.setRequestHeader(\"Accept\", \"application/json\");\r\n            client.send();\r\n    \r\n            function handler() {\r\n                if (this.readyState !== 4) {\r\n                    return;\r\n                }\r\n                if (this.status === 200) {\r\n                    resolve(this.response);\r\n                } else {\r\n                    reject(new Error(this.statusText));\r\n                }\r\n            };\r\n        });\r\n        return promise;\r\n    };\r\n    \r\n    getJSON(\"/posts.json\").then(function (json) {\r\n        console.log('Contents: ' + json);\r\n    }, function (error) {\r\n        console.error(' 出错了 ', error);\r\n    });\r\n```\r\n\r\n### 3、Promise.prototype.then()\r\n\r\nPromise 实例具有then方法，也就是说，then方法是定义在原型对象 Promise.prototype 上的。它的作用是为 Promise 实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是 Resolved 状态的回调函数，第二个参数（可选）是 Rejected 状态的回调函数。          \r\nthen方法返回的是一个新的 Promise 实例（注意，不是原来那个 Promise 实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。           \r\n```javascript\r\n    getJSON(\"/posts.json\").then(function(json) {\r\n        return json.post;\r\n    }).then(function(post) {\r\n        // ...\r\n    });\r\n```\r\n\r\n采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个 Promise 对象（即有异步操作），这时后一个回调函数，就会等待该 Promise 对象的状态发生变化，才会被调用。           \r\n```javascript\r\n    getJSON(\"/post/1.json\").then(function (post) {\r\n        return getJSON(post.commentURL);\r\n    }).then(function funcA(comments) {\r\n        console.log(\"Resolved: \", comments);\r\n    }, function funcB(err) {\r\n        console.log(\"Rejected: \", err);\r\n    });\r\n```\r\n\r\n上面代码中，第一个then方法指定的回调函数，返回的是另一个 Promise 对象。这时，第二个then方法指定的回调函数，就会等待这个新的 Promise 对象状态发生变化。如果变为 Resolved ，就调用funcA，如果状态变为 Rejected ，就调用funcB。              \r\n\r\n\r\n### 4、Promise.prototype.catch()     \r\nPromise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。         \r\n实例：     \r\n```javascript\r\n    getJSON(\"/posts.json\").then(function (posts) {\r\n        // ...\r\n    }).catch(function (error) {\r\n        //  处理 getJSON  和 前一个回调函数运行时发生的错误\r\n        console.log(' 发生错误！ ', error);\r\n    });\r\n```\r\n\r\n跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数， Promise 对象抛出的错误不会传递到外层代码，即不会有任何反应。           \r\n```javascript\r\n    var someAsyncThing = function () {\r\n        return new Promise(function (resolve, reject) {\r\n        //  下面一行会报错，因为 x 没有声明\r\n            resolve(x + 2);\r\n        });\r\n    };\r\n    someAsyncThing().then(function () {\r\n        console.log('everything is great');\r\n    });\r\n```\r\n\r\n### 5、Promise.all()     \r\nPromise.all方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。           \r\nvar p = Promise.all([p1, p2, p3]);          \r\n上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是 Promise 对象的实例。             \r\n\r\n实例：         \r\n```javascript\r\n    Promise.all([checkLogin(),getUserInfo()]).then(([res1,res2])=>{\r\n        console.log(`result1:${res1.result}, result2:${res2.userID}`)\r\n    });\r\n```\r\n\r\n### 6、Promise.race()            \r\nPromise.race(iterable) 方法返回一个 promise，一旦迭代器中的某个 promise 解决或拒绝，返回的 promise 就会解决或拒绝。\r\n\r\n\r\n### 7、Promise.resolve()         \r\n有时需要将现有对象转为 Promise 对象，Promise.resolve方法就起到这个作用。        \r\n```javascript\r\n    var jsPromise = Promise.resolve($.ajax('/whatever.json'));  \r\n```\r\n\r\n### 8、Promise.reject()          \r\nPromise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。它的参数用法与Promise.resolve方法完全一致。               \r\n\r\n\r\n### 9、两个有用的附加方法         \r\nES6 的 Promise API 提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在 ES6 之中、但很有用的方法。          \r\n#### 9.1、done()     \r\nPromise 对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为 Promise 内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。              \r\n```javascript\r\n    asyncFunc()\r\n        .then(f1)\r\n        .catch(r1)\r\n        .then(f2)\r\n        .done();\r\n```\r\n\r\n#### 9.2、finally()      \r\nfinally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。               \r\n```javascript\r\n    server.listen(0)\r\n        .then(function () {\r\n    // run test\r\n        })\r\n        .finally(server.stop);\r\n```\r\n\r\n### 10、Promise的使用           \r\n使用 Generator 函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。          \r\n```javascript\r\n    function getFoo() {\r\n        return new Promise(function (resolve, reject) {\r\n            resolve('foo');\r\n        });\r\n    }\r\n    \r\n    var g = function* () {\r\n        try {\r\n            var foo = yield getFoo();\r\n            console.log(foo);\r\n        } catch (e) {\r\n            console.log(e);\r\n        }\r\n    };\r\n    \r\n    function run(generator) {\r\n        var it = generator();\r\n    \r\n        function go(result) {\r\n            if (result.done) return result.value;\r\n            return result.value.then(function (value) {\r\n                return go(it.next(value));\r\n            }, function (error) {\r\n                return go(it.throw(error));\r\n            });\r\n        }\r\n    \r\n        go(it.next());\r\n    }\r\n    \r\n    run(g);\r\n```\r\n\r\n\r\n### 参考文章\r\n- [超详细的 Promise 理解与实现](https://juejin.im/post/6857934319886893064)\r\n- [前端 Promise 常见的应用场景](https://juejin.im/post/6844904131702833159)\r\n- [Promise 执行过程的正确理解姿势](https://juejin.im/post/6844903974563233799)\r\n- [【JavaScript】必须要会的手写Promise](https://juejin.im/post/6844904142087913486)\r\n- [深度揭秘 Promise 微任务注册和执行过程](https://juejin.im/post/6844903987183894535)\r\n\r\n\r\n### 其他Promise相关文档\r\n- [Promise原理与实现](/books/专题知识库/05、基础知识点专题/other/09、Promise原理与实现/README.md)\r\n- [超详细的 Promise 理解与实现](https://juejin.im/post/6857934319886893064)\r\n- [前端 Promise 常见的应用场景](https://juejin.im/post/6844904131702833159)\r\n- [Promise 执行过程的正确理解姿势](https://juejin.im/post/6844903974563233799)\r\n- [【JavaScript】必须要会的手写Promise](https://juejin.im/post/6844904142087913486)\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/41/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/41/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/40",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/40/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/40/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/40/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/40",
    "id": 1610245014,
    "node_id": "I_kwDOJCCH1M5f-mOW",
    "number": 40,
    "title": "手写 async 函数？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/3",
      "html_url": "https://github.com/yanlele/interview-question/milestone/3",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/3/labels",
      "id": 9118710,
      "node_id": "MI_kwDOJCCH1M4AiyP2",
      "number": 3,
      "title": "高",
      "description": "高级别面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 3,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:34:04Z",
      "updated_at": "2023-03-05T15:34:46Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T15:30:23Z",
    "updated_at": "2023-03-05T15:30:23Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## async/await 的本质\n\nasync/await 是 ECMAScript 2017（ES8）中引入的一个语言特性，用于处理异步编程。async/await 实际上是对 Promise 的封装，通过让开发者以同步的方式编写异步代码，使得代码更加易读和易于维护。\n\nasync/await 是一种更加高级的异步编程方式，它使用了 Promise 作为底层实现，可以更好地处理异步编程中的错误和异常，避免了回调地狱和代码可读性差的问题。\n\n## 手写 async/await 实现\n\nasync/await 的实现可以通过封装 Promise 和 Generator 函数来实现，下面是一个简单的手写实现示例：\n```js\nfunction delay(ms) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve();\n    }, ms);\n  });\n}\n\nfunction* generator() {\n  console.log(\"start\");\n  yield delay(1000);\n  console.log(\"after 1 second\");\n  yield delay(2000);\n  console.log(\"after 2 more seconds\");\n}\n\nfunction async(generatorFunc) {\n  const iterator = generatorFunc();\n\n  function handle(iteratorResult) {\n    if (iteratorResult.done) {\n      return Promise.resolve(iteratorResult.value);\n    }\n\n    return Promise.resolve(iteratorResult.value).then((res) => {\n      return handle(iterator.next(res));\n    });\n  }\n\n  return handle(iterator.next());\n}\n\nasync(function () {\n  return generator();\n}).then(() => {\n  console.log(\"all done\");\n});\n```\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/40/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/40/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/39",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/39/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/39/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/39/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/39",
    "id": 1610238252,
    "node_id": "I_kwDOJCCH1M5f-kks",
    "number": 39,
    "title": "ES6 Generator 了解多少？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T15:11:54Z",
    "updated_at": "2023-03-05T15:11:55Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## Generator 基本概念\n\nES6中的 Generator（生成器）是一种特殊类型的函数，它可以被暂停和恢复。这意味着在调用Generator函数时，它不会立即执行，而是返回一个可暂停执行的Generator对象。在需要的时候，可以通过调用.next()方法来恢复函数的执行。这使得我们能够编写更具表现力和灵活性的代码。\n\nGenerator函数使用特殊的语法：在函数关键字后面添加一个星号(*)。Generator函数中可以使用一个新的关键字yield，用于将函数的执行暂停，并且可以将一个值返回给调用者。\n\n以下是一个简单的 Generator 函数的例子：\n\n```js\nfunction* generateSequence() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nlet generator = generateSequence();\n\nconsole.log(generator.next().value); // 1\nconsole.log(generator.next().value); // 2\nconsole.log(generator.next().value); // 3\n```\n在上面的例子中，generateSequence()是一个Generator函数，它定义了一个简单的数列生成器。在函数中，使用了yield关键字，以便能够暂停函数执行。最后，我们通过调用generator.next()方法来恢复函数的执行，并逐步返回生成器中的每一个值。\n\n\nGenerator函数也可以接收参数，并且可以在每次迭代时使用不同的参数值。这使得它们能够以更灵活的方式生成数据。\n\n以下是一个带参数的Generator函数的例子：\n```js\nfunction* generateSequence(start, end) {\n  for (let i = start; i <= end; i++) {\n    yield i;\n  }\n}\n\nlet generator = generateSequence(1, 5);\n\nconsole.log(generator.next().value); // 1\nconsole.log(generator.next().value); // 2\nconsole.log(generator.next().value); // 3\nconsole.log(generator.next().value); // 4\nconsole.log(generator.next().value); // 5\n```\n\nGenerator是一种非常有用的工具，它能够帮助我们编写更灵活和表达力强的代码。它们在异步编程、迭代器和生成器等场景中得到了广泛的应用。\n\n\n## 与 async/await 有啥关系？\nGenerator 和 async/await 都是 ES6 中引入的异步编程解决方案，它们本质上都是利用了 JavaScript 中的协程（coroutine）。\n\nGenerator 和 async/await 都是 JavaScript 中用于异步编程的方式，它们的本质相同，都是利用了生成器函数的特性来实现异步操作。\n\n在 ES5 中，JavaScript 使用回调函数实现异步编程，但是这样会导致回调嵌套过深，代码可读性差、难以维护。Generator 和 async/await 的出现解决了这个问题，它们让异步编程更加像同步编程，使代码可读性和可维护性得到了大幅提升。\n\n**Generator 可以使用 yield 语句来暂停函数执行，并返回一个 Generator 对象，通过这个对象可以控制函数的继续执行和结束。而 async/await 则是基于 Promise 实现的语法糖，可以使异步代码看起来像同步代码，代码结构更加清晰明了。**\n\n在使用上，Generator 和 async/await 都需要通过一些特定的语法来实现异步操作，不同的是 async/await 通过 await 关键字等待 Promise 对象的解决，而 Generator 则是通过 yield 关键字暂停函数执行，并返回一个 Generator 对象，通过 next 方法控制函数的继续执行和结束。另外，async/await 可以更好地处理 Promise 的错误，而 Generator 需要使用 try/catch 语句来捕获错误。\n\nGenerator 和 async/await 可以互相转换，这意味着我们可以使用 Generator 来实现 async/await 的功能，也可以使用 async/await 来调用 Generator 函数。\n\n```js\nfunction* gen() {\n  yield 1;\n  yield 2;\n  yield 3;\n}\n\nasync function test() {\n  for await (const x of gen()) {\n    console.log(x);\n  }\n}\n\ntest(); // 输出 1, 2, 3\n```\n\n在上面的代码中，`for await...of` 循环语句可以遍历 `Generator` 函数生成的迭代器，从而实现异步迭代。注意在调用 for await...of 时需要使用 yield* 关键字来进行委托。\n\n\nGenerator 函数使用 await 调用示例：\n```js\nfunction* generator() {\n  const result1 = yield asyncTask1();\n  const result2 = yield asyncTask2(result1);\n  return result2;\n}\n\nasync function runGenerator() {\n  const gen = generator();\n  const result1 = await gen.next().value;\n  const result2 = await gen.next(result1).value;\n  const finalResult = await gen.next(result2).value;\n  console.log(finalResult);\n}\n\nrunGenerator();\n```\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/39/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/39/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/38",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/38/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/38/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/38/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/38",
    "id": 1610226221,
    "node_id": "I_kwDOJCCH1M5f-hot",
    "number": 38,
    "title": "ES6 Map 数据结构了解多少？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T14:40:20Z",
    "updated_at": "2023-03-05T14:40:20Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 基本概念\n\nMap 对象保存键值对，并且能够记住键的原始插入顺序。任何值（对象或者基本类型）都可以作为一个键或一个值。\n\nMap 对象是键值对的集合。Map 中的一个键只能出现一次；它在 Map 的集合中是独一无二的。Map 对象按键值对迭代——一个 for...of 循环在每次迭代后会返回一个形式为 [key，value] 的数组。迭代按插入顺序进行，即键值对按 set() 方法首次插入到集合中的顺序（也就是说，当调用 set() 时，map 中没有具有相同值的键）进行迭代。\n\n## api\n\n**静态属性**\n- size 属性：size属性返回 Map 结构的成员总数。\n\n**实例方法**\n- set(key, value)：set方法设置key所对应的键值，然后返回整个 Map 结构。如果key已经有值，则键值会被更新，否则就新生成该键。\n\n- get(key)：get方法读取key对应的键值，如果找不到key，返回undefined。\n\n- has(key)：has方法返回一个布尔值，表示某个键是否在 Map 数据结构中。\n\n- delete(key)：delete方法删除某个键，返回 true 。如果删除失败，返回 false 。\n\n- clear()：clear方法清除所有成员，没有返回值。\n\n- forEach()：遍历 Map 的所有成员。\n\n**迭代方法**\n- keys()：返回键名的遍历器。\n- values()：返回键值的遍历器。\n- entries()：返回所有成员的遍历器。\n- `Map.prototype[@@iterator]()`：返回一个新的迭代对象，其为一个包含 Map 对象中所有键值对的 [key, value] 数组，并以插入 Map 对象的顺序排列。\n    \n    \n## 复制或合并 Maps\nMap 能像数组一样被复制：\n```js\nconst original = new Map([\n  [1, 'one'],\n]);\n\nconst clone = new Map(original);\n\nconsole.log(clone.get(1)); // one\nconsole.log(original === clone); // false. 浅比较 不为同一个对象的引用\n```\n\n\nMap 对象间可以进行合并，但是会保持键的唯一性。\n```js\nconst first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nconst second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的。\n// 展开语法本质上是将 Map 对象转换成数组。\nconst merged = new Map([...first, ...second]);\n\nconsole.log(merged.get(1)); // uno\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\n\n\nMap 对象也能与数组合并：\n```js\nconst first = new Map([\n  [1, 'one'],\n  [2, 'two'],\n  [3, 'three'],\n]);\n\nconst second = new Map([\n  [1, 'uno'],\n  [2, 'dos']\n]);\n\n// Map 对象同数组进行合并时，如果有重复的键值，则后面的会覆盖前面的。\nconst merged = new Map([...first, ...second, [1, 'eins']]);\n\nconsole.log(merged.get(1)); // eins\nconsole.log(merged.get(2)); // dos\nconsole.log(merged.get(3)); // three\n```\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/38/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/38/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/37",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/37/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/37/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/37/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/37",
    "id": 1610223054,
    "node_id": "I_kwDOJCCH1M5f-g3O",
    "number": 37,
    "title": "Map 和 Object 有哪些主要的区别？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T14:31:00Z",
    "updated_at": "2023-03-05T14:31:19Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "不过 Map 和 Object 有一些重要的区别，在下列情况中使用 Map 会是更好的选择：\n\n<table class=\"standard-table\">\n  <thead>\n    <tr>\n      <th scope=\"row\"></th>\n      <th scope=\"col\">Map</th>\n      <th scope=\"col\">Object</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th scope=\"row\">意外的键</th>\n      <td><code>Map</code> 默认情况不包含任何键。只包含显式插入的键。</td>\n      <td>\n        <p>一个 <code>Object</code> 有一个原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</p>\n        <div class=\"notecard note\" id=\"sect1\">\n          <p><strong>备注：</strong>虽然可以用 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create\"><code>Object.create(null)</code></a> 来创建一个没有原型的对象，但是这种用法不太常见。</p>\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th scope=\"row\">键的类型</th>\n      <td>一个 <code>Map</code> 的键可以是<strong>任意值</strong>，包括函数、对象或任意基本类型。</td>\n      <td>一个 <code>Object</code> 的键必须是一个 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String\"><code>String</code></a> 或是 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol\"><code>Symbol</code></a>。</td>\n    </tr>\n    <tr>\n      <th scope=\"row\">键的顺序</th>\n      <td>\n        <p><code>Map</code> 中的键是有序的。因此，当迭代的时候，一个 <code>Map</code> 对象以插入的顺序返回键值。</p>\n      </td>\n      <td>\n        <p>虽然 <code>Object</code> 的键目前是有序的，但并不总是这样，而且这个顺序是复杂的。因此，最好不要依赖属性的顺序。</p>\n        <p>\n          自 ECMAScript 2015 规范以来，对象的属性被定义为是有序的；ECMAScript 2020 则额外定义了继承属性的顺序。参见 <a href=\"https://tc39.es/ecma262/#sec-ordinaryownpropertykeys\" class=\"external\" target=\"_blank\">OrdinaryOwnPropertyKeys</a>\n          和\n          <a href=\"https://tc39.es/ecma262/#sec-enumerate-object-properties\" class=\"external\" target=\"_blank\">EnumerateObjectProperties</a> 抽象规范说明。但是，请注意没有可以迭代对象所有属性的机制，每一种机制只包含了属性的不同子集。（<a href=\"/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\"><code>for-in</code></a>\n          仅包含了以字符串为键的属性；<a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys</code></a>\n          仅包含了对象自身的、可枚举的、以字符串为键的属性；<a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames\"><code>Object.getOwnPropertyNames</code></a>\n          包含了所有以字符串为键的属性，即使是不可枚举的；<a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols\"><code>Object.getOwnPropertySymbols</code></a>\n          与前者类似，但其包含的是以 <code>Symbol</code> 为键的属性，等等。）\n        </p>\n      </td>\n    </tr>\n    <tr>\n      <th scope=\"row\">Size</th>\n      <td><code>Map</code> 的键值对个数可以轻易地通过 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map/size\"><code>size</code></a> 属性获取。</td>\n      <td><code>Object</code> 的键值对个数只能手动计算。</td>\n    </tr>\n    <tr>\n      <th scope=\"row\">迭代</th>\n      <td><code>Map</code> 是 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols\">可迭代的</a> 的，所以可以直接被迭代。</td>\n      <td>\n        <p><code>Object</code> 没有实现 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterable_protocol\">迭代协议</a>，所以使用 JavaSctipt 的 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Statements/for...of\">for...of</a> 表达式并不能直接迭代对象。</p>\n        <div class=\"notecard note\" id=\"sect2\">\n          <p><strong>备注：</strong></p>\n          <ul>\n            <li>对象可以实现迭代协议，或者你可以使用 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys\"><code>Object.keys</code></a> 或 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/entries\"><code>Object.entries</code></a>。</li>\n            <li>\n              <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in\">for...in</a>\n              表达式允许你迭代一个对象的<em>可枚举</em>属性。\n            </li>\n          </ul>\n        </div>\n      </td>\n    </tr>\n    <tr>\n      <th scope=\"row\">性能</th>\n      <td>\n        <p>在频繁增删键值对的场景下表现更好。</p>\n      </td>\n      <td>\n        <p>在频繁添加和删除键值对的场景下未作出优化。</p>\n      </td>\n    </tr>\n    <tr>\n      <th scope=\"row\">序列化和解析</th>\n      <td>\n        <p>没有元素的序列化和解析的支持。</p>\n        <p>（但是你可以使用携带 <em>replacer</em> 参数的 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a> 创建一个自己的对 <code>Map</code> 的序列化和解析支持。参见 Stack Overflow 上的提问：<a href=\"https://stackoverflow.com/q/29085197/\" class=\"external\" target=\"_blank\">How do you JSON.stringify an ES6 Map?</a>）</p>\n      </td>\n      <td>\n        <p>原生的由 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object</code></a> 到 JSON 的序列化支持，使用 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify\"><code>JSON.stringify()</code></a>。</p>\n        <p>原生的由 JSON 到 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object\"><code>Object</code></a> 的解析支持，使用 <a href=\"/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse\"><code>JSON.parse()</code></a>。</p>\n      </td>\n    </tr>\n  </tbody>\n</table>\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/37/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/37/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/36",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/36/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/36/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/36/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/36",
    "id": 1610220287,
    "node_id": "I_kwDOJCCH1M5f-gL_",
    "number": 36,
    "title": "如何检测对象是否循环引用？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T14:22:49Z",
    "updated_at": "2023-03-05T14:34:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 检测循环引用\r\n\r\n例如下面的场景， 已经出现循环引用了， 如何检测？ \r\n```js\r\nconst foo = {\r\n  foo: \"Foo\",\r\n  bar: {\r\n    bar: \"Bar\",\r\n  },\r\n};\r\n\r\nfoo.bar.baz = foo; // 循环引用！\r\n```\r\n\r\n解答：使用 WeakSet 特性解决；\r\n```js\r\n// 对 传入的 subject 对象 内部存储的所有内容执行回调\r\nfunction execRecursively(fn, subject, _refs = new WeakSet()) {\r\n  // 避免无限递归\r\n  if (_refs.has(subject)) {\r\n    return;\r\n  }\r\n\r\n  fn(subject);\r\n  if (typeof subject === \"object\") {\r\n    _refs.add(subject);\r\n    for (const key in subject) {\r\n      execRecursively(fn, subject[key], _refs);\r\n    }\r\n  }\r\n}\r\n\r\nconst foo = {\r\n  foo: \"Foo\",\r\n  bar: {\r\n    bar: \"Bar\",\r\n  },\r\n};\r\n\r\nfoo.bar.baz = foo; // 循环引用！\r\nexecRecursively((obj) => console.log(obj), foo);\r\n```\r\n\r\n参考：[#35 ](https://github.com/yanlele/interview-question/issues/35)",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/36/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/36/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/35",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/35/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/35/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/35/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/35",
    "id": 1610219292,
    "node_id": "I_kwDOJCCH1M5f-f8c",
    "number": 35,
    "title": "es6 数据结构 Set 了解多少？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T14:20:02Z",
    "updated_at": "2023-03-05T14:20:02Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## Set \n\n### 基本概念\nSet 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。\n\nSet对象是值的集合，你可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。\n\n另外，NaN 和 undefined 都可以被存储在 Set 中，NaN 之间被视为相同的值（NaN 被认为是相同的，尽管 NaN !== NaN）。\n\n### 有哪些属性和方法\n操作方法：               \n`add(value)`：添加某个值，返回 Set 结构本身。                   \n`delete(value)`：删除某个值，返回一个布尔值，表示删除是否成功。                       \n`has(value)`：返回一个布尔值，表示该值是否为Set的成员。                   \n`clear()`：清除所有成员，没有返回值。\n\n遍历方法：                       \n`keys()`：返回键名的遍历器                     \n`values()`：返回键值的遍历器                   \n`entries()`：返回键值对的遍历器                     \n`forEach()`：使用回调函数遍历每个成员\n`Set.prototype[@@iterator]()`： 返回一个新的迭代器对象，该对象包含 Set 对象中的按插入顺序排列的所有元素的值。\n\n**`Set.prototype[@@iterator]()`** 较为特殊， 细说一下：\n@@iterator 属性的初始值和 values 属性的初始值是同一个函数。\n```js\nconst mySet = new Set();\nmySet.add('0');\nmySet.add(1);\nmySet.add({});\n\nconst setIter = mySet[Symbol.iterator]();\n\nconsole.log(setIter.next().value); // \"0\"\nconsole.log(setIter.next().value); // 1\nconsole.log(setIter.next().value); // Object\n```\n\n### 一些实用场景\n```js\n// 判断是会否属于： B 是否属于 A\nfunction isSuperset(set, subset) {\n    for (let elem of subset) {\n        if (!set.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// 合集\nfunction union(setA, setB) {\n    let _union = new Set(setA);\n    for (let elem of setB) {\n        _union.add(elem);\n    }\n    return _union;\n}\n\n// 交集\nfunction intersection(setA, setB) {\n    let _intersection = new Set();\n    for (let elem of setB) {\n        if (setA.has(elem)) {\n            _intersection.add(elem);\n        }\n    }\n    return _intersection;\n}\n\n// 对称差分\nfunction symmetricDifference(setA, setB) {\n    let _difference = new Set(setA);\n    for (let elem of setB) {\n        if (_difference.has(elem)) {\n            _difference.delete(elem);\n        } else {\n            _difference.add(elem);\n        }\n    }\n    return _difference;\n}\n\n// 属于 A 但是不属于 B\nfunction difference(setA, setB) {\n    let _difference = new Set(setA);\n    for (let elem of setB) {\n        _difference.delete(elem);\n    }\n    return _difference;\n}\n\n//Examples\nlet setA = new Set([1, 2, 3, 4]),\n    setB = new Set([2, 3]),\n    setC = new Set([3, 4, 5, 6]);\n\nisSuperset(setA, setB);          // => true\nunion(setA, setC);               // => Set [1, 2, 3, 4, 5, 6]\nintersection(setA, setC);        // => Set [3, 4]\nsymmetricDifference(setA, setC); // => Set [1, 2, 5, 6]\ndifference(setA, setC);          // => Set [1, 2]\n```\n\n\n## WeakSet \n### 基本概念\nWeakSet 对象允许你将弱保持对象存储在一个集合中。\n\nWeakSet 对象是一些对象值的集合。且其与 Set 类似，WeakSet 中的每个对象值都只能出现一次。在 WeakSet 的集合中，所有对象都是唯一的。\n\n它和 Set 对象的主要区别有：\n\n- WeakSet 只能是对象的集合，而不能像 Set 那样，可以是任何类型的任意值。\n- WeakSet 持弱引用：集合中对象的引用为弱引用。如果没有其它的对 WeakSet 中对象的引用，那么这些对象会被当成垃圾回收掉。\n\n这也意味着 WeakSet 中没有存储当前对象的列表。正因为这样，**WeakSet 是不可枚举的**。\n\n\n## 实例方法\n\n- WeakSet.prototype.add(value): 将 value 添加到 WeakSet 对象最后一个元素的后面。\n\n- WeakSet.prototype.delete(value): 从 WeakSet 中移除 value。此后调用 WeakSet.prototype.has(value) 将返回 false。\n\n- WeakSet.prototype.has(value): 返回一个布尔值，表示 value 是否存在于 WeakSet 对象中。\n\n\n### 使用场景 - 检测循环引用\n```js\n// 对 传入的 subject 对象 内部存储的所有内容执行回调\nfunction execRecursively(fn, subject, _refs = new WeakSet()) {\n  // 避免无限递归\n  if (_refs.has(subject)) {\n    return;\n  }\n\n  fn(subject);\n  if (typeof subject === \"object\") {\n    _refs.add(subject);\n    for (const key in subject) {\n      execRecursively(fn, subject[key], _refs);\n    }\n  }\n}\n\nconst foo = {\n  foo: \"Foo\",\n  bar: {\n    bar: \"Bar\",\n  },\n};\n\nfoo.bar.baz = foo; // 循环引用！\nexecRecursively((obj) => console.log(obj), foo);\n```\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/35/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/35/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/34",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/34/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/34/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/34/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/34",
    "id": 1610209405,
    "node_id": "I_kwDOJCCH1M5f-dh9",
    "number": 34,
    "title": "Proxy 和 Reflect 了解多少？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T13:52:57Z",
    "updated_at": "2023-03-05T13:52:58Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## Proxy\n\n### 基本概念\nProxy(代理) 是 ES6 中新增的一个特性。Proxy 让我们能够以简洁易懂的方式控制外部对对象的访问。其功能非常类似于设计模式中的代理模式。\n使用 Proxy 的好处是：对象只需关注于核心逻辑，一些非核心的逻辑 （如：读取或设置对象的某些属性前记录日志；设置对象的某些属性值前，需要验证；某些属性的访问控制等）可以让 Proxy 来做。 从而达到关注点分离，降级对象复杂度的目的。\n\n### api 有哪些？\n`var p = new Proxy(target, handler);`                   \n其中，target 为被代理对象。handler 是一个对象，其声明了代理 target 的一些操作。p 是代理后的对象。当外界每次对 p 进行操作时，就会执行 handler 对象上的一些方法。\n\nhandler 能代理的一些常用的方法如下：\n- handler.getPrototypeOf(): Object.getPrototypeOf 方法的捕捉器。\n\n- handler.setPrototypeOf(): Object.setPrototypeOf 方法的捕捉器。\n\n- handler.isExtensible(): Object.isExtensible 方法的捕捉器。\n\n- handler.preventExtensions(): Object.preventExtensions 方法的捕捉器。\n\n- handler.getOwnPropertyDescriptor(): Object.getOwnPropertyDescriptor 方法的捕捉器。\n\n- handler.defineProperty(): Object.defineProperty 方法的捕捉器。\n\n- handler.has(): in 操作符的捕捉器。\n\n- handler.get(): 属性读取操作的捕捉器。\n\n- handler.set(): 属性设置操作的捕捉器。\n\n- handler.deleteProperty(): delete 操作符的捕捉器。\n\n- handler.ownKeys(): Object.getOwnPropertyNames 方法和 Object.getOwnPropertySymbols 方法的捕捉器。\n\n- handler.apply(): 函数调用操作的捕捉器。\n\n- handler.construct(): new 操作符的捕捉器。\n...\n  \n### 基础使用\n```javascript\nvar target = {\n   name: 'obj'\n };\n var logHandler = {\n   get: function(target, key) {\n     console.log(`${key} 被读取`);\n     return target[key];\n   },\n   set: function(target, key, value) {\n     console.log(`${key} 被设置为 ${value}`);\n     target[key] = value;\n   }\n };\nvar targetWithLog = new Proxy(target, logHandler);\ntargetWithLog.name;             // 控制台输出：name 被读取\ntargetWithLog.name = 'others';  // 控制台输出：name 被设置为 others\nconsole.log(target.name);       // 控制台输出: others\n```\n\n### 使用示例 - 实现虚拟属性\n```javascript\nvar person = {\n  fisrsName: '张',\n  lastName: '小白'\n};\nvar proxyedPerson = new Proxy(person, {\n  get: function (target, key) {\n    if(key === 'fullName'){\n      return [target.fisrsName, target.lastName].join(' ');\n    }\n    return target[key];\n  },\n  set: function (target, key, value) {\n    if(key === 'fullName'){\n      var fullNameInfo = value.split(' ');\n      target.fisrsName = fullNameInfo[0];\n      target.lastName = fullNameInfo[1];\n    } else {\n      target[key] = value;\n    }\n  }\n});\n\nconsole.log('姓:%s, 名:%s, 全名: %s', proxyedPerson.fisrsName, proxyedPerson.lastName, proxyedPerson.fullName);// 姓:张, 名:小白, 全名: 张 小白\nproxyedPerson.fullName = '李 小露';\nconsole.log('姓:%s, 名:%s, 全名: %s', proxyedPerson.fisrsName, proxyedPerson.lastName, proxyedPerson.fullName);// 姓:李, 名:小露, 全名: 李 小露\n```\n\n### 使用示例 - 实现私有变量\n下面的 demo 实现了真正的私有变量。代理中把以 _ 开头的变量都认为是私有的。                   \n```javascript\nvar api = {\n  _secret: 'xxxx',\n  _otherSec: 'bbb',\n  ver: 'v0.0.1'\n};\n\napi = new Proxy(api, {\n  get: function(target, key) {\n    // 以 _ 下划线开头的都认为是 私有的\n    if (key.startsWith('_')) {\n      console.log('私有变量不能被访问');\n      return false;\n    }\n    return target[key];\n  },\n  set: function(target, key, value) {\n    if (key.startsWith('_')) {\n      console.log('私有变量不能被修改');\n      return false;\n    }\n    target[key] = value;\n  },\n  has: function(target, key) {\n    return key.startsWith('_') ? false : (key in target);\n  }\n});\n\napi._secret; // 私有变量不能被访问\nconsole.log(api.ver); // v0.0.1\napi._otherSec = 3; // 私有变量不能被修改\nconsole.log('_secret' in api); //false\nconsole.log('ver' in api); //true\n```\n\n### 使用示例 - 抽离校验模块\n```javascript\nfunction Animal() {\n  return createValidator(this, animalValidator);\n}\nvar animalValidator = {\n  name: function(name) {\n    // 动物的名字必须是字符串类型的\n    return typeof name === 'string';\n  }\n};\n\nfunction createValidator(target, validator) {\n  return new Proxy(target, {\n    set: function(target, key, value) {\n      if (validator[key]) {\n        // 符合验证条件\n        if (validator[key](value)) {\n          target[key] = value;\n        } else {\n          throw Error(`Cannot set ${key} to ${value}. Invalid.`);\n        }\n      } else {\n        target[key] = value\n      }\n    }\n  });\n}\n\nvar dog = new Animal();\ndog.name = 'dog';\nconsole.log(dog.name);\ndog.name = 123; // Uncaught Error: Cannot set name to 123. Invalid.\n```\n\n## Reflect\n\n### 概念\nReflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。**这些方法与 `proxy handler` 的方法相同**。Reflect 不是一个函数对象，因此它是不可构造的。\n\n与大多数全局对象不同 Reflect 并非一个构造函数，所以不能通过 new 运算符对其进行调用，或者将 Reflect 对象作为一个函数来调用。**Reflect 的所有属性和方法都是静态的**（就像 Math 对象）。\n\n### api 有哪些？\n- Reflect.apply(target, thisArgument, argumentsList): 对一个函数进行调用操作，同时可以传入一个数组作为调用参数。和 Function.prototype.apply() 功能类似。\n    - 举例\n    ```javascript\n    const ages = [11, 33, 12, 54, 18, 96];\n    \n    // 旧写法\n    const youngest = Math.min.apply(Math, ages);\n    const oldest = Math.max.apply(Math, ages);\n    const type = Object.prototype.toString.call(youngest);\n    \n    // 新写法\n    const youngest = Reflect.apply(Math.min, Math, ages);\n    const oldest = Reflect.apply(Math.max, Math, ages);\n    const type = Reflect.apply(Object.prototype.toString, youngest, []);\n    ```\n\n- Reflect.construct(target, argumentsList[, newTarget]): 对构造函数进行 new 操作，相当于执行 new target(...args)。\n    - Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。\n    ```javascript\n    function Greeting(name) {\n      this.name = name;\n    }\n    \n    // new 的写法\n    const instance = new Greeting('张三');\n    \n    // Reflect.construct 的写法\n    const instance = Reflect.construct(Greeting, ['张三']);\n    ```\n\n- Reflect.defineProperty(target, propertyKey, attributes): 和 Object.defineProperty() 类似。如果设置成功就会返回 true\n\n- Reflect.deleteProperty(target, propertyKey): 作为函数的delete操作符，相当于执行 delete target[name]。该方法返回一个布尔值。\n    - Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象属性。\n    ```javascript\n    const myObj = { foo: 'bar' };\n    \n    // 旧写法\n    delete myObj.foo;\n    \n    // 新写法\n    Reflect.deleteProperty(myObj, 'foo');\n    ```\n    该方法返回一个布尔值。如果删除成功或删除的属性不存在，则返回true，如果删除失败，删除的属性依然还在，则返回false。\n\n- Reflect.get(target, propertyKey[, receiver]): 获取对象身上某个属性的值，类似于 target[name]。\n    - Reflect.get方法查找并返回target的name属性，如果没有，则返回undefined。\n    ```javascript\n    var myObject = {\n      foo: 1,\n      bar: 2,\n      get baz() {\n        return this.foo + this.bar;\n      },\n    }\n    \n    Reflect.get(myObject, 'foo') // 1\n    Reflect.get(myObject, 'bar') // 2\n    Reflect.get(myObject, 'baz') // 3\n    ```\n  \n    - 读取函数的this绑定的receiver\n    ```js\n    var myObject = {\n      foo: 1,\n      bar: 2,\n      get baz() {\n        return this.foo + this.bar;\n      },\n    };\n    \n    var myReceiverObject = {\n      foo: 4,\n      bar: 4,\n    };\n    \n    Reflect.get(myObject, 'baz', myReceiverObject) // 8\n    ```\n  \n    - 如果第一个参数不是对象，则Reflect.get则会报错。 \n\n\n- Reflect.getOwnPropertyDescriptor(target, propertyKey): 类似于 Object.getOwnPropertyDescriptor()。如果对象中存在该属性，则返回对应的属性描述符，否则返回 undefined。\n\n- Reflect.getPrototypeOf(target): 类似于 Object.getPrototypeOf()。\n\n- Reflect.has(target, propertyKey): 判断一个对象是否存在某个属性，和 in 运算符 的功能完全相同。\n    - Reflect.has对应 name in obj 里面的in操作\n    ```javascript\n    var myObject = {\n      foo: 1,\n    };\n    \n    // 旧写法\n    'foo' in myObject // true\n    \n    // 新写法\n    Reflect.has(myObject, 'foo') // true\n    ```\n    如果第一个参数不是对象，Reflect.has和in都会报错。\n\n- Reflect.isExtensible(target): 类似于 Object.isExtensible().\n\n- Reflect.ownKeys(target): 返回一个包含所有自身属性（不包含继承属性）的数组。(类似于 Object.keys(), 但不会受enumerable 影响).\n\n- Reflect.preventExtensions(target): 类似于 Object.preventExtensions()。返回一个Boolean。\n\n- Reflect.set(target, propertyKey, value[, receiver]): 将值分配给属性的函数。返回一个Boolean，如果更新成功，则返回true。\n    - Reflect.set方法设置target对象的name属性等于value。\n    ```javascript\n    var myObject = {\n        foo: 1,\n        set bar(value) {\n          return this.foo = value;\n        },\n    }\n    \n    myObject.foo // 1\n    \n    Reflect.set(myObject, 'foo', 2);\n    myObject.foo // 2\n    \n    Reflect.set(myObject, 'bar', 3)\n    myObject.foo // 3\n    ```\n  \n    - 如果name属性设置的赋值函数，则赋值函数的this绑定receiver。\n    ```javascript\n    var myObject = {\n        foo: 4,\n        set bar(value) {\n          return this.foo = value;\n        },\n    };\n    \n    var myReceiverObject = {\n      foo: 0,\n    };\n    \n    Reflect.set(myObject, 'bar', 1, myReceiverObject);\n    myObject.foo // 4\n    myReceiverObject.foo // 1\n    ```\n\n- Reflect.setPrototypeOf(target, prototype): 设置对象原型的函数。返回一个 Boolean，如果更新成功，则返回 true。\n\n\n\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/34/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/34/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/33",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/33/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/33/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/33/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/33",
    "id": 1610191698,
    "node_id": "I_kwDOJCCH1M5f-ZNS",
    "number": 33,
    "title": "call、apply、bind 的区别和用法？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T13:01:56Z",
    "updated_at": "2023-03-05T13:06:33Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "call、apply 和 bind 都是 JavaScript 中用于改变函数执行上下文（即 this 指向）的方法，它们的区别和用法如下：\r\n\r\n## call\r\ncall 方法可以改变函数的 this 指向，同时还能传递多个参数。\r\n**call 方法的语法如下：**\r\n```js\r\nfun.call(thisArg, arg1, arg2, ...)\r\n```\r\nfun：要调用的函数。\r\nthisArg：函数内部 this 指向的对象。\r\narg1, arg2, ...：传递给函数的参数列表。\r\n\r\n\r\n**call 方法的使用示例：**\r\n```js\r\nconst person = {\r\n  name: 'Alice',\r\n  sayHello: function () {\r\n    console.log(`Hello, ${this.name}!`)\r\n  },\r\n}\r\n\r\nconst person2 = {\r\n  name: 'Bob',\r\n}\r\n\r\nperson.sayHello.call(person2) // 输出：Hello, Bob!\r\n```\r\n\r\n## apply\r\napply 方法和 call 方法类似，它也可以改变函数的 this 指向，但是它需要传递一个数组作为参数列表。\r\n**apply 方法的语法如下：**\r\n```js\r\nfun.apply(thisArg, [argsArray])\r\n```\r\nfun：要调用的函数。\r\nthisArg：函数内部 this 指向的对象。\r\nargsArray：传递给函数的参数列表，以数组形式传递。\r\n\r\n**apply 方法的使用示例：**\r\n```js\r\nconst person = {\r\n  name: 'Alice',\r\n  sayHello: function (greeting) {\r\n    console.log(`${greeting}, ${this.name}!`)\r\n  },\r\n}\r\n\r\nconst person2 = {\r\n  name: 'Bob',\r\n}\r\n\r\nperson.sayHello.apply(person2, ['Hi']) // 输出：Hi, Bob!\r\n```\r\n\r\n## bind\r\nbind 方法和 call、apply 方法不同，它并不会立即调用函数，而是返回一个新的函数，这个新函数的 this 指向被绑定的对象。\r\n**bind 方法的语法如下：**\r\n\r\n```js\r\nfun.bind(thisArg[, arg1[, arg2[, ...]]])\r\n```\r\nfun：要调用的函数。\r\nthisArg：函数内部 this 指向的对象。\r\narg1, arg2, ...：在调用函数时，绑定到函数参数的值。\r\n\r\n**bind 方法的使用示例：**\r\n```js\r\nconst person = {\r\n  name: 'Alice',\r\n  sayHello: function () {\r\n    console.log(`Hello, ${this.name}!`)\r\n  },\r\n}\r\n\r\nconst person2 = {\r\n  name: 'Bob',\r\n}\r\n\r\nconst sayHelloToBob = person.sayHello.bind(person2)\r\nsayHelloToBob() // 输出：Hello, Bob!\r\n```\r\n\r\n**参数传递**\r\n在使用 bind 方法时，我们可以通过传递参数来预先填充函数的一些参数，这样在调用函数时只需要传递剩余的参数即可。\r\n```js\r\nconst person = {\r\n  name: 'Alice',\r\n  sayHello: function (greeting, punctuation) {\r\n    console.log(`${greeting}, ${this.name}, ${punctuation}`)\r\n  },\r\n}\r\n\r\nconst person2 = {\r\n  name: 'Bob',\r\n}\r\n\r\nconst sayHelloToBob = person.sayHello.bind(person2);\r\n\r\nsayHelloToBob(1,2); // 输出：1, Bob, 2\r\n```\r\n\r\n**再举一个例子：**\r\n```js\r\nthis.x = 9;    // 在浏览器中，this 指向全局的 \"window\" 对象\r\nvar module = {\r\n  x: 81,\r\n  getX: function() { return this.x; }\r\n};\r\n\r\nmodule.getX(); // 81\r\n\r\nvar retrieveX = module.getX;\r\nretrieveX();\r\n// 返回 9 - 因为函数是在全局作用域中调用的\r\n\r\n// 创建一个新函数，把 'this' 绑定到 module 对象\r\n// 新手可能会将全局变量 x 与 module 的属性 x 混淆\r\nvar boundGetX = retrieveX.bind(module);\r\nboundGetX(); // 81\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/33/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/33/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/32",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/32/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/32/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/32/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/32",
    "id": 1610186453,
    "node_id": "I_kwDOJCCH1M5f-X7V",
    "number": 32,
    "title": "let 和 const 与 var 的区别？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T12:45:39Z",
    "updated_at": "2023-03-05T12:45:39Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## let 和 const 与 var 的区别\n\n1、不存在变量提升                                                  \n必须先定义后使用，否则报错\n\n2、暂时性死区                     \n在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。\n\n3、不允许重复申明/不允许在函数内部重新申明参数（也算重复申明）\n\n4.1 SE5的作用域                     \n1）、内层变量覆盖外层的变量                                  \n2）、用来计数的循环变量会泄露为全局变量\n\n5、const是一个常量，一旦申明，就不能改变。而且在申明的时候必须初始化，不能留到后面赋值。\n\n6、在ES5里面，未申明的全局变量会自动生为window的属性:                            \n没法在编译过程爆出变量为申明的错误，语法上顶层对象有一个实体含义的对象这样肯定不合适。                             \n用var定义的依然会升级为顶层对象(全局对象)window的属性；但是let,const申明则不会。\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/32/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/32/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/31",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/31/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/31/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/31/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/31",
    "id": 1610185431,
    "node_id": "I_kwDOJCCH1M5f-XrX",
    "number": 31,
    "title": "常见数组排序算法有哪些？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T12:42:26Z",
    "updated_at": "2023-03-05T12:42:27Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 常见排序算法中，时间复杂度和空间复杂度是怎样的？\n如图所示：\n![01_10](https://user-images.githubusercontent.com/22188674/222961047-79023840-bd63-4a2c-93fe-2d94f2a8ac04.png)\n\n## 快速排序：\n先从数列中取出一个数作为“基准”。\n\n分区过程：将比这个“基准”大的数全放到“基准”的右边，小于或等于“基准”的数全放到“基准”的左边。\n再对左右区间重复第二步，直到各区间只有一个数。\n```javascript\nvar quickSort = function(arr) {\n    if (arr.length <= 1) { return arr; }\n    var pivotIndex = Math.floor(arr.length / 2);   //基准位置（理论上可任意选取）\n    var pivot = arr.splice(pivotIndex, 1)[0];  //基准数\n    var left = [];\n    var right = [];\n    for (var i = 0; i < arr.length; i++){\n        if (arr[i] < pivot) {\n            left.push(arr[i]);\n        } else {\n            right.push(arr[i]);\n        }\n    }\n    return quickSort(left).concat([pivot], quickSort(right));  //链接左数组、基准数构成的数组、右数组\n};\n```\n\n\n## 选择排序：\n首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置                     \n再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。                     \n重复第二步，直到所有元素均排序完毕。\n```javascript\nfunction selectionSort(arr) {\n    var len = arr.length;\n    var minIndex, temp;\n    for (var i = 0; i < len - 1; i++) {\n        minIndex = i;\n        for (var j = i + 1; j < len; j++) {\n            if (arr[j] < arr[minIndex]) {     // 寻找最小的数\n                minIndex = j;                 // 将最小数的索引保存\n            }\n        }\n        temp = arr[i];\n        arr[i] = arr[minIndex];\n        arr[minIndex] = temp;\n    }\n    return arr;\n}\n```\n\n## 插入排序：\n将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。                    \n从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n```javascript\nfunction insertionSort(arr) {\n    var len = arr.length;\n    var preIndex, current;\n    for (var i = 1; i < len; i++) {\n        preIndex = i - 1;\n        current = arr[i];\n        while(preIndex >= 0 && arr[preIndex] > current) {\n            arr[preIndex+1] = arr[preIndex];\n            preIndex--;\n        }\n        arr[preIndex+1] = current;\n    }\n    return arr;\n}\n```\n\n## 冒泡法排序：\n比较相邻的元素。如果第一个比第二个大，就交换他们两个。             \n对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。                            \n针对所有的元素重复以上的步骤，除了最后一个。                  \n持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n```javascript\nfunction bubbleSort(arr) {\n    var len = arr.length;\n    for (var i = 0; i < len - 1; i++) {\n        for (var j = 0; j < len - 1 - i; j++) {\n            if (arr[j] > arr[j+1]) {        // 相邻元素两两对比\n                var temp = arr[j+1];        // 元素交换\n                arr[j+1] = arr[j];\n                arr[j] = temp;\n            }\n        }\n    }\n    return arr;\n}\n```\n\n## 希尔排序\n1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。\n它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。\n\n先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：                                 \n选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；                                    \n按增量序列个数k，对序列进行k 趟排序；                                    \n每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。\n仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n```javascript\nfunction shellSort(arr) {\n    var len = arr.length,\n        temp,\n        gap = 1;\n    while (gap < len / 3) {          // 动态定义间隔序列\n        gap = gap * 3 + 1;\n    }\n    for (gap; gap > 0; gap = Math.floor(gap / 3)) {\n        for (var i = gap; i < len; i++) {\n            temp = arr[i];\n            for (var j = i-gap; j > 0 && arr[j]> temp; j-=gap) {\n                arr[j + gap] = arr[j];\n            }\n            arr[j + gap] = temp;\n        }\n    }\n    return arr;\n}\n```\n\n## 归并排序\n直接上代码了\n```js\nfunction mergeSort(arr){\n    var len = arr.length;\n    if(len <2)\n        return arr;\n    var mid = Math.floor(len/2),\n        left = arr.slice(0,mid),\n        right =arr.slice(mid);\n    //send left and right to the mergeSort to broke it down into pieces\n    //then merge those\n    return merge(mergeSort(left),mergeSort(right));\n}\n\nfunction merge(left, right){\n    var result = [],\n        lLen = left.length,\n        rLen = right.length,\n        l = 0,\n        r = 0;\n    while(l < lLen && r < rLen){\n        if(left[l] < right[r]){\n            result.push(left[l++]);\n        }\n        else{\n            result.push(right[r++]);\n        }\n    }\n    //remaining part needs to be addred to the result\n    return result.concat(left.slice(l)).concat(right.slice(r));\n}\n```\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/31/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/31/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/30",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/30/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/30/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/30/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/30",
    "id": 1610079701,
    "node_id": "I_kwDOJCCH1M5f993V",
    "number": 30,
    "title": "WebSocket 了解多少？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T06:46:08Z",
    "updated_at": "2023-03-05T06:46:09Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 基本概念\n\nWebSocket 是一种基于 TCP 协议的网络通信协议，可以在客户端和服务器之间进行双向通信。相比传统的 HTTP 请求，WebSocket 具有更低的延迟和更高的效率。但是，由于同源策略的限制，**WebSocket 也会受到跨域问题的影响。**\n\nWebSocket 通过在客户端和服务器之间建立持久连接来解决跨域问题。WebSocket 的握手过程与 HTTP 协议相似，客户端首先通过 HTTP 请求与服务器建立连接，然后服务器返回一个握手响应，表示连接已经建立成功。**在握手完成后，客户端和服务器之间就可以通过该连接进行双向通信，不受同源策略的限制。**\n\n需要注意的是，WebSocket 协议本身并没有限制跨域请求，**但是在实际使用中，服务器通常会限制 WebSocket 连接的来源**。这是出于安全性考虑，避免恶意网站通过 WebSocket 连接获取敏感信息。因此，在使用 WebSocket 进行跨域通信时，需要确保服务器允许来自指定域名或 IP 地址的连接。\n\n\n## WebSocket 同源限制是啥？\n\nWebSocket 通信协议本身不受同源策略限制，因为 WebSocket 是一个独立的协议。但是在建立 WebSocket 连接时，需要进行握手，握手时会发送 HTTP 请求头，因此受到同源策略的限制。需要满足以下条件才能建立 WebSocket 连接：\n\n- 协议头必须为 \"ws://\" 或 \"wss://\"（安全的 WebSocket）\n\n- 域名和端口必须与当前网页完全一致\n\n如果以上条件不满足，浏览器将不允许建立 WebSocket 连接。\n\n\n## 关于请求头的问题\n在建立WebSocket连接时，需要添加`Upgrade`头和`Connection`头，其中Upgrade头指明这是一个WebSocket请求，Connection头指明连接方式为升级连接（upgrade）。\n服务器如果同意升级，则会返回 101 状态码，表示升级成功，此时 WebSocket 连接建立成功，双方就可以通过该连接进行双向通信。这个过程与同源策略无关，因此 WebSocket 不会受到同源策略的限制。\n\nnew WebSocket(url) 创建 WebSocket 对象时，会自动添加 Upgrade 头和 Connection 头。这是因为在 WebSocket 协议中，这两个头部是必需的，用于告知服务器客户端希望建立 WebSocket 连接。\n示例代码如下：\n```js\nconst socket = new WebSocket('ws://localhost:8080');\n```\n\n此外，在WebSocket请求中也可以添加一些自定义的请求头，例如：\n```js\nconst socket = new WebSocket('ws://localhost:8080', {\n  headers: {\n    'X-Custom-Header': 'hello',\n    'Y-Custom-Header': 'world'\n  }\n});\n```\n\n\n## 建立一个 WebSocket 连接需要以下步骤：\n**1. 创建一个 WebSocket 对象**\n```js\nconst socket = new WebSocket('ws://localhost:8080');\n```\n\n**2. 监听 WebSocket 事件**\nWebSocket 对象是一个 EventTarget 对象，它可以监听多个事件。常见的事件有 open、message、error 和 close。\n\n- open 事件：WebSocket 连接建立成功时触发。\n```js\nsocket.addEventListener('open', event => {\n  console.log('WebSocket 连接已建立');\n});\n```\n\n- message 事件：WebSocket 收到消息时触发。\n```js\nsocket.addEventListener('message', event => {\n  console.log(`收到消息：${event.data}`);\n});\n```\n\n- error 事件：WebSocket 连接出错时触发。\n```js\nsocket.addEventListener('error', event => {\n  console.error('WebSocket 连接出错', event);\n});\n```\n\n- close 事件：WebSocket 连接关闭时触发。\n```js\nsocket.addEventListener('close', event => {\n  console.log('WebSocket 连接已关闭');\n});\n```\n\n以上是建立 WebSocket 连接的基本步骤。需要注意的是，在使用 WebSocket 协议时，服务器端也需要提供相应的支持。\n\n## 服务端支持\n要支持 WebSocket，服务器需要在接收到客户端 WebSocket 握手请求时，返回符合 WebSocket 协议规范的响应。在 Node.js 中，我们可以使用 ws 模块来实现 WebSocket 服务器。以下是一个简单的 WebSocket 服务器的示例代码：\n```js\nconst WebSocket = require('ws');\n\nconst server = new WebSocket.Server({ port: 8080 });\n\nserver.on('connection', (socket) => {\n  console.log('Client connected');\n\n  socket.on('message', (message) => {\n    console.log(`Received message: ${message}`);\n\n    // Echo the message back to the client\n    socket.send(`Echo: ${message}`);\n  });\n\n  socket.on('close', () => {\n    console.log('Client disconnected');\n  });\n});\n```\n\n需要注意的是，在生产环境中，我们需要使用 HTTPS 协议来保证 WebSocket 的安全性。同时，我们还需要注意处理异常情况，例如客户端断开连接等。\n\n其中 `ws` 不是 Node.js 的内置模块，它是一个第三方模块，可以使用 npm 安装。在 Node.js 应用中使用 WebSocket 时，需要先安装 ws 模块。可以使用以下命令进行安装：\n```\nnpm install ws\n```\n\n## 服务端如何限制链接源？\n在 WebSocket 建立连接的时候，可以通过检查请求的 Origin 头部信息来限制访问源。下面是一个简单的 Node.js 示例代码：\n```js\nconst WebSocket = require('ws');\nconst server = new WebSocket.Server({ port: 8080 });\n\nserver.on('connection', (ws, req) => {\n  const { origin } = req.headers;\n  // 判断请求的 origin 是否允许连接\n  if (origin === 'https://www.example.com') {\n    // 允许连接\n    console.log('Connection allowed from', origin);\n    ws.send('Connection allowed');\n  } else {\n    // 拒绝连接\n    console.log('Connection refused from', origin);\n    ws.close();\n  }\n});\n```\n\n## \"ws://\" 与 \"wss://\" 有啥区别？\n\"ws://\" 和 \"wss://\" 都是 WebSocket 协议的 URL 前缀，它们之间的区别在于传输层协议的不同。\n\n\"ws://\" 使用的是普通的 HTTP 协议作为传输层协议，在传输过程中数据是明文的，容易被中间人攻击篡改数据，存在安全风险。\n\n\"wss://\" 使用的是加密的 SSL/TLS 协议作为传输层协议，在传输过程中数据是加密的，更加安全。但是因为要进行 SSL/TLS 握手等复杂过程，所以 \"wss://\" 的连接建立时间和数据传输速度会比 \"ws://\" 慢一些。\n\n因此，如果数据传输需要保密性，建议使用 \"wss://\"，否则可以使用 \"ws://\"。\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/30/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/30/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/29",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/29/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/29/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/29/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/29",
    "id": 1610073368,
    "node_id": "I_kwDOJCCH1M5f98UY",
    "number": 29,
    "title": "postMessage 是如何解决跨域问题的？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T06:16:18Z",
    "updated_at": "2023-03-05T06:16:19Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 基本概念\n\npostMessage 是 HTML5 提供的一种跨窗口通信机制，可以在不同窗口、甚至不同域名之间进行通信，从而实现跨域通信。通过在一个窗口中调用 postMessage 方法向另一个窗口发送消息，接收窗口可以监听 message 事件，以接收发送过来的消息。\n\n使用 postMessage 可以解决一些跨域问题，如在一个域名下的网页与其他域名下的网页进行通信。具体来说，当两个窗口的协议、主机名或端口不同时，就会发生跨域问题。但使用 postMessage 可以突破同源策略的限制，实现不同域之间的通信。\n\n一般情况下，为了保证安全，使用 postMessage 进行跨域通信时，需要在目标窗口中设置 window.postMessage 的接收地址，只有来自该地址的消息才能被接收，从而避免了安全问题。同时，可以使用 origin 参数来限制消息来源，避免恶意攻击。\n\n## 代码举例\n\n假设我们有两个域名为 https://domain-a.com 和 https://domain-b.com 的网站，现在需要在这两个网站之间进行跨域通信。\n\n在 https://domain-a.com 的页面中，我们可以使用以下代码向 https://domain-b.com 发送一条消息：\n\n```js\nconst targetOrigin = \"https://domain-b.com\";\nconst message = \"Hello, domain-b!\";\n\nwindow.parent.postMessage(message, targetOrigin);\n```\n\n这里的 window.parent 表示当前页面所在窗口的父级窗口，即指向 https://domain-a.com 的窗口对象。\n\n在 https://domain-b.com 的页面中，我们可以使用以下代码监听消息并做出相应处理：\n```js\nwindow.addEventListener(\"message\", event => {\n  const origin = event.origin; // 发送消息的域名\n  const data = event.data; // 消息内容\n\n  if (origin === \"https://domain-a.com\") {\n    console.log(\"Received message from domain-a:\", data);\n  }\n});\n```\n\n使用 postMessage 进行跨域通信需要注意安全问题，特别是在确定目标域名时应该使用固定的字符串而不是动态生成的值，以避免被攻击者利用。\n\n## iframe 是否可以使用 postMessage 通信？\n不同的 iframe 和同一个页面之间也可以通过 postMessage 方法进行通信。这种情况下，通信的流程和同一页面中不同窗口的通信流程基本相同。只不过发送方和接收方不在同一页面中，而是在不同的 iframe 中。假设页面 A 中有两个 iframe，一个是 B 页面，另一个是 C 页面，现在需要在这两个 iframe 之间进行通信，具体的实现过程如下：\n\n在 B 页面的脚本中使用 postMessage 方法向父级页面 A 发送消息：\n```js\nwindow.parent.postMessage('message from B', 'http://localhost:3000');\n```\n\n在 C 页面的脚本中使用 postMessage 方法向父级页面 A 发送消息：\n```js\nwindow.parent.postMessage('message from C', 'http://localhost:3000');\n```\n\n在页面 A 的脚本中监听 message 事件，接收来自不同 iframe 的消息：\n```js\nwindow.addEventListener('message', function(event) {\n  // 判断消息来源是否是指定的 iframe\n  if (event.origin === 'http://localhost:3000') {\n    console.log('Received message: ' + event.data);\n  }\n});\n```\n\n需要注意的是，在这个过程中，B 和 C 两个 iframe 都需要和父级页面 A 都处于同一域名下，否则会触发跨域安全限制。\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/29/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/29/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/28",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/28/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/28/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/28/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/28",
    "id": 1610071472,
    "node_id": "I_kwDOJCCH1M5f972w",
    "number": 28,
    "title": "CORS 是如何实现跨域的？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T06:07:54Z",
    "updated_at": "2023-03-05T06:07:55Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## cors 的基本概念\n\nCORS（Cross-Origin Resource Sharing，跨域资源共享）是一种用于让浏览器绕过同源策略限制，实现跨域访问资源的机制。在浏览器端，JavaScript 的跨域请求必须要经过浏览器的同源策略限制，即只能向同一域名下的服务器发送请求，而不能向其它域名的服务器发送请求。CORS 提供了一种通过在服务端设置响应头的方式来实现浏览器端跨域请求的机制。\n\n**基本概念有哪些？**\n1. 预检请求（Preflight Request）：在实际请求之前，浏览器会发送一个预检请求OPTIONS，来确认服务端是否接受实际请求。\n\n2. 简单请求（Simple Request）：满足以下条件的请求为简单请求：请求方法为GET、HEAD或POST；HTTP头信息不超出Accept、Accept-Language、Content-Language、Content-Type、Last-Event-ID、DPR、Save-Data、Viewport-Width、Width；Content-Type的值仅限于text/plain、multipart/form-data、application/x-www-form-urlencoded。\n\n3. 非简单请求（Non-simple Request）：不满足简单请求条件的请求。\n\n4. CORS安全规则（CORS Safelisting Rules）：指的是CORS中服务端响应的Access-Control-Allow-Origin，指定是否允许跨域请求的源。\n\n5. withCredentials：指的是XMLHttpRequest中的一个属性，用于在请求中携带cookie信息。\n\n6. 暴露Header（Exposed Headers）：在CORS响应中，Access-Control-Expose-Headers头用于暴露哪些响应头给客户端使用。\n\n7. 存储 Cookies（Cookie Storage）：跨域请求中，浏览器默认不会发送cookie信息，需要在服务端设置Access-Control-Allow-Credentials和客户端设置withCredentials为true才能实现。\n\n8. 跨域请求中的安全问题（CORS Security Issues）：CORS的出现，引入了一些安全问题，例如CSRF、XSS等，需要在开发中做好防范措施。\n\n## 如何实现跨域请求？\n在 HTTP 请求中，使用了 CORS 标准头部来告诉浏览器该请求是跨域请求，并且在服务端设置 Access-Control-Allow-Origin 头部来允许指定的域名访问资源。\n\n**客户端 CORS 标准头部有以下几个：**\n\n- Origin：表示请求来自哪个域名。\n- Access-Control-Request-Method：表示请求的方法类型（比如 GET、POST 等）。\n- Access-Control-Request-Headers：表示请求头中的额外信息（比如 Content-Type 等）。\n\n\n**服务端返回的响应头部有以下几个：**\n\n- Access-Control-Allow-Origin：表示允许的域名访问该资源，可以设置为 * 表示任何域名都可以访问。\n- Access-Control-Allow-Credentials：表示是否允许浏览器携带 Cookie 和认证信息等，默认为 false。\n- Access-Control-Allow-Methods：表示允许的请求方法类型。\n- Access-Control-Allow-Headers：表示允许的请求头中的额外信息。\n\n通过在服务端设置这些头部，可以实现跨域请求的授权和安全验证。\n\n\n## 预检请求 作用是啥？\n预检请求（Preflight Request）是CORS中的一种特殊请求，主要用于在实际请求之前，增加一次HTTP查询请求，以检查实际请求是否可以被服务器接受。\n\n在CORS中，有些HTTP请求是简单请求（Simple Request），比如GET和POST请求，可以直接发送。而对于一些复杂请求，比如请求方法为PUT、DELETE、PATCH等，或者Content-Type类型为application/json、application/xml等，会在发送真正请求之前，增加一次HTTP查询请求，以便服务器能够知道是否允许该请求。这个查询请求就是预检请求，用来查询服务器是否支持该请求，并给出支持的条件。\n\n预检请求中包含了一些额外的HTTP头信息，比如Origin、Access-Control-Request-Method、Access-Control-Request-Headers等，这些信息告诉服务器实际请求中会包含哪些信息，并请求服务器在实际请求中是否能够接受这些信息。\n\n服务器接收到预检请求后，会根据请求头中的信息来判断是否允许实际请求。如果允许，会在响应头中加入一些额外的信息，比如Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers等，告诉浏览器实际请求可以被接受。如果不允许，则不会发送实际请求，而是直接返回一个错误响应。\n\n## 如何避免 cors 中的一些安全问题？\n\n在CORS中有一些安全问题，例如CSRF（跨站点请求伪造）攻击和CORS劫持。以下是避免这些问题的一些方法：\n\n1. CSRF攻击：使用CSRF令牌来验证请求，这样只有在正确的来源站点上发出的请求才会被视为有效请求。\n\n2. CORS劫持：在响应中添加Access-Control-Allow-Origin标头，并设置为信任的站点。另外，也可以使用Content-Security-Policy标头来限制JavaScript的执行。\n\n3. 永远不要在CORS请求中使用敏感凭据（例如Cookie和HTTP身份验证信息）。\n\n4. 限制跨域请求的范围，只允许特定的来源站点。\n\n5. 在服务器上使用防火墙和其他安全措施来保护应用程序，例如SSL / TLS加密，HTTP Strict Transport Security（HSTS）等。\n\n总之，应该采取适当的安全措施来防止CORS相关的安全问题。\n\n\n\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/28/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/28/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/27",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/27/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/27/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/27/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/27",
    "id": 1610069084,
    "node_id": "I_kwDOJCCH1M5f97Rc",
    "number": 27,
    "title": "JSONP 是如何实现跨域的?",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T05:57:36Z",
    "updated_at": "2023-03-05T05:57:36Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## JSONP\n\nJSONP 的实现原理是通过添加一个 script 标签，指定 src 属性为跨域请求的 URL，而这个 URL 返回的不是 JSON 数据，而是一段可执行的 JavaScript 代码，这段代码会调用一个指定的函数，并且将 JSON 数据作为参数传入函数中。\n\n例如，假设我们从 http://example.com 域名下请求数据，我们可以通过在 http://example.com 中添加如下代码实现 JSONP 请求：\n\n```js\nfunction handleData(data) {\n  // 处理获取到的数据\n}\n\nconst script = document.createElement('script');\nscript.src = 'http://example.org/api/data?callback=handleData';\ndocument.head.appendChild(script);\n```\n\n其中，我们指定了一个名为 `handleData` 的回调函数，并将这个函数名作为参数传递给了跨域请求的 URL 中的 callback 参数。服务器端返回的数据将会被包装在这个回调函数中，例如：\n```js\nhandleData({\"name\": \"John\", \"age\": 30});\n```\n\n在这个例子中，我们可以在 handleData 函数中处理获取到的数据。需要注意的是，在使用 JSONP 时，**需要保证服务器端返回的数据是一个可执行的 JavaScript 代码，并且必须使用指定的回调函数名来包装数据，否则无法正确处理数据。**\n\n### 如何获取 jsonp 的相应参数\n\n获取 JSONP 响应结果的方法有两种，**一种是通过回调函数参数获取**，**另一种是通过 script 标签加载完成后解析全局变量获取**。\n\n假设服务器返回以下 JSONP 响应：\n\n```js\ncallback({\"name\": \"Alice\", \"age\": 20});\n```\n\n其中 callback 是客户端定义的回调函数名，用于指定返回数据的处理方式。\n\n我们可以使用以下两种方式获取响应结果：\n\n**1. 通过回调函数参数获取**\n在客户端定义一个全局函数作为回调函数，服务器返回的数据会作为回调函数的参数传入，这个参数可以在回调函数中处理。\n```js\nfunction handleResponse(data) {\n  console.log(data.name); // Alice\n  console.log(data.age); // 20\n}\n\n// 创建 script 标签\nconst script = document.createElement('script');\nscript.src = 'http://example.com/api?callback=handleResponse';\n\n// 插入到文档中开始加载数据\ndocument.body.appendChild(script);\n```\n\n**2. 通过全局变量获取**\n在客户端定义一个全局函数作为回调函数，服务器返回的数据会作为一个全局变量赋值给该函数所在的对象，我们可以在 script 标签加载完成后解析全局变量获取响应结果。\n```js\nfunction handleResponse() {\n  console.log(myData.name); // Alice\n  console.log(myData.age); // 20\n}\n\n// 创建 script 标签\nconst script = document.createElement('script');\nscript.src = 'http://example.com/api?callback=handleResponse';\n\n// 插入到文档中开始加载数据\ndocument.body.appendChild(script);\n\n// script 标签加载完成后解析全局变量\nwindow.myData = {};\nscript.onload = () => {\n  delete window.myData; // 删除全局变量\n};\n```\n\n注意，使用 JSONP 时要注意安全问题，应该对返回的数据进行验证，避免接收到恶意代码。此外，JSONP **只能发送 GET 请求**，无法发送 POST 请求，**也无法使用 HTTP 请求头和请求体传递数据**。\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/27/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/27/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/26",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/26/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/26/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/26/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/26",
    "id": 1610068701,
    "node_id": "I_kwDOJCCH1M5f97Ld",
    "number": 26,
    "title": "跨域通信的常见方式有哪些?",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T05:55:50Z",
    "updated_at": "2023-03-05T07:03:52Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 常见方式\r\n\r\n**JSONP**\r\nJSONP是通过动态创建script标签的方式，利用script标签可以跨域请求资源的特性来实现的，本质是利用了script标签没有跨域限制的特性，可以在请求的url后加一个callback参数，后端接收到请求后，将需要传递的数据作为参数传递到callback函数中，前端定义该函数来接收数据，从而实现跨域通信。\r\n[#27 ](https://github.com/yanlele/interview-question/issues/27)\r\n\r\n\r\n**CORS**\r\nCORS是一种现代浏览器支持的跨域解决方案，CORS全称为跨域资源共享（Cross-Origin Resource Sharing），其本质是在服务端设置允许跨域访问的响应头，浏览器通过判断响应头中是否允许跨域访问来决定是否允许跨域访问。\r\n[#28 ](https://github.com/yanlele/interview-question/issues/28)\r\n\r\n**postMessage**\r\npostMessage是HTML5引入的一种新的跨域通信方式，主要是用于在不同窗口之间进行通信，包括不同域名、协议、端口等情况，通过调用window.postMessage()方法，在两个窗口之间发送消息，接收方通过监听message事件来接收消息，从而实现跨域通信。\r\n[#29 ](https://github.com/yanlele/interview-question/issues/29)\r\n\r\n\r\n**WebSocket**\r\nWebSocket是一种新的网络协议，可以实现客户端和服务器之间的实时双向通信，同时也可以跨域通信，WebSocket协议建立在TCP协议之上，通过HTTP协议发起握手请求，握手成功后，客户端和服务器就可以通过WebSocket协议进行实时通信了。\r\n[#30](https://github.com/yanlele/interview-question/issues/20) \r\n\r\n\r\n**代理转发**\r\n代理转发是一种常用的跨域通信方式，主要是通过在同一域名下设置代理服务器，在代理服务器上实现跨域访问，再将结果返回给前端页面，从而实现跨域通信。\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/26/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/26/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/24",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/24/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/24/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/24/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/24",
    "id": 1610061980,
    "node_id": "I_kwDOJCCH1M5f95ic",
    "number": 24,
    "title": "ajax如何获取下载进度?",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T05:22:16Z",
    "updated_at": "2023-03-05T05:22:17Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## ajax如何获取下载进度?\n\n要获取下载进度，可以使用 `XMLHttpRequest` 对象提供的 `onprogress` 事件。\n\n使用 onprogress 事件，可以获取文件的下载进度信息，可以通过 loaded 和 total 属性获取当前已经下载的字节数和文件的总字节数，从而计算出当前的下载进度。\n\n下面是一个使用 onprogress 事件获取文件下载进度的示例代码：\n\n```js\nconst xhr = new XMLHttpRequest();\nxhr.open('GET', 'file.url', true);\nxhr.responseType = 'blob';\nxhr.onprogress = function (event) {\n  if (event.lengthComputable) {\n    const percentComplete = (event.loaded / event.total) * 100;\n    console.log(`Downloaded ${percentComplete}%`);\n  }\n};\nxhr.onload = function (event) {\n  // 文件下载完成\n  const blob = xhr.response;\n};\nxhr.send();\n```\n\n在上面的代码中，通过将 XMLHttpRequest 对象的 **responseType 设置为 blob**，来请求一个文件资源，然后监听 onprogress 事件，计算出当前的下载进度，并在控制台输出，最后在 onload 事件中获取到下载的文件内容。\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/24/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/24/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/23",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/23/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/23/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/23/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/23",
    "id": 1610061708,
    "node_id": "I_kwDOJCCH1M5f95eM",
    "number": 23,
    "title": "手写创建一个 ajax 请求",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T05:20:56Z",
    "updated_at": "2023-03-05T05:20:57Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 手动创建一个 ajax 请求\n\n一般来说，我们可以使用XMLHttpRequest对象来创建Ajax请求，其流程如下：\n\n1. 创建XMLHttpRequest对象，通过调用其构造函数来实现。\n2. 使用open()方法指定请求的方法、URL以及是否异步请求。\n3. 使用setRequestHeader()方法设置请求头，例如设置请求的Content-Type。\n4. 设置响应的回调函数，一般有onreadystatechange和onload两种方式。\n5. 使用send()方法发送请求。\n\n实现如下：\n\n```javascript\nvar getJSON = function(url) {\n  var promise = new Promise(function(resolve, reject) {\n    function handler() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    }\n\n    var client = new XMLHttpRequest();\n    //如果是IE的内核ActiveXObject('Microsoft.XMLHTTP');\n    client.open(\"GET\", url);\n    client.onreadystatechange = handler;\n    client.responseType = \"json\";\n    client.setRequestHeader(\"Accept\", \"application/json\");\n    //如果是post请求：client.setRequestHeader('Content-Type','application/X-WWW-form-urlencoded')\n    client.send();\n  });\n  return promise;\n};\n\ngetJSON(\"/posts.json\").then(function(json) {\n  console.log('Contents: ' + json);\n}, function(error) {\n  console.error(' 出错了 ', error);\n});\n```\n\n- `xhr.open()` 第一个参数是请求的方法，可以是GET、POST、PUT等；第二个参数是请求的URL；第三个参数表示是否异步请求。\n\n- `setRequestHeader()`方法用于设置请求头，例如设置Content-Type，常见的值有application/json、application/x-www-form-urlencoded等\n\n- `onreadystatechange回调函数`会在XMLHttpRequest对象的状态发生变化时触发\n\n- 最后，调用send()方法发送请求。\n\n## 回调函数一般有哪些？\n\n设置响应的回调函数，一般有 `onreadystatechange` 和 `onload` 两种方式；\n\n在 XMLHttpRequest 对象中，onreadystatechange 和 onload 是两种不同的事件回调函数。\n\n**onreadystatechange** :事件会在 readyState 的值改变时被触发，它会在请求过程中的每个状态改变时都被触发，从而可以通过 readyState\n的值来判断请求的过程。一般来说，onreadystatechange 回调函数需要根据 readyState 的不同值做出不同的处理，如：\n\n- readyState 为 1 （UNSENT）：代理被创建，但尚未调用 open() 方法；\n- readyState 为 1 （已经调用 open() 方法）时，可以做一些请求初始化的工作；\n- readyState 为 2 （已经调用 send() 方法）时，可以获取响应头信息；\n- readyState 为 3 （正在接收数据）时，可以获取响应的部分数据；\n- readyState 为 4 （已经接收到全部响应数据）时，可以对响应的数据进行处理。\n\n**onload**: 而 onload 事件则是在整个请求过程完成后被触发，表示整个请求已经完成。这个回调函数通常用来处理响应数据，如将响应数据渲染到页面中等。\n\n因此，onreadystatechange 和 onload 这两种回调函数的作用是不同的，需要根据不同的场景进行选择和使用。\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/23/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/23/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/22",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/22/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/22/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/22/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/22",
    "id": 1610057942,
    "node_id": "I_kwDOJCCH1M5f94jW",
    "number": 22,
    "title": "什么是同源策略？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-05T05:02:04Z",
    "updated_at": "2023-03-05T12:31:49Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "同源策略是一种安全机制，它是浏览器对 JavaScript 实施的一种安全限制。所谓“同源”是指域名、协议、端口号均相同。同源策略限制了一个页面中的脚本只能与同源页面的脚本进行交互，而不能与不同源页面的脚本进行交互。这是为了防止恶意脚本窃取数据、进行 XSS 攻击等安全问题。\n\n\n同源策略限制的资源包括：\n\n- Cookie、LocalStorage 和 IndexDB 等存储性资源\n- AJAX、WebSocket 等发送 HTTP 请求的方法\n- DOM 节点\n- 其他通过脚本或插件执行的跨域请求\n\n这些资源只能与同源页面进行交互，不能与不同源的页面进行交互。\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/22/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/22/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/21",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/21/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/21/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/21/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/21",
    "id": 1609838759,
    "node_id": "I_kwDOJCCH1M5f9DCn",
    "number": 21,
    "title": "JS 有哪些迭代器，该如何使用？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-04T15:57:11Z",
    "updated_at": "2023-03-05T05:02:30Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "\n## 迭代器分类\n在 JavaScript 中，有三种类型的迭代器：\n\n- **Array Iterator（数组迭代器）**：通过对数组进行迭代以访问其元素。\n\n- **String Iterator（字符串迭代器）**：通过对字符串进行迭代以访问其字符。\n\n- **Map Iterator（映射迭代器）和 Set Iterator（集合迭代器）**：通过对 Map 和 Set 数据结构进行迭代以访问其键和值。\n\n此外，在 ES6 中，我们还可以使用自定义迭代器来迭代对象中的元素。我们可以使用 Symbol.iterator 方法来创建自定义迭代器，该方法返回一个具有 next 方法的迭代器对象。\n\n另外，`Generator` 函数可以看作是一种特殊的迭代器，它能够暂停执行和恢复执行，使得我们可以通过控制迭代器的执行来生成序列。\n\n## Array Iterator（数组迭代器）有哪些迭代方法？\n\nArray Iterator（数组迭代器）是针对 JavaScript 数组的迭代器，它可以通过 `Array.prototype[Symbol.iterator]()` 方法来获取。\n\n获取到数组迭代器后，我们可以使用以下迭代方法：\n\n`next()`: 返回一个包含 value 和 done 属性的对象，value 表示下一个元素的值，done 表示是否迭代结束。\n\n`return()`: 用于提前终止迭代，并返回给定的值。\n\n`throw()`: 用于向迭代器抛出一个异常。\n\n下面是一个使用迭代器的示例代码：\n```js\nconst arr = ['a', 'b', 'c'];\nconst iterator = arr[Symbol.iterator]();\n\nconsole.log(iterator.next()); // { value: 'a', done: false }\nconsole.log(iterator.next()); // { value: 'b', done: false }\nconsole.log(iterator.next()); // { value: 'c', done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n```\n\n除了以上的迭代方法，还可以通过 for...of 语句来使用迭代器，如下所示：\n```js\nconst arr = ['a', 'b', 'c'];\nfor (const item of arr) {\n  console.log(item);\n}\n// output:\n// a\n// b\n// c\n```\n\n另外，数组迭代器除了上述的迭代方法，还可以使用 forEach()、map()、filter()、reduce() 等常见数组方法进行迭代操作；\n\n## String Iterator（字符串迭代器） 有哪些迭代方法？\n`String Iterator` 是 ES6 引入的一种迭代器，可以用于遍历字符串。String Iterator 没有自己的迭代方法，但可以使用通用的迭代方法。以下是 String Iterator 可以使用的迭代方法：\n\n`next()`：返回迭代器的下一个值，格式为 {value: string, done: boolean}。\n`Symbol.iterator`：返回一个迭代器对象，可以使用 for...of 循环来遍历字符串。\n\n示例代码如下：\n```js\nconst str = \"hello\";\nconst strIterator = str[Symbol.iterator]();\n\nconsole.log(strIterator.next()); // { value: 'h', done: false }\nconsole.log(strIterator.next()); // { value: 'e', done: false }\nconsole.log(strIterator.next()); // { value: 'l', done: false }\nconsole.log(strIterator.next()); // { value: 'l', done: false }\nconsole.log(strIterator.next()); // { value: 'o', done: false }\nconsole.log(strIterator.next()); // { value: undefined, done: true }\n\nfor (let char of str) {\n  console.log(char);\n}\n// Output:\n// h\n// e\n// l\n// l\n// o\n```\n\n## Map Iterator（映射迭代器）和 Set Iterator（集合迭代器）有哪些迭代方法？\n\n**Map Iterator 和 Set Iterator 都有以下迭代方法：**\n`next()`: 返回迭代器中下一个元素的对象，对象包含 value 和 done 两个属性。value 属性是当前元素的值，done 属性表示迭代器是否已经迭代完成。\n`Symbol.iterator`: 返回迭代器本身，使其可被 for...of 循环使用。\n\n\n**Map Iterator 还有以下方法：**\n`entries()`: 返回一个新的迭代器对象，该迭代器对象的元素是 [key, value] 数组。\n`keys()`: 返回一个新的迭代器对象，该迭代器对象的元素是 Map 中的键名。\n`values()`: 返回一个新的迭代器对象，该迭代器对象的元素是 Map 中的键值。\n\n\n**Set Iterator 还有以下方法：**\n`entries()`: 返回一个新的迭代器对象，该迭代器对象的元素是 [value, value] 数组。\n`keys()`: 返回一个新的迭代器对象，该迭代器对象的元素是 Set 中的值。\n`values()`: 返回一个新的迭代器对象，该迭代器对象的元素是 Set 中的值。\n\n\n**Map Iterator 使用举例**\n```js\nconst myMap = new Map();\nmyMap.set(\"key1\", \"value1\");\nmyMap.set(\"key2\", \"value2\");\nmyMap.set(\"key3\", \"value3\");\n\nconst mapIterator = myMap.entries();\n\nconsole.log(mapIterator.next().value); // [\"key1\", \"value1\"]\nconsole.log(mapIterator.next().value); // [\"key2\", \"value2\"]\nconsole.log(mapIterator.next().value); // [\"key3\", \"value3\"]\nconsole.log(mapIterator.next().value); // undefined\n```\n\n\n**Set Iterator 使用举例**\n```js\nconst mySet = new Set(['apple', 'banana', 'orange']);\n\n// 使用 for...of 循环遍历 Set\nfor (const item of mySet) {\n  console.log(item);\n}\n\n// 使用 Set 迭代器手动遍历 Set\nconst setIterator = mySet.values();\nlet next = setIterator.next();\nwhile (!next.done) {\n  console.log(next.value);\n  next = setIterator.next();\n}\n```\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/21/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/21/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/20",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/20/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/20/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/20/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/20",
    "id": 1609830251,
    "node_id": "I_kwDOJCCH1M5f9A9r",
    "number": 20,
    "title": "如何使对象 iterable 化， 以其可以支持 for...of 迭代",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-04T15:28:59Z",
    "updated_at": "2023-03-05T05:02:39Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "在 JavaScript 中，如果一个对象要被 for...of 迭代，那么它必须是可迭代的。可迭代对象是一种具有 Symbol.iterator 方法的对象，该方法返回一个迭代器对象，该迭代器对象实现了 next() 方法，每次调用 next() 方法都返回一个包含 value 和 done 属性的对象，用于迭代对象的每个元素。\n\n因此，要使一个对象 iterable 化，需要实现一个 Symbol.iterator 方法。该方法应该返回一个迭代器对象，这个迭代器对象应该实现 next() 方法，用于返回迭代对象的每个元素。\n\n**举一个例子**下面是一个简单的示例，演示如何将一个普通对象 iterable 化：\n```js\nconst myObj = {\n  data: [1, 2, 3],\n  [Symbol.iterator]() {\n    let index = 0;\n    return {\n      next: () => {\n        if (index < this.data.length) {\n          return { value: this.data[index++], done: false };\n        } else {\n          return { done: true };\n        }\n      },\n    };\n  },\n};\n\nfor (const item of myObj) {\n  console.log(item);\n}\n// 输出：1, 2, 3\n```\n\n**再举一个例子**，比如我们有一个对象，里面存储了一些学生的信息，我们希望能够使用 for...of 循环遍历每个学生信息：\n```js\nconst students = {\n  Alice: { age: 18, gender: 'female', score: 90 },\n  Bob: { age: 19, gender: 'male', score: 85 },\n  Charlie: { age: 20, gender: 'male', score: 95 }\n};\n\nstudents[Symbol.iterator] = function* () {\n  const keys = Object.keys(this);\n  for (let i = 0; i < keys.length; i++) {\n    yield [keys[i], this[keys[i]]];\n  }\n};\n\nfor (const [name, info] of students) {\n  console.log(`${name}: ${info.age} ${info.gender} ${info.score}`);\n}\n```\n\n这样我们就可以使用 for...of 循环遍历学生信息对象中的每个学生信息了。\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/20/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/20/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/19",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/19/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/19/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/19/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/19",
    "id": 1609827374,
    "node_id": "I_kwDOJCCH1M5f9AQu",
    "number": 19,
    "title": "js 对象可以使用 for...of 迭代吗？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-04T15:22:00Z",
    "updated_at": "2023-03-05T05:02:47Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "JavaScript **对象本身并不能直接使用 for...of 迭代**，因为它并不是一个可迭代对象（iterable）。\n\n但是，如果我们想要遍历对象的属性，可以使用 for...in 循环，例如：\n```js\nconst obj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nfor (let prop in obj) {\n  console.log(prop + ': ' + obj[prop]);\n}\n\n// 这段代码可以输出：\nname: John\nage: 30\ncity: New York\n```\n\n需要注意的是，for...in 循环会遍历对象自身的所有可枚举属性（不包括原型链上的属性），包括非数字键和继承的属性。如果只想遍历对象自身的属性，可以使用 hasOwnProperty() 方法进行判断，例如：\n```js\nconst obj = {\n  name: 'John',\n  age: 30,\n  city: 'New York'\n};\n\nfor (let prop in obj) {\n  if (obj.hasOwnProperty(prop)) {\n    console.log(prop + ': ' + obj[prop]);\n  }\n}\n```\n\n这段代码和上面的代码功能是一样的，但是多了一个 hasOwnProperty() 判断，可以确保只输出对象自身的属性。\n\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/19/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/19/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/18",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/18/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/18/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/18/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/18",
    "id": 1609713275,
    "node_id": "I_kwDOJCCH1M5f8kZ7",
    "number": 18,
    "title": "详细讲一下 Symbol 数据类型特征与实际使用案例？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-04T10:25:34Z",
    "updated_at": "2023-03-05T05:02:56Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## Symbol 概要简介\nSymbol 是 ECMAScript 6 引入的一种新的原始数据类型，用来表示独一无二的值。每个 Symbol 值都是唯一的，因此可以用来创建一些独特的标识符。\n\n## 定义\nSymbol 的定义非常简单，只需要调用 Symbol() 方法即可，例如：\n```js\nconst mySymbol = Symbol();\n```\n\n在使用 Symbol 的时候，可以给它传递一个可选的描述信息，用于标识 Symbol 的含义，例如：\n```js\nconst mySymbol = Symbol('my symbol');\n```\n\n\n## 使用场景\n\n### 常量的定义\n由于每个 Symbol 的值都是唯一的，因此可以用它来定义常量，避免不小心修改值。例如：\n```js\nconst MY_CONST = Symbol('my_const')\n```\n\n### Symbol 值可以作为对象的属性名，用来避免属性名冲突\n例如：\n```js\nconst obj = {};\nconst mySymbol = Symbol('my symbol');\nobj[mySymbol] = 'hello';\nconsole.log(obj[mySymbol]); // 输出：'hello'\n```\n\n\n### 在使用 Symbol 的时候，可以结合 Object.defineProperty() 方法来定义一个只读的属性\n例如：\n```js\nconst obj = {};\nconst mySymbol = Symbol('my symbol');\nObject.defineProperty(obj, mySymbol, {\n    value: 'hello',\n    writable: false\n});\nconsole.log(obj[mySymbol]); // 输出：'hello'\nobj[mySymbol] = 'world';\nconsole.log(obj[mySymbol]); // 输出：'hello'\n```\n\n### 还可以使用 Symbol.for() 方法创建一个可共享的 Symbol 值 \n例如：\n```js\nconst s1 = Symbol.for('foo');\nconst s2 = Symbol.for('foo');\nconsole.log(s1 === s2); // 输出：true\n```\n在上述示例中，虽然 s1 和 s2 的值不同，但是它们所表示的含义相同，因此可以认为它们是相等的。这种通过 Symbol.for() 方法创建的 Symbol 值，会被保存在一个全局的 Symbol 注册表中，可以被不同的代码块访问到。\n\n\n### 私有属性的定义 \n由于 Symbol 值是唯一的，因此可以用它来模拟私有属性的概念，防止属性名冲突。例如：\n```js\nconst _myPrivateProp = Symbol('my_private_prop')\nclass MyClass {\n    constructor() {\n    this[_myPrivateProp] = 'private value'\n}\ngetPrivateValue() {\n    return this[_myPrivateProp]\n    }\n}\n```\n在这个例子中，_myPrivateProp 就是一个 Symbol 值，用于存储私有属性的值，它无法被外部访问到，只能通过类的方法来获取它的值。\n\n### 自定义迭代器\nSymbol 还可以用于自定义迭代器，例如：\n```js\nconst myIterable = {\n  [Symbol.iterator]: function* () {\n    yield 1\n    yield 2\n    yield 3\n  }\n}\nfor (let value of myIterable) {\n  console.log(value)\n}\n// Output: 1 2 3\n```\n在这个例子中，我们使用了 Symbol.iterator 来定义了一个自定义的迭代器，这个迭代器可以被 for...of 循环调用来遍历对象的属性值。\n\n\n## 总结\n总之，`Symbol` 的主要用途是创建独一无二的属性名，用来避免属性名冲突。\n在实际开发中，可以将 `Symbol` 作为对象的属性名来定义一些特殊的行为，例如迭代器、生成器等，这些都是 `Symbol` 的实际使用案例。\n\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/18/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/18/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/17",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/17/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/17/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/17/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/17",
    "id": 1609707590,
    "node_id": "I_kwDOJCCH1M5f8jBG",
    "number": 17,
    "title": "JS数据类型有哪些，区别是什么？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-04T10:05:54Z",
    "updated_at": "2023-03-05T05:03:08Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "在 JavaScript 中，数据类型可以分为两类：**原始类型和对象类型**。原始类型包括：数字（number）、字符串（string）、布尔值（boolean）、null、undefined 和 Symbol（ES6 新增），对象类型包括：对象（object）、数组（array）、函数（function）等。\r\n\r\n区别如下：\r\n\r\n- 原始类型的值是不可变的，对象类型的值是可变的。\r\n- 原始类型的值是按值访问的，对象类型的值是按引用访问的。 \r\n- 原始类型存储在栈内存中，对象类型存储在堆内存中。\r\n\r\n\r\n**原始类型**：\r\n具体来说，**数字、字符串、布尔值、null 和 undefined 是 JavaScript 中的五种原始类型，它们都是不可变的**。每次对原始类型进行操作时，都会创建一个新的原始类型的值。例如：\r\n```js\r\nlet num1 = 10;\r\nlet num2 = num1 + 5;\r\nconsole.log(num1); // 10\r\nconsole.log(num2); // 15\r\n```\r\n\r\n在上面的例子中，对 num1 进行操作时并没有改变 num1 的值，而是创建了一个新的值 num2。\r\n\r\n\r\n**对象类型**：\r\n对象类型则是可变的，因为对象、数组、函数等值是通过引用来访问的。例如：\r\n\r\n```ts\r\nlet obj1 = { name: '张三' };\r\nlet obj2 = obj1;\r\nobj2.name = '李四';\r\nconsole.log(obj1.name); // \"李四\"\r\nconsole.log(obj2.name); // \"李四\"\r\n```\r\n在上面的例子中，修改了 obj2 的属性值，但由于 obj1 和 obj2 指向的是同一个对象，所以 obj1 的属性值也被修改了。\r\n\r\n\r\n**Symbol**：\r\n除了五种原始类型和对象类型外，ES6 新增了一种原始类型：`Symbol`。它的主要作用是创建唯一的标识符。例如：\r\n```js\r\nlet s1 = Symbol();\r\nlet s2 = Symbol();\r\nconsole.log(s1 === s2); // false\r\n```\r\n在上面的例子中，两个 Symbol 创建的值是不相等的，即使它们的值是一样的。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/17/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/17/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/16",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/16/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/16/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/16/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/16",
    "id": 1609697767,
    "node_id": "I_kwDOJCCH1M5f8gnn",
    "number": 16,
    "title": "网络模型分层大概有哪些层级？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-04T09:40:44Z",
    "updated_at": "2023-03-05T05:03:19Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "计算机网络体系结构通常被划分为七层，即**OSI（Open System Interconnection，开放式系统互联）参考模型**和**TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/互联网协议）参考模型。**\r\n\r\n## OSI参考模型包含七层，从底层到顶层依次是：\r\n\r\n物理层（Physical Layer）：负责将比特流传输到物理媒介上，如电缆、光纤等。\r\n\r\n数据链路层（Data Link Layer）：负责将比特流组装成帧，进行差错校验、流量控制等操作。\r\n\r\n网络层（Network Layer）：负责将数据包从源节点传输到目的节点，实现路由选择、拥塞控制等功能。\r\n\r\n传输层（Transport Layer）：负责为应用层提供可靠的端到端通信，常用的协议有TCP和UDP。\r\n\r\n会话层（Session Layer）：负责建立、管理、终止进程之间的会话连接，使不同应用程序之间能够进行数据交互。\r\n\r\n表示层（Presentation Layer）：负责对数据进行编码、解码和加密、解密，保证数据在传输过程中的安全性和正确性。\r\n\r\n应用层（Application Layer）：提供用户接口，实现用户与计算机网络之间的交互。\r\n\r\n\r\n\r\n## CP/IP参考模型包含四层，从底层到顶层依次是：\r\n\r\n网络接口层（Network Interface Layer）：负责将数据帧封装成包，并进行物理层的传输。\r\n\r\n网络层（Internet Layer）：负责将数据包从源节点传输到目的节点，实现路由选择、拥塞控制等功能。\r\n\r\n传输层（Transport Layer）：负责为应用层提供可靠的端到端通信，常用的协议有TCP和UDP。\r\n\r\n应用层（Application Layer）：提供用户接口，实现用户与计算机网络之间的交互。\r\n\r\n\r\n**需要注意的是**: OSI参考模型和TCP/IP参考模型虽然不完全一致，但两者都包含了物理层、数据链路层、网络层和应用层。传输层和会话层、表示层在TCP/IP参考模型中被合并为了传输层。\r\n\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/16/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/16/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/14",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/14/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/14/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/14/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/14",
    "id": 1608767453,
    "node_id": "I_kwDOJCCH1M5f49fd",
    "number": 14,
    "title": "TCP 传输过程？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-03T14:45:41Z",
    "updated_at": "2023-03-05T05:03:31Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 传输过程\r\nTCP（传输控制协议）是一种面向连接的协议，它保证了数据的可靠传输。在 TCP 传输数据时，数据会被分割成一个个的数据包进行传输，具体传输过程如下：\r\n\r\n- **建立连接**：TCP 通过三次握手建立连接，即客户端向服务器发送 SYN（同步）数据包，服务器接收到 SYN 后回应一个 SYN-ACK（同步-确认）数据包，客户端再回应一个 ACK（确认）数据包，连接建立成功。\r\n\r\n- **数据传输**：数据在应用层被拆分成数据段，在传输层被拆分成数据包（也称为报文段），每个数据包包含源端口号、目标端口号、序列号、确认号、标志位等信息。发送方发送数据包后，等待接收方回复确认信息，如果未收到确认信息，则进行重传，直到接收方成功接收数据包。\r\n\r\n- **拥塞控制**：当网络拥塞时，TCP 会采取措施来减少数据的传输速率，如减小窗口大小、降低拥塞窗口等。\r\n\r\n- **连接终止**：TCP 通过四次挥手来关闭连接，即客户端发送一个 FIN（终止）数据包，服务器回应一个 ACK 数据包表示接收到 FIN，然后服务器再发送一个 FIN 数据包，客户端回应一个 ACK 数据包表示接收到 FIN，连接关闭成功。\r\n\r\n总的来说，**TCP 通过三次握手建立连接、数据分段传输、拥塞控制和四次挥手关闭连接来保证数据的可靠传输**。\r\n\r\n\r\n## 详细说一下 TCP 通过三次握手建立连接？\r\nTCP通过三次握手建立连接的过程如下：\r\n\r\n- **第一次握手**：客户端向服务端发送 `SYN`（同步）包，其中 `SYN=1，seq=x`，表示客户端希望与服务端建立连接，同时指定自己的初始序号为`x`。此时客户端处于 `SYN_SENT` 状态。\r\n\r\n- **第二次握手**：服务端接收到 SYN 包后，向客户端发送 `SYN-ACK` 包，其中 SYN=1，`ACK=1，ack=x+1，seq=y`，表示服务端已经收到客户端的请求，同意建立连接，同时指定自己的初始序号为y，确认号为`x+1`。此时服务端处于 `SYN_RCVD` 状态。\r\n\r\n- **第三次握手**：客户端收到 SYN-ACK 包后，向服务端发送 `ACK` 包，其中 `SYN=0，ACK=1，ack=y+1，seq=x+1`，表示客户端已经收到服务端的确认，连接建立成功。此时客户端处于 `ESTABLISHED` 状态，服务端也处于 `ESTABLISHED` 状态。\r\n\r\n这样就完成了三次握手建立连接的过程。在这个过程中，客户端和服务端都可以向对方发送数据。\r\n需要注意的是，如果客户端在等待服务端的 SYN-ACK 包时超时或未收到响应，会重新发送 SYN 包，直到建立连接或达到最大重试次数。同时，在建立连接后，每个数据包都会在传输时带有序号和确认号，以保证数据的可靠传输。\r\n\r\n## TCP数据分段传输的过程是怎么样的？\r\n\r\n- 应用层将需要传输的数据分成适当大小的数据段，每个数据段称为一个TCP数据包。\r\n\r\n- TCP协议根据MSS（最大报文长度）将TCP数据包分割成更小的IP数据包，以适应底层网络的MTU（最大传输单元）。\r\n\r\n- 在传输数据之前，TCP在每个数据包中添加一个包头（header），其中包含序列号（sequence number）和确认号\r\n（acknowledgment number）等信息。\r\n\r\n- 发送方将数据包发送到网络，并等待接收方的确认响应。如果发送方没有收到确认响应，它会重新发送数据包。\r\n\r\n- 接收方收到数据包后，会对数据包进行确认，向发送方发送确认响应。如果接收方没有收到正确的数据包，它会要求发送方重发数据。\r\n\r\n- 发送方收到确认响应后，会将下一个数据包发送到网络，并等待接收方的确认响应。如果发送方没有收到确认响应，它会重新发送数据包。\r\n\r\n- 接收方根据收到的数据包的序列号和确认号，组装数据包，然后将数据包传递给上层应用程序。\r\n\r\nTCP数据分段传输可以提高网络的可靠性和稳定性，**避免了数据包的丢失和重传，但是也会造成额外的网络开销。**\r\n\r\n\r\n## TCP 是如何进行拥塞控制？\r\n\r\nTCP使用拥塞控制算法来避免网络中的拥塞现象，并在发生拥塞时减少发送数据的速率，从而避免网络拥塞的加剧。TCP的拥塞控制算法主要包括以下几个方面：\r\n\r\n- **慢启动（Slow Start）**：在TCP连接刚建立时，发送方限制了自己的初始发送窗口大小，从而避免发送过多的数据导致网络拥塞。发送方以指数级别的方式增加其发送窗口大小，直到达到一个阈值，然后就会进入拥塞避免状态。\r\n\r\n- **拥塞避免（Congestion Avoidance）**：在拥塞避免状态下，TCP发送方每经过一轮的传输，就将其发送窗口大小增加一个MSS（最大报文段长度）的值。这样可以逐渐增加发送窗口大小，从而提高数据传输速率。\r\n\r\n**拥塞检测（Congestion Detection）**：当TCP发送方收到一个超时重传的确认消息时，它就认为网络中出现了拥塞，并将其发送窗口大小减半，然后重新进入慢启动状态。\r\n\r\n- **拥塞避免（Congestion Avoidance）**：当TCP发送方收到一个失序的确认消息时，它就知道它发送的某些数据包在网络中已经丢失了，此时就不必等到超时重传定时器时间到期，而是立即重传那些丢失的数据包。\r\n\r\n- **快速恢复（Fast Recovery）**：在快速重传后，TCP发送方将进入快速恢复状态，其中发送方的发送窗口大小将设置为丢失数据包的数量加上MSS的值，从而避免了发送窗口大小的降低和慢启动状态的重新启动。\r\n\r\n\r\n## 四次挥手关闭连接流程如何？\r\n\r\nTCP 通过四次挥手来关闭连接，具体过程如下：\r\n\r\n- 客户端向服务端发送 FIN 报文，表示客户端不再发送数据。\r\n\r\n- 服务端收到 FIN 报文后，向客户端发送 ACK 报文，表示收到了客户端的 FIN 报文。\r\n\r\n- 服务端向客户端发送 FIN 报文，表示服务端不再发送数据。\r\n\r\n- 客户端收到 FIN 报文后，向服务端发送 ACK 报文，表示收到了服务端的 FIN 报文。\r\n\r\n图示如下：\r\n```\r\n客户端                服务端\r\n|                      |\r\n|  FIN(seq=x)          |\r\n|--------------------->|\r\n|  ACK(seq=x+1,ack=y)  |\r\n|<---------------------|\r\n|                      |\r\n|  FIN(seq=y)          |\r\n|<---------------------|\r\n|  ACK(seq=y+1,ack=x+1)|\r\n|--------------------->|\r\n```\r\n\r\n其中，`seq` 表示序号，`ack` 表示确认号。第一次握手中，客户端发送的序号 seq=x，表示客户端的数据流的第一个字节的序号。第二次握手中，服务端发送的确认号 ack=y，表示服务端期望下一个收到的字节的序号是 y。第三次握手中，服务端发送的序号 seq=y，表示服务端的数据流的第一个字节的序号。第四次握手中，客户端发送的确认号 ack=x+1，表示客户端期望下一个收到的字节的序号是 x+1。注意，在第四次握手中，客户端发送 ACK 报文后，不再发送数据，但服务端可能还有数据需要发送，因此服务端需要先发送 FIN 报文。\r\n\r\n四次挥手的过程中，最后一个 ACK 报文可能会丢失，因此需要等待一段时间后才能确认连接已经关闭。这个等待时间称为 `TIME_WAIT` 状态，一般为 `2MSL`（Maximum Segment Lifetime，最长报文寿命）时间，即一个报文在网络中最长的生命周期，通常为 2 分钟。\r\n\r\n值得注意的是，TCP 的四次挥手过程是可靠的，可以确保数据可靠传输。但由于四次挥手需要消耗额外的时间和网络资源，因此在某些情况下，**可以使用 TCP 的强制断开连接方式（RST），通过发送一个 RST 报文来立即中断连接**。但这种方式可能会导致数据的丢失和损坏，因此应该谨慎使用。\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/14/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/14/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/13",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/13/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/13/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/13/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/13",
    "id": 1608761495,
    "node_id": "I_kwDOJCCH1M5f48CX",
    "number": 13,
    "title": "HTTP建立连接的过程?",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-03T14:41:29Z",
    "updated_at": "2023-03-05T05:03:40Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "## 在HTTP/1.1中\r\n建立连接过程遵循以下步骤：\r\n\r\n- 建立TCP连接：客户端通过三次握手建立TCP连接。\r\n\r\n- 发送请求：客户端向服务器发送一个HTTP请求报文。\r\n\r\n- 服务器响应：服务器收到请求后，返回一个HTTP响应报文。\r\n\r\n- 客户端接收响应：客户端收到响应后，根据响应中的状态码判断请求是否成功。\r\n\r\n- 关闭连接：如果响应中包含 Connection: close 头部，那么连接关闭，否则保持连接，可以继续发送请求。\r\n\r\n## 在HTTP/2中\r\n建立连接过程使用了多路复用，可以在一个连接上同时处理多个请求和响应，具体过程如下：\r\n\r\n- 客户端和服务器建立TCP连接。\r\n\r\n- 客户端发送一个HTTP/2的SETTINGS帧，其中包含一些配置信息，如帧的大小和流的并发数量等。\r\n\r\n- 服务器返回一个HTTP/2的SETTINGS帧，确认了客户端发送的设置。\r\n\r\n- 客户端发送一个HTTP/2的HEADERS帧，其中包含了第一个请求的信息，同时还包含了一个唯一的标识符，称为流ID。\r\n\r\n- 服务器返回一个HTTP/2的HEADERS帧，其中包含了响应的信息，同时也包含了与请求相同的流ID。\r\n\r\n- 客户端可以在同一个连接上发送多个请求和响应，每个请求和响应都包含一个流ID，用于标识请求和响应之间的关系。\r\n\r\n- 当客户端或服务器想要关闭连接时，它可以发送一个HTTP/2的GOAWAY帧，表示不再接受新的请求或响应，并且将连接关闭。\r\n\r\n总之，HTTP/1.1是基于请求-响应模型的，每次请求都需要建立一个新的连接。而HTTP/2使用多路复用，可以在一个连接上处理多个请求和响应，提高了性能和效率。",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/13/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/13/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/12",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/12/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/12/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/12/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/12",
    "id": 1608748256,
    "node_id": "I_kwDOJCCH1M5f44zg",
    "number": 12,
    "title": "HTTP 缓存策略有哪些？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/3",
      "html_url": "https://github.com/yanlele/interview-question/milestone/3",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/3/labels",
      "id": 9118710,
      "node_id": "MI_kwDOJCCH1M4AiyP2",
      "number": 3,
      "title": "高",
      "description": "高级别面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 3,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:34:04Z",
      "updated_at": "2023-03-05T15:34:46Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-03T14:32:04Z",
    "updated_at": "2023-03-05T05:03:51Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# HTTP 缓存策略有哪些？\r\n\r\nHTTP缓存策略是指浏览器和服务器之间在传输资源时，如何使用缓存的方式。HTTP缓存的主要目的是减少网络传输的数据量，提高页面的访问速度。\r\n\r\n\r\n## 缓存的主要策略有哪些？\r\nHTTP缓存策略主要包括以下几种：\r\n\r\n- `强缓存：`通过设置 HTTP 头部中的 Expires 或 Cache-Control 字段来指定资源在本地缓存的有效期。当资源未过期时，浏览器直接从缓存中读取，不会向服务器发送请求，从而提高页面的访问速度。\r\n\r\n- `协商缓存：`当资源的缓存时间已经过期，浏览器会向服务器发送请求，服务器会检查资源是否有更新，如果没有更新，则返回 304 状态码，告诉浏览器直接使用本地缓存。\r\n    - `Last-Modified / If-Modified-Since`：服务器在返回资源时，会添加 Last-Modified 头部字段，表示资源最后的修改时间。当浏览器下次请求该资源时，会在请求头部添加 If-Modified-Since 字段，表示上次请求时资源的修改时间。服务器检查这两个时间是否一致，如果一致，则返回 304 状态码，否则返回新的资源。\r\n    - `ETag / If-None-Match`：服务器在返回资源时，会添加 ETag 头部字段，表示资源的唯一标识。当浏览器下次请求该资源时，会在请求头部添加 If-None-Match 字段，表示上次请求时资源的唯一标识。服务器检查这两个标识是否一致，如果一致，则返回 304 状态码，否则返回新的资源。\r\n\r\n- `离线缓存：`通过使用 HTML5 提供的 Application Cache API，可以将页面的资源缓存在本地，使得用户在没有网络连接的情况下也能够访问页面。\r\n\r\n- `Service Worker 缓存：`Service Worker 是一种在浏览器后台运行的 JavaScript 线程，可以拦截和处理浏览器发送的网络请求。通过使用 Service Worker，可以将页面的资源缓存在本地，提高页面的访问速度和用户体验。\r\n\r\n\r\n## 强缓存中 Expires 或 Cache-Control 有什么区别？\r\n在 HTTP 缓存策略中，强缓存是指在一定时间内，直接使用本地缓存而不发送请求到服务器。`Expires 和 Cache-Control` 是用于设置强缓存的两种方式。\r\n\r\n- Expires: 是 HTTP/1 的产物，它是一个 HTTP 头字段，`表示资源过期时间，是一个绝对时间`。服务器返回的 HTTP 头中，如果包含 Expires 字段，则表示该资源在该过期时间之前可以直接从缓存中获取，而不需要再次请求服务器。\r\n- Cache-Control: 是 `HTTP/1.1` 的产物，是一个 HTTP 头字段，用来控制文档缓存行为。它的值可以是很多不同的指令，例如 `max-age、no-cache、no-store、must-revalidate` 等等。其中，`max-age` 指令可以设置资源的最大有效时间，单位是秒。如果服务器返回的 HTTP 头中包含 Cache-Control 指令，则浏览器会根据该指令的值来决定是否直接使用本地缓存，而不需要再次请求服务器。\r\n\r\nExpires 是一个绝对时间，因此它的缺点是当服务器的时间与客户端的时间不一致时，缓存过期时间就可能会出现偏差。\r\n而 Cache-Control 是一个相对时间，因此它的缺点是需要服务器和客户端的时间保持一致，同时需要正确设置 max-age 的值。\r\n在实际应用中，建议使用 Cache-Control，因为它更加灵活和可控。\r\n\r\n## 离线缓存 Application Cache API 是如何缓存 http 资源的？\r\n`Application Cache API（应用程序缓存）`是 HTML5 标准中提供的一个用于离线缓存 Web 应用程序的技术。它可以将 Web 应用程序中的文件（包括 HTML、CSS、JavaScript 和图像等）保存到客户端浏览器中的缓存中，在没有网络连接的情况下，仍然能够访问应用程序。\r\n\r\n在 Application Cache API 中，通过在 `cache manifest 文件中列出需要缓存的资源列表来实现离线缓存`。该文件必须以 `.appcache` 为后缀名，`并且必须在 Web 服务器上进行访问。`浏览器会下载该文件，并将文件中列出的资源文件下载到本地缓存中。当应用程序在离线状态下打开时，浏览器会自动从本地缓存中加载缓存的文件。\r\n\r\n下面是一个简单的 cache manifest 文件示例：\r\n```\r\nCACHE MANIFEST\r\n# version 1.0.0\r\n\r\nCACHE:\r\nindex.html\r\nstyles.css\r\nscript.js\r\nimage.jpg\r\n\r\nNETWORK:\r\n*\r\n\r\nFALLBACK:\r\n```\r\n\r\n上面的示例文件将缓存 index.html、styles.css、script.js 和 image.jpg 等资源文件，同时指定 NETWORK 和 FALLBACK，这两个属性分别用于指定离线缓存不生效时的网络连接策略和替换资源文件。\r\n\r\n需要注意的是，Application Cache API 并不是一种完美的缓存技术，它也存在一些缺陷。例如，**当更新 Web 应用程序时，需要手动清除客户端浏览器中的缓存才能生效**，否则用户访问的仍然是旧版本的应用程序。同时，Application Cache API **只能缓存 GET 请求**，不支持 POST 等其他请求方法。因此，为了更好地实现离线缓存，可以使用其他技术，例如 Service Worker。\r\n\r\n## Service Worker 是如何缓存 http 请求资源的？\r\n\r\nervice Worker 是一种在浏览器后台运行的脚本，可以拦截和处理浏览器网络请求。因此，可以使用 Service Worker 来缓存 http 请求资源。\r\n\r\nService Worker 可以通过以下步骤来缓存 http 请求资源：\r\n\r\n1. 注册 Service Worker：通过在页面中注册 Service Worker，可以告诉浏览器使用 Service Worker 来处理网络请求。\r\n\r\n2. 安装 Service Worker：一旦 Service Worker 被注册，浏览器就会下载并安装它。在安装过程中，Service Worker 可以缓存一些静态资源（如 HTML、CSS 和 JavaScript 文件）。\r\n\r\n3. 激活 Service Worker：一旦 Service Worker 安装成功，它就可以被激活。在激活过程中，Service Worker 可以删除旧版本的缓存，或者执行其他一些操作。\r\n\r\n4. 拦截网络请求：一旦 Service Worker 被激活，它就可以拦截浏览器发送的网络请求。\r\n\r\n5. 处理网络请求：当 Service Worker 拦截到网络请求时，它可以执行一些自定义的逻辑来处理这些请求。例如，它可以检查缓存中是否已经存在该请求的响应，如果存在，则直接返回缓存中的响应，否则，它可以将请求发送到服务器并缓存服务器的响应。\r\n\r\n6. 更新缓存：如果缓存中的资源发生了变化，Service Worker 可以自动更新缓存。例如，它可以在后台下载最新的资源，并更新缓存中的文件。\r\n\r\n需要注意的是，使用 Service Worker 来缓存 http 请求资源需要一些额外的工作。例如，**需要编写 Service Worker 脚本来处理请求，并且需要将该脚本注册到浏览器中**。此外，还需要考虑一些缓存策略，以确保缓存的数据与服务器上的数据保持同步。\r\n\r\n**下面是一个使用 Service Worker 实现缓存的示例代码：**\r\n```js\r\n// 注册 Service Worker\r\nif ('serviceWorker' in navigator) {\r\n  window.addEventListener('load', function() {\r\n    navigator.serviceWorker.register('/service-worker.js').then(function(registration) {\r\n      console.log('ServiceWorker registration successful with scope: ', registration.scope);\r\n    }, function(err) {\r\n      console.log('ServiceWorker registration failed: ', err);\r\n    });\r\n  });\r\n}\r\n\r\n// 安装 Service Worker\r\nself.addEventListener('install', function(event) {\r\n  console.log('ServiceWorker install');\r\n  event.waitUntil(\r\n    caches.open('my-cache').then(function(cache) {\r\n      return cache.addAll([\r\n        '/',\r\n        '/index.html',\r\n        '/styles.css',\r\n        '/script.js',\r\n        '/image.png'\r\n      ]);\r\n    })\r\n  );\r\n});\r\n\r\n// 激活 Service Worker\r\nself.addEventListener('activate', function(event) {\r\n  console.log('ServiceWorker activate');\r\n});\r\n\r\n// 拦截网络请求\r\nself.addEventListener('fetch', function(event) {\r\n  event.respondWith(\r\n    caches.match(event.request).then(function(response) {\r\n      if (response) {\r\n        console.log('ServiceWorker fetch from cache:', event.request.url);\r\n        return response;\r\n      } else {\r\n        console.log('ServiceWorker fetch from network:', event.request.url);\r\n        return fetch(event.request);\r\n      }\r\n    })\r\n  );\r\n});\r\n\r\n// 更新缓存\r\nself.addEventListener('activate', event => {\r\n  event.waitUntil(\r\n    caches.keys().then(cacheNames => {\r\n      return Promise.all(\r\n        cacheNames.filter(cacheName => {\r\n          return cacheName.startsWith('my-cache') &&\r\n            cacheName !== 'my-cache';\r\n        }).map(cacheName => {\r\n          return caches.delete(cacheName);\r\n        })\r\n      );\r\n    })\r\n  );\r\n});\r\n```\r\n\r\n当网络请求到来时，会首先在缓存中查找对应的资源，如果有则直接返回缓存中的资源，否则从网络中获取资源并返回。这样就可以实现基本的离线缓存功能。\r\n\r\n在这个示例中，当 Service Worker 被安装时，我们打开一个新的缓存并将应用程序的静态资源添加到缓存中。在 fetch 事件中，我们拦截每个网络请求并尝试匹配它们到我们的缓存中，如果匹配到了则返回缓存的响应，否则通过 fetch 方法从网络中获取资源。在 activate 事件中，我们可以更新缓存，删除旧的缓存项并将新的缓存项添加到缓存中。\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/12/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/12/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/11",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/11/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/11/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/11/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/11",
    "id": 1608703696,
    "node_id": "I_kwDOJCCH1M5f4t7Q",
    "number": 11,
    "title": "请简述 HTTP 请求的过程",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-03T14:02:10Z",
    "updated_at": "2023-03-05T05:04:02Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "HTTP（Hypertext Transfer Protocol）是一种用于传输数据的协议。当我们在浏览器中输入 URL，点击链接或提交表单时，浏览器会发送 HTTP 请求，并等待服务器的响应。以下是 HTTP 请求的基本过程：\r\n\r\n`建立连接`：浏览器向服务器发出连接请求，服务器接受请求并建立连接。\r\n\r\n`发送请求`：浏览器向服务器发送 HTTP 请求。请求包括请求方法（GET、POST、PUT、DELETE等）、请求头（包含一些元数据，如 Accept、Content-Type、Authorization 等）、请求体（POST 和 PUT 请求会带上数据）等。\r\n\r\n`接受请求`：服务器接受请求并解析请求。服务器会根据请求的内容进行相应的处理，如查询数据库、读取文件等。\r\n\r\n`发送响应`：服务器向浏览器发送 HTTP 响应。响应包括响应状态码、响应头、响应体等。常见的响应状态码包括 200 OK、404 Not Found、500 Internal Server Error 等。\r\n\r\n`接受响应`：浏览器接受响应并解析响应。浏览器会根据响应的内容进行相应的处理，如渲染页面、执行 JavaScript 等。\r\n\r\n`断开连接`：请求处理完毕后，浏览器和服务器会断开连接。\r\n\r\n需要注意的是，HTTP 是一种无状态协议，即每次请求都是独立的，服务器不会保留任何关于请求的信息。为了保持客户端与服务器之间的状态，通常使用 Cookie 或 Session 等机制来保存状态信息。\r\n\r\n此外，现代浏览器通常会使用 HTTP 缓存来提高性能。当浏览器发送请求时，如果发现资源已经在本地缓存中存在，就会直接使用缓存的版本，而不是重新从服务器下载。可以使用 Cache-Control、Expires 等响应头控制缓存的行为。",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/11/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/11/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/10",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/10/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/10/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/10/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/10",
    "id": 1608655083,
    "node_id": "I_kwDOJCCH1M5f4iDr",
    "number": 10,
    "title": "实现一个双向链表， 具备添加节点、删除节点、在特定位置插入节点、查找节点、遍历等功能",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-03-03T13:37:21Z",
    "updated_at": "2023-03-05T05:04:12Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 必须要掌握的知识\r\n在 JavaScript 中实现双向链表需要掌握以下知识点：\r\n\r\n- 如何使用构造函数和类创建双向链表节点，以及如何在节点之间建立双向连接。\r\n\r\n- 双向链表的常用操作，包括`添加节点、删除节点、在特定位置插入节点、查找节点`等。\r\n\r\n- 双向链表的遍历和迭代，包括`正向遍历、反向遍历、循环遍历`等。\r\n\r\n- 链表的常见问题，例如`链表是否为空、链表长度、查找节点`等。\r\n\r\n- 对 JavaScript 垃圾回收机制的理解，确保双向链表的实现不会导致内存泄漏。\r\n\r\n以上知识点是实现双向链表所必须掌握的内容，掌握这些知识点能够帮助我们有效地创建和操作双向链表。\r\n\r\n## 什么是双向链表\r\n\r\n双向链表（Doubly linked list）是一种常见的数据结构，它是由一系列节点组成的，每个节点都包含一个指向前驱节点和后继节点的指针。相比单向链表，双向链表具有双向遍历的能力，即可以从任意一个节点开始，向前或向后遍历整个链表。\r\n\r\n双向链表的每个节点通常包含两个指针，即 prev 指针和 next 指针。prev 指针指向当前节点的前驱节点，而 next 指针指向当前节点的后继节点。由于每个节点都包含两个指针，因此双向链表的节点通常比单向链表的节点更占用空间。\r\n\r\n双向链表可以用于实现各种数据结构和算法，如LRU（Least Recently Used）缓存淘汰算法，双向队列（Deque）等。由于它具有双向遍历的能力，因此在某些场景下可以比单向链表更加高效和方便。\r\n\r\n\r\n## 实现一个双向链表\r\n```js\r\nclass Node {\r\n  constructor(value) {\r\n    this.value = value;\r\n    this.next = null;\r\n    this.prev = null;\r\n  }\r\n}\r\n\r\nclass DoublyLinkedList {\r\n  constructor() {\r\n    this.head = null;\r\n    this.tail = null;\r\n    this.length = 0;\r\n  }\r\n\r\n  // 在链表末尾添加节点\r\n  push(value) {\r\n    const node = new Node(value);\r\n    if (this.length === 0) {\r\n      this.head = node;\r\n      this.tail = node;\r\n    } else {\r\n      this.tail.next = node;\r\n      node.prev = this.tail;\r\n      this.tail = node;\r\n    }\r\n    this.length++;\r\n    return this;\r\n  }\r\n\r\n  // 从链表末尾移除节点\r\n  pop() {\r\n    if (this.length === 0) {\r\n      return undefined;\r\n    }\r\n    const node = this.tail;\r\n    if (this.length === 1) {\r\n      this.head = null;\r\n      this.tail = null;\r\n    } else {\r\n      this.tail = node.prev;\r\n      this.tail.next = null;\r\n      node.prev = null;\r\n    }\r\n    this.length--;\r\n    return node.value;\r\n  }\r\n\r\n  // 在链表开头添加节点\r\n  unshift(value) {\r\n    const node = new Node(value);\r\n    if (this.length === 0) {\r\n      this.head = node;\r\n      this.tail = node;\r\n    } else {\r\n      this.head.prev = node;\r\n      node.next = this.head;\r\n      this.head = node;\r\n    }\r\n    this.length++;\r\n    return this;\r\n  }\r\n\r\n  // 从链表开头移除节点\r\n  shift() {\r\n    if (this.length === 0) {\r\n      return undefined;\r\n    }\r\n    const node = this.head;\r\n    if (this.length === 1) {\r\n      this.head = null;\r\n      this.tail = null;\r\n    } else {\r\n      this.head = node.next;\r\n      this.head.prev = null;\r\n      node.next = null;\r\n    }\r\n    this.length--;\r\n    return node.value;\r\n  }\r\n\r\n  // 获取指定位置的节点\r\n  get(index) {\r\n    if (index < 0 || index >= this.length) {\r\n      return undefined;\r\n    }\r\n    let node = null;\r\n    if (index < this.length / 2) {\r\n      node = this.head;\r\n      for (let i = 0; i < index; i++) {\r\n        node = node.next;\r\n      }\r\n    } else {\r\n      node = this.tail;\r\n      for (let i = this.length - 1; i > index; i--) {\r\n        node = node.prev;\r\n      }\r\n    }\r\n    return node;\r\n  }\r\n\r\n  // 在指定位置插入节点\r\n  insert(index, value) {\r\n    if (index < 0 || index > this.length) {\r\n      return false;\r\n    }\r\n    if (index === 0) {\r\n      return !!this.unshift(value);\r\n    }\r\n    if (index === this.length) {\r\n      return !!this.push(value);\r\n    }\r\n    const node = new Node(value);\r\n    const prevNode = this.get(index - 1);\r\n    const nextNode = prevNode.next;\r\n    prevNode.next = node;\r\n    node.prev = prevNode;\r\n    node.next = nextNode;\r\n    nextNode.prev = node;\r\n    this.length++;\r\n    return true;\r\n  }\r\n\r\n  // 移除指定位置的节点\r\n  remove(index) {\r\n    if (index < 0 || index >= this.length) {\r\n      return undefined;\r\n    }\r\n    if (index === 0) {\r\n      return this.shift();\r\n    }\r\n    if (index === this.length - 1) {\r\n      return this.pop();\r\n    }\r\n    const nodeToRemove = this.get(index);\r\n    const prevNode = nodeToRemove.prev;\r\n    const nextNode = nodeToRemove.next;\r\n    prevNode.next = nextNode;\r\n    nextNode.prev = prevNode;\r\n    nodeToRemove.next = null;\r\n    nodeToRemove.prev = null;\r\n    this.length--;\r\n    return nodeToRemove.value;\r\n  }\r\n\r\n  // 反转链表\r\n  reverse() {\r\n    let node = this.head;\r\n    this.head = this.tail;\r\n    this.tail = node;\r\n    let prevNode = null;\r\n    let nextNode = null;\r\n    for (let i = 0; i < this.length; i++) {\r\n      nextNode = node.next;\r\n      node.next = prevNode;\r\n      node.prev = nextNode;\r\n      prevNode = node;\r\n      node = nextNode;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  // 通过 value 来查询 index\r\n  findIndexByValue(value) {\r\n    let currentNode = this.head;\r\n    let index = 0;\r\n\r\n    while (currentNode) {\r\n      if (currentNode.value === value) {\r\n        return index;\r\n      }\r\n      currentNode = currentNode.next;\r\n      index++;\r\n    }\r\n\r\n    return -1; // 如果链表中没有找到该值，返回 -1\r\n  }\r\n\r\n  // 正向遍历链表，并返回遍历结果\r\n  forwardTraversal() {\r\n    const result = [];\r\n    let current = this.head;\r\n    while (current) {\r\n      result.push(current.value);\r\n      current = current.next;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // 反向遍历链表，并返回遍历结果\r\n  backwardTraversal() {\r\n    const result = [];\r\n    let current = this.tail;\r\n    while (current) {\r\n      result.push(current.value);\r\n      current = current.prev;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  // 循环遍历链表，并返回遍历结果\r\n  loopTraversal() {\r\n    const result = [];\r\n    let current = this.head;\r\n    while (current) {\r\n      result.push(current.value);\r\n      current = current.next;\r\n      if (current === this.head) {\r\n        break;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n}\r\n```\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/10/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/10/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/9",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/9/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/9/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/9/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/9",
    "id": 1603421329,
    "node_id": "I_kwDOJCCH1M5fkkSR",
    "number": 9,
    "title": "JS 中继承方式有哪些？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-02-28T16:45:31Z",
    "updated_at": "2023-03-05T05:04:23Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 1、借助构造函数实现继承\r\n\r\ncall和apply改变的是JS运行的上下文:             \r\n```javascript\r\n/*借助构造函数实现继承*/\r\nfunction Parent(name) {\r\n    this.name = name;\r\n    this.getName = function () {\r\n        console.log(this.name);\r\n    }\r\n}\r\n\r\nfunction Child(name) {\r\n    Parent.call(this, name);\r\n    this.type = 'child1'\r\n}\r\n\r\nlet child = new Child('yanle');\r\nchild.getName();\r\nconsole.log(child.type);\r\n```\r\n父类的this指向到了子类上面去，改变了实例化的this 指向，导致了父类执行的属性和方法，都会挂在到\t子类实例上去；                     \r\n缺点：父类原型链上的东西并没有被继承；\r\n\r\n\r\n# 2、通过原型链实现继承\r\n```javascript\r\n/*通过原型链实现继承*/\r\nfunction Parent2(){\r\n    this.name='parent2'\r\n}\r\n\r\nfunction Child2(){\r\n    this.type='child2'\r\n}\r\n\r\nChild2.prototype=new Parent2();\r\nconsole.log(new Child2());\r\n```\r\n\r\nChild2.prototype是Child2构造函数的一个属性，这个时候prototype被赋值了parent2的一个实例，实例化了新的对象Child2()的时候，\r\n会有一个__proto__属性，这个属性就等于起构造函数的原型对象，但是原型对象被赋值为了parent2的一个实例，\r\n所以new Child2的原型链就会一直向上找parent2的原型\r\n\r\nvar s1=new Child2();                \r\nvar s2=new Child2();                    \r\ns1.__proto__===s2.__proto__;//返回true                        \r\n\r\n缺点：通过子类构造函数实例化了两个对象，当一个实例对象改变其构造函数的属性的时候，\r\n那么另外一个实例对象上的属性也会跟着改变（期望的是两个对象是隔离的赛）；原因是构造函数的原型对象是公用的；\r\n\r\n\r\n# 3、组合方式\r\n```javascript\r\n/*组合方式*/\r\nfunction Parent3(){\r\n    this.name='parent3';\r\n    this.arr=[1,2,3];\r\n}\r\n\r\nfunction Child3(){\r\n    Parent3.call(this);\r\n    this.type='child';\r\n}\r\n\r\nChild3.prototype=new Parent3();\r\nvar s3=new Child3();\r\nvar s4=new Child3();\r\ns3.arr.push(4);\r\nconsole.log(s3,s4);\r\n```\r\n\r\n**优点:**这是最通用的使用方法，集合了上面构造函数继承，原型链继承两种的优点。                      \r\n**缺点:**父类的构造函数执行了2次，这是没有必要的，                            \r\nconstructor指向了parent了\r\n\r\n\r\n# 4、组合继承的优化\r\n```javascript\r\n/*组合继承的优化1*/\r\nfunction Parent4(){\r\n    this.name='parent3';\r\n    this.arr=[1,2,3];\r\n}\r\n\r\nfunction Child4(){\r\n    Parent4.call(this);\r\n    this.type='child5';\r\n}\r\n\r\nChild4.prototype=Parent4.prototype;\r\nvar s5=new Child4();\r\nvar s6=new Child4()\r\n```\r\n\r\n**缺点：**s5 instaceof child4 //true, s5 instanceof Parent4//true                                \r\n我们无法区分一个实例对象是由其构造函数实例化，还是又其构造函数的父类实例化的                              \r\ns5.constructor  指向的是Parent4;//原因是子类原型对象的constructor 被赋值为了父类原型对象的\tconstructor,所以我们使用constructor的时候，肯定是指向父类的                           \r\nChild3.constructor 也有这种情况                               \r\n\r\n# 5、组合继承的优化2\r\n```javascript\r\nfunction Parent5() {\r\n    this.name = 'parent5';\r\n    this.play = [1, 2, 3];\r\n}\r\n\r\nfunction Child5() {\r\n    Parent5.call(this);\r\n    this.type = 'child5'\r\n}\r\n\r\nChild5.prototype = Object.create(Parent5.prototype);\r\n//这个时候虽然隔离了，但是constructor还是只想的Parent5的，因为constructor会一直向上找\r\nChild5.prototype.constructor=Child5;\r\n\r\nvar s7=new Child5();\r\nconsole.log(s7 instanceof Child5,s7 instanceof Parent5);\r\nconsole.log(s7.constructor);\r\n```\r\n\r\n通过Object.create来创建原型中间对象，那么这么来的话，chiild5的对象prototype获得的是parent5\t父类的原型对象；                    \r\nObject.create创建的对象，原型对象就是参数；                            \r\n    \r\n    \r\n# 6、ES 中的继承\r\nClass 可以通过extends关键字实现继承，让子类继承父类的属性和方法。extends 的写法比 ES5 的原型链继承，要清晰和方便很多。\r\n```js\r\nclass Point { /* ... */ }\r\n\r\nclass ColorPoint extends Point {\r\n  constructor(x, y, color) {\r\n    super(x, y); // 调用父类的constructor(x, y)\r\n    this.color = color;\r\n  }\r\n\r\n  toString() {\r\n    return this.color + ' ' + super.toString(); // 调用父类的toString()\r\n  }\r\n}\r\n```\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/9/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/9/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/8",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/8/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/8/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/8/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/8",
    "id": 1603408313,
    "node_id": "I_kwDOJCCH1M5fkhG5",
    "number": 8,
    "title": "解释一下 原型、构造函、实例、原型链 之间的关系？",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-02-28T16:36:39Z",
    "updated_at": "2023-03-05T05:04:31Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 创建对象有哪几种方式？\r\n\r\n```js\r\n// 面向字面量\r\nvar o1={name:'01'};\r\nvar o11=new Object({name:'o11'});\r\n\r\n// 使用显示的构造函数：\r\nvar M=function(){this.name='02'};\r\nvar o2=new M();\r\n\r\n// 通过Object.create()创建\r\nvar P={name:'o3'};\r\nvar o3=Object.create(P)\r\n```\r\n\r\n# 解释一下 原型、构造函、实例、原型链 之间的关系？\r\n![01_01](https://user-images.githubusercontent.com/22188674/221917767-022a2d09-3539-4e54-a462-34299be8eb0b.png)\r\n\r\n## 1、基础           \r\n构造函数可以通过new来生成一个实例、构造函数也是函数；                \r\n函数都有一个prototype属性，这个就是原型对象；         \r\n原型对象可以通过构造器constructor来指向它的构造函数；             \r\n实例的__proto__属性，指向的是其构造函数的原型对象；                          \r\n\r\n\r\n**原型链**：从一个实例对象，向上找构造这个实例相关联的对象，相关联的对象又向上找，找到创造它的一个实例对象，\r\n一直到Object.prototype截止。原型链是通过prototype和__proto__向上找的。构造函数通过prototype创建了很多方法，\r\n被其所有实例所公用，存放在原型对象上；                      \r\n\r\n例子：\r\n```javascript\r\nvar M=function(name){this.name=name};\r\nvar o3=new M('o3');\r\n```\r\n\r\n当我们需要扩展实例的时候，我们可以对构造函数添加方法，但是这样会创建每一个实例都拷贝一份它自己的添加的方法，\r\n占用内存，而且也没有必要，这个时候就可以新添加的方法写进原型里面去，添加到原型链中去，\r\n在实例的原型链中我们可以在原型对象上找到添加的方法；\r\n\r\n```javascript\r\nvar M=function(name){this.name=name};\r\nvar o3=new M('o3');\r\nM.prototype.say=function(){\r\nConsole.log('say hi');\r\n};\r\nvar o5=new M('o5');\r\n```\r\n\r\n通过这种方式o3和o5都有say方法；原型链的优势是原型对象的方法是被所有实例共有的；\r\n\r\n当访问一个实例方法的时候，首先在实例本身找这个方法，如果没有找到就会到其构建函数的原型对象去找，如果还是没有找到，\r\n那么它会继续通过原型链在原型对象的更上一级查找，一直到object.prototype;\r\n\r\n一定要记住只有函数才有proptotype,对象是没有的；\r\n\r\n只有实例对象又__proto__ , 因为函数也是对象，所以函数也有__proto__ , 但是和实例对象的__proto__是有区别的，函数的__proto__是function这个对象的构造实例；\r\n\r\n\r\n## 2、instanceof 原理\r\n\r\n实例对象上面有一个__proto__ ，这个是引用的它构造函数的原型对象；\r\n\r\ninstanceof是用来判断实例是不是由某个构造函数实例化出来的对象，其原理是判断实例对象是否指向构造函数的原型；\r\n只要是在原型链上的函数，都会被instanceof看做是实例对象的一个构造函数，所以都会返回true;\r\n\r\n```\r\nm1.__proto__===m1.prototype;返回true\r\nm1.prototype.__proto===Object.prototype;返回true\r\n\r\no3.__proto__.constructor===Object;//返回false\r\n所以我们判断一个实例对象的构造函数，用constructor;\r\n```\r\n\r\n## 3、new 运算符\t\t\r\n后面跟着的是一个构造函数\r\n\r\n一个新对象被创建。它继承自 foo.prototype->                            \r\n构造函数foo会被执行，执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例。\tnew foo等同于new foo(),只能在不传递任何参数的情况->                     \r\n如果构造函数返回了一个‘对象’，那么这个对象会取代整个new 出来的结果。如果构造函数没有返回值，\t那么new出来的结果为步骤1创建的对象\r\n\r\n## 4、Object.create()\r\n创建的实例对象是指向的对象原型，实例对象本身是不具备创建对象的属性和方法的，是通过原型链来链接的。\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/8/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/8/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/7",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/7/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/7/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/7/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/7",
    "id": 1603392107,
    "node_id": "I_kwDOJCCH1M5fkdJr",
    "number": 7,
    "title": "Http协议基础",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209338819,
        "node_id": "LA_kwDOJCCH1M8AAAABNoAzww",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/%E7%BD%91%E7%BB%9C",
        "name": "网络",
        "color": "E84C98",
        "default": false,
        "description": "web 网络相关内容"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/2",
      "html_url": "https://github.com/yanlele/interview-question/milestone/2",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/2/labels",
      "id": 9118709,
      "node_id": "MI_kwDOJCCH1M4AiyP1",
      "number": 2,
      "title": "中",
      "description": "中级程序面试问题\r\n",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 23,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:52Z",
      "updated_at": "2023-03-05T15:11:55Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-02-28T16:25:46Z",
    "updated_at": "2023-03-05T05:04:40Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# http 协议有什么特点？\r\n**简单快速，灵活、无连接、无状态**   \r\n\r\n每一个资源对应一个URI，请求只要输入资源地址uri就可以了；     \r\n在每一个http头部协议中都有一个数据类型，通过一个http协议就可以完成不同类型数据的传输；     \r\n链接一次就会断开；       \r\n每一次链接不会记住链接状态的，服务器不区分两次链接的身份；\r\n\r\n\r\n  \r\n\r\n# http报文组成部分？\r\n\r\n## 请求报文\r\n\r\n**请求报文**：请求行、请求头、空行、请求体     \r\n**请求行**：HTTP请求方法、页面地址、协议版本等         \r\n**请求头**：key,value值，告诉服务端我要什么内容、要什么数据类型                      \r\n**空行**：分割请求头和请求体的，遇到空行，服务器就知道，请求头结束了，接下来是请求体了           \r\n**请求体**：就是给服务端的一些入参数据；          \r\n我所了解的请求体有两种格式，Content-Type: application/x-www-form-urlencoded  和  payload  和 json   \r\n\r\n## 相应报文\r\n状态行、响应头、空行、响应体\r\n\r\n**状态行**：协议版本  状态码   状态\r\n其他的一样的   \r\n\r\n\r\n\r\n# 通信协议？\r\n建立在 TCP 之上的\r\n\r\n\r\n# 常见请求头数据和相应头数据（以github某请求为例子）\r\n**Request Headers**\r\n```\r\nAccept: */*                         // 告诉服务器，客户机支持的数据类型\r\nAccept-Encoding: gzip, deflate, br  // 告诉服务器，客户机支持的数据压缩格式\r\nAccept-Language: zh-CN,zh;q=0.9     // 编码格式\r\nConnection: keep-alive              // 是否支持场链接\r\nContent-Length: 12308               // 获取文件的总大小\r\nContent-Type: application/json      // 返回数据格式\r\nHost: api.github.com\r\nOrigin: https://github.com\r\nReferer: https://github.com/yanlele/node-index/blob/master/book/05%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%93%E9%A2%98/01_01%E3%80%81%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E9%83%A8%E5%88%861-10.md\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.102 Safari/537.36\r\n```\r\n\r\n**Response Headers:**\r\n```\r\nAccess-Control-Allow-Origin: *                          // 允许跨域策略\r\nAccess-Control-Expose-Headers: ETag, Link, Location...  // 列出了哪些首部可以作为响应的一部分暴露给外部\r\nCache-Control: no-cache                                 // 缓存失效时间\r\nContent-Length: 5                                       // 获取文件的总大小\r\nContent-Security-Policy: default-src 'none'             // 配置内容安全策略涉\r\nContent-Type: application/json; charset=utf-8           // 返回数据格式\r\nDate: Wed, 21 Nov 2018 09:55:47 GMT\r\nReferrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin\r\nServer: GitHub.com\r\nStatus: 200 OK                                          // 状态码\r\nStrict-Transport-Security: max-age=31536000; includeSubdomains; preload\r\nVary: Accept-Encoding\r\nX-Content-Type-Options: nosniff\r\nX-Frame-Options: deny\r\nX-GitHub-Media-Type: github.v3; format=json\r\nX-GitHub-Request-Id: A3D4:2AE5:13372C:19E45C:5BF52BA3\r\nX-XSS-Protection: 1; mode=block\r\n``` \r\n\r\n# HTTP方法相关？\r\nGET请求资源、post传输资源、put更新资源、delete删除资源、head获取报文首部\r\n\r\n## get和post区别\r\n- get只能url 编码、post支持多种编码方式            \r\n- get在传输参数有长度限制的，而post是没有长度限制的        \r\n- get通过url传递，post放在request body中      \r\n- get不安全，post是一种安全的传输协议方式     \r\n- get会把参数保存到浏览器记录里，而post中的参数不会保存          \r\n- get 会被浏览器缓存  \r\n\r\n# http 常见状态码有哪些？\r\n**1.XX**:指示信息-表示请求已经接受，继续处理\r\n         \r\n**2.XX:成功**         \r\n    200：请求成功            \r\n    206：客户端发送一个range头的get请求，服务器完成了他         \r\n    \r\n**3.XX：重定向**        \r\n    301：请求的页面转移到新的url;      \r\n    302:临时转移到新的url          \r\n    304：客户端缓存的文件并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用         \r\n    \r\n**4.XX：客户端错误**             \r\n    400：语法错误        \r\n    401：请求未授权       \r\n    403：请求禁止访问      \r\n    404：请求资源不存在     \r\n    \r\n**5.XX：服务端错误**     \r\n    500：服务器发生不可预期的错误        \r\n    503：服务器请求未完成  \r\n\r\n\r\n\r\n# 什么是 HTTP持久链接？\r\nhttp采用的是 \"请求-应答\" 模式                         \r\n当使用keep-Alive 模式（又称持久链接、链接重用）时、http1.1版本才支持的                        \r\n`Connection: keep-alive`\r\n\r\n# 什么是管线化？\r\n持久链接下：链接传递消息类似于请求1->响应1->请求2->响应2->请求3->响应3                             \r\n管线化：请求1-》请求2-》请求3-》响应1-》响应2-》响应3                            \r\n需要通过持久链接完成，所以仅HTTP1.1版本支持                       \r\n只有get和head请求支持管线化，post请求是有所限制的          \r\n\r\n# 深入研究 HTTPS\r\n## Https涉及到的主体:                            \r\n1、客户端。通常是浏览器(Chrome、IE、FireFox等)，也可以自己编写的各种语言的客户端程序。                                    \r\n2、服务端。一般指支持Https的网站，比如github、支付宝。                                   \r\n3、CA(Certificate Authorities)机构。Https证书签发和管理机构，比如Symantec、Comodo、GoDaddy、GlobalSign。\r\n\r\n图示这三个角色：    \r\n![01-05-01](https://user-images.githubusercontent.com/22188674/221914484-98831a29-4af5-472c-be59-f54dcd46b15d.png)\r\n\r\n\r\n## 发明 Https 的动机:\r\n`认证正在访问的网站。` 什么叫认证网站？比如你正在访问支付宝，怎样确定你正在访问的是阿里巴巴提供的支付宝而不是假冒伪劣的钓鱼网站呢？                                     \r\n`保证所传输数据的私密性和完整性。` 众所周知，Http是明文传输的，所以处在同一网络中的其它用户可以通过网络抓包来窃取和篡改数据包的内容，\r\n甚至运营商或者wifi提供者，有可能会篡改http报文，添加广告等信息以达到盈利的目的。\r\n\r\n\r\n## Https的工作流程\r\n\r\n![01-05-02](https://user-images.githubusercontent.com/22188674/221914949-a44091ea-57f5-49b4-87ad-b777ca1313c3.png)\r\n\r\n可以看到工作流程，基本分为**三个阶段**：     \r\n                     \r\n**1、`认证服务器。`** 浏览器内置一个受信任的CA机构列表，并保存了这些CA机构的证书。\r\n第一阶段服务器会提供经CA机构认证颁发的服务器证书，如果认证该服务器证书的CA机构，存在于浏览器的受信任CA机构列表中，\r\n并且服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，\r\n并从服务器证书中取得服务器公钥，用于后续流程。\r\n否则，浏览器将提示用户，根据用户的选择，决定是否继续。\r\n当然，我们可以管理这个受信任CA机构列表，添加我们想要信任的CA机构，或者移除我们不信任的CA机构。\r\n\r\n**2、`协商会话密钥。`** 客户端在认证完服务器，获得服务器的公钥之后，利用该公钥与服务器进行加密通信，\r\n协商出两个会话密钥，分别是用于加密客户端往服务端发送数据的客户端会话密钥，用于加密服务端往客户端发送数据的服务端会话密钥。\r\n在已有服务器公钥，可以加密通讯的前提下，还要协商两个对称密钥的原因，是因为非对称加密相对复杂度更高，在数据传输过程中，使用对称加密，可以节省计算资源。\r\n另外，会话密钥是随机生成，每次协商都会有不一样的结果，所以安全性也比较高。\r\n\r\n**3、`加密通讯。`**此时客户端服务器双方都有了本次通讯的会话密钥，之后传输的所有Http数据，都通过会话密钥加密。\r\n这样网路上的其它用户，将很难窃取和篡改客户端和服务端之间传输的数据，从而保证了数据的私密性和完整性。\r\n\r\n## 总结\r\n说是讨论Https，事实上Https就是Http跑在SSL或者TLS上，所以本文讨论的原理和流程其实是SSL和TLS的流程，对于其它使用SSL或者TLS的应用层协议，本文内容一样有效。                                \r\n本文只讨论了客户端验证服务端，服务端也可以给客户端颁发证书并验证客户端，做双向验证，但应用没有那么广泛，原理类似。                       \r\n由于采用了加密通讯，Https无疑要比Http更耗费服务器资源，这也是很多公司明明支持Https却默认提供Http的原因。\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/7/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/7/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/6",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/6/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/6/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/6/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/6",
    "id": 1603362175,
    "node_id": "I_kwDOJCCH1M5fkV1_",
    "number": 6,
    "title": "DOM事件类相关问题",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209173738,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2u6g",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/JavaScript",
        "name": "JavaScript",
        "color": "0F22CD",
        "default": false,
        "description": "JS 基础语法"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-02-28T16:07:54Z",
    "updated_at": "2023-03-05T05:04:51Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "DOM事件级别、DOM事件模型、DOM事件流、DOM事件捕获的具体流程、Event对象的常见应用、自动以事件\r\n\r\n# dom 级别\r\nDOM级别一共可以分为四个级别：DOM0级、DOM1级、DOM2级和DOM3级。\r\nDOM级别其实就是标准的迭代，对于版本的称呼，类似ES5、ES6。\r\n\r\n## 1、DOM0级\r\nDOM没有被W3C定为标准之前。\r\n\r\n## 2、DOM1级\r\n1998年10月成为W3C的标准后，称为DOM1级。DOM1级由两个模块组成：DOM核心（DOM Core）和DOM HTML。其中，DOM核心规定的是如何映射基于XML的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML模块则在DOM核心的基础上加以扩展，添加了针对HTML的对象和方法。\r\n\r\n## 3、DOM2级\r\n在DOM1级的基础上进行了扩展。为节点添加了更多方法和属性等。\r\n添加新的模块，包括：视图、事件、范围、遍历、样式等。\r\n\r\n## 4、DOM3级\r\nDOM3级进一步扩展了DOM，增加了XPath模块、加载和保存（DOM Load and Save）模块等，开始支持XML1.0规范。\r\n\r\n\r\n\r\n\r\n# DOM事件\r\n## 1、DOM0级事件\r\nDOM0级处理事件就是将一个函数赋值给一个事件处理属性。\r\n```js\r\n<button id=\"btn\" type=\"button\"></button> \r\n \r\nvar btn = document.getElementById('btn')\r\nbtn.onclick = function() { \r\n    console.log('Hello World')\r\n}\r\n// 将一个函数赋值给了一个事件处理属性onclick 这样的方法就是DOM0级。\r\n// 可以通过给事件处理属性赋值null来解绑事件。\r\n```\r\n\r\n## DOM2级事件\r\nDOM2级处理事件是在DOM0级处理事件的基础上再添加了一些处理程序。\r\n\r\n- 可以同时绑定多个事件处理函数。\r\n- 定义了 addEventListener 和 removeEventListener 两个方法。\r\n```js\r\nelement.addEventListener(eventName, fn, useCapture)\r\n// 第三个参数 useCapture：指定事件是否在捕获或冒泡阶段执行。布尔值，可选，默认false\r\n// 可能值：true - 事件句柄在捕获阶段执行；false- 默认。事件句柄在冒泡阶段执行\r\n\r\n<button id=\"btn\" type=\"button\"></button> \r\n \r\nvar btn = document.getElementById('btn')\r\nfunction showFn() { \r\n    alert('Hello World')\r\n}\r\nfunction LogFn() { \r\n    alert('Hello World')\r\n}\r\n// 同时绑定多个事件处理函数\r\nbtn.addEventListener('click', showFn);\r\nbtn.addEventListener('click', LogFn);\r\n\r\n// 解绑事件 \r\nbtn.removeEventListener('click', showFn); \r\n```\r\n\r\n## DOM3级事件\r\nDOM3级处理事件是在DOM2级处理事件的基础上再添加了很多事件类型。\r\n\r\n- UI事件，当用户与页面上的元素交互时触发，如：`load`、`scroll`\r\n- 焦点事件，当元素获得或失去焦点时触发，如：`blur`、`focus`\r\n- 鼠标事件，当用户通过鼠标在页面执行操作时触发如：`dbclick`、`mouseup`\r\n- 滚轮事件，当使用鼠标滚轮或类似设备时触发，如：`mousewheel`\r\n- 文本事件，当在文档中输入文本时触发，如：`textInput`\r\n- 键盘事件，当用户通过键盘在页面上执行操作时触发，如：`keydown`、`keypress`\r\n- 合成事件，当为IME（输入法编辑器）输入字符时触发，如：`compositionstart`\r\n- 变动事件，当底层DOM结构发生变化时触发，如：`DOMsubtreeModified`\r\n\r\n同时DOM3级事件也允许使用者自定义一些事件。\r\n\r\n\r\n# 事件模型\r\n捕获（从上到下）、冒泡（从下到上）；\r\n\r\n\r\n# 事件流\r\n用户和浏览器做交互的过程中，事件的传递，比如点击左键，怎么传递到页面上的。\r\n\r\n捕获->目标阶段->冒泡\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n  <meta charset=\"UTF-8\">\r\n  <title>事件冒泡</title>\r\n</head>\r\n<body>\r\n  <div id=\"parent\">\r\n    我是父元素\r\n    <span id=\"son\">我是子元素</span>\r\n  </div>\r\n</body>\r\n<script type=\"text/javascript\">\r\nvar parent = document.getElementById('parent');\r\nvar son = document.getElementById('son');\r\n\r\nparent.addEventListener('click', () => {\r\n  alert('父级冒泡');\r\n}, false);\r\nparent.addEventListener('click', () => {\r\n  alert('父级捕获');\r\n}, true);\r\nson.addEventListener('click', () => {\r\n  alert('子级捕获');\r\n}, true);\r\nson.addEventListener('click', () => {\r\n  alert('子级冒泡');\r\n}, false);\r\n</script>\r\n</html>\r\n```\r\n当点击父元素：父级冒泡 -> 父级捕获\r\n当点击子元素：父级捕获 -> 子级捕获 -> 子级冒泡 -> 父级冒泡\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/6/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/6/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/5",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/5/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/5/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/5/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/5",
    "id": 1603340937,
    "node_id": "I_kwDOJCCH1M5fkQqJ",
    "number": 5,
    "title": "解释边距重叠",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209172485,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2qBQ",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/CSS",
        "name": "CSS",
        "color": "7F09CC",
        "default": false,
        "description": "CSS 相关类型的问题"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-02-28T15:57:08Z",
    "updated_at": "2023-03-05T05:05:02Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 什么是BFC\r\n\r\nBFC （block formatting context） 及块级格式化上下文，从样式上看，具有 BFC 的元素与普通的容器没有什么区别，从功能上看，BFC相当于构建了一个密闭的盒子模型，在BFC中的元素不受外部元素的影响；\r\n\r\n**个人理解**：BFC就是将盒子中子元素的属性锁在父元素中，例如margin,float 使其不影响盒子外的元素。\r\n\r\n\r\n\r\n# 如何构建BFC\r\n\r\n以下情况都会使元素产生BFC\r\n\r\n- 根元素或其它包含它的元素 (也就是html元素本身就是BFC)\r\n- float:left ,right\r\n- position:absolute,fixed\r\n- display:inline-block,table-cell,table-caption;(行内块元素与表格元素)\r\n- overflow：hidden，auto，scroll （非 visible属性）\r\n- display: flow-root\r\n- column-span: all\r\n\r\n# BFC的作用\r\n\r\n## 1. 解决高度塌陷\r\n由于浮动元素脱离了文档流，普通盒子是无法包裹住已经浮动的元素；父级元素的高度为0；\r\n\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        * { box-sizing: border-box; }\r\n\r\n        .outer {\r\n            background-color: #ccc;\r\n            width: 200px;\r\n        }\r\n        .outer div{\r\n            width: 100px;\r\n            margin: 10px 20px;\r\n            background-color: red;\r\n            width: 100px;\r\n            height: 100px;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body >\r\n    <div class=\"outer \">\r\n        <div style=\"float: left;\"></div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n当子元素浮动 父级获取不到浮动元素的高度，造成高度塌陷\r\n\r\n\r\n当父元素转变为BFC时，浮动元素被包裹住：\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        * { box-sizing: border-box; }\r\n\r\n        .outer {\r\n            background-color: #ccc;\r\n            width: 200px;\r\n            overflow: hidden;  //转变为BFC\r\n        }\r\n        .outer div{\r\n            width: 100px;\r\n            margin: 10px 20px;\r\n            background-color: red;\r\n            width: 100px;\r\n            height: 100px;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body >\r\n    <div class=\"outer \">\r\n        <div style=\"float: left;\"></div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 2.浮动重叠\r\n当一个元素浮动，后面的元素没浮动，那么后面的元素就会与浮动元素发生重叠\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        * { box-sizing: border-box; }\r\n\r\n        .outer {\r\n            background-color: #ccc;\r\n            width: 200px;\r\n            overflow: hidden;\r\n        }\r\n        .outer div{\r\n            width: 100px;\r\n            margin: 10px 20px;\r\n            background-color: red;\r\n            width: 100px;\r\n            height: 100px;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body >\r\n    <div class=\"outer \">\r\n        <div style=\"float: left;\"></div>\r\n        <div ></div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n后一个元素 与前一个浮动元素发生重叠\r\n\r\n根据BFC不与浮动元素重叠的特性，为没有浮动的元素创建BFC环境\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        * { box-sizing: border-box; }\r\n\r\n        .outer {\r\n            background-color: #ccc;\r\n            width: 200px;\r\n            overflow: hidden;\r\n        }\r\n        .outer div{\r\n            width: 100px;\r\n            margin: 10px 20px;\r\n            background-color: red;\r\n            width: 100px;\r\n            height: 100px;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body >\r\n    <div class=\"outer \">\r\n        <div style=\"float: left;\"></div>\r\n        <div style=\"overflow: hidden;\"></div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n## 3.边距重叠\r\n边距重叠分为两种情况\r\n\r\n- 父子重叠\r\n```html\r\n当 父级没有 \r\n-  垂直方向的border，\r\n-  垂直方向 padding，\r\n-  父级不是内联元素，\r\n-  父级不是BFC,\r\n-  父级没有清除浮动，\r\n\r\n这五个条件时，子元素的上下边距会和父级发生重叠 \r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        * { box-sizing: border-box; }\r\n\r\n        .outer {\r\n            background-color: #ccc;\r\n            width: 200px;\r\n        }\r\n        .outer div{\r\n            width: 100px;\r\n            margin: 10px 20px;\r\n            background-color: red;\r\n            width: 100px;\r\n            height: 100px;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body >\r\n    <div class=\"outer \">\r\n        <div></div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n解决办法：\r\n```html\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        * { box-sizing: border-box; }\r\n\r\n        .outer {\r\n            background-color: #ccc;\r\n            width: 200px;\r\n            /*padding: 1px;*/    加padding  \r\n            /*border: 1px solid yellow;*/ 加border\r\n            /*display: inline-block;*/  内联块\r\n            /*overflow: hidden;*/       BFC\r\n        }\r\n        .clearfix:after{                清除浮动\r\n            content: '';\r\n            display: table;\r\n            clear:both;\r\n        }\r\n        .outer div{\r\n            width: 100px;\r\n            margin: 10px 20px;\r\n            background-color: red;\r\n            width: 100px;\r\n            height: 100px;\r\n        }\r\n\r\n    </style>\r\n</head>\r\n<body >\r\n    <div class=\"outer clearfix\">\r\n        <div></div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n\r\n- 兄弟重叠\r\n当两个元素的垂直边距相互接触时，两者边距会发生合并，合并的规则为      \r\n```html\r\n- 如果是正数比大小，大的覆盖小的\r\n- 都为负数比绝对值大小，大的覆盖小的\r\n- 正负都有取其差\r\n\r\n1.将两个元素浮动\r\n2.将两个元素display：inline-block\r\n<!DOCTYPE html>\r\n<html lang=\"en\">\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Document</title>\r\n    <style>\r\n        * { box-sizing: border-box; }\r\n\r\n        .outer {\r\n            background-color: #ccc;\r\n            width: 200px;\r\n            overflow: hidden;\r\n        }\r\n        .outer div{\r\n            width: 100px;\r\n            margin: 10px 20px;\r\n            background-color: red;\r\n            width: 100px;\r\n            height: 100px;\r\n            /*下面两种方式*/\r\n            float: left;\r\n            display: inline-block;\r\n        }\r\n    </style>\r\n</head>\r\n<body >\r\n    <div class=\"outer \">\r\n        <div ></div>\r\n        <div ></div>\r\n    </div>\r\n</body>\r\n</html>\r\n```\r\n其实兄弟重叠完全可以设置一个最大值的边距就可达到想要的效果，完全没有必要去使用上面的两个方法。\r\n\r\n\r\n\r\n# 参考文档\r\n- https://blog.csdn.net/itseven7/article/details/79009215\r\n\r\n\r\n\r\n\r\n",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/5/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/5/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  },
  {
    "url": "https://api.github.com/repos/yanlele/interview-question/issues/4",
    "repository_url": "https://api.github.com/repos/yanlele/interview-question",
    "labels_url": "https://api.github.com/repos/yanlele/interview-question/issues/4/labels{/name}",
    "comments_url": "https://api.github.com/repos/yanlele/interview-question/issues/4/comments",
    "events_url": "https://api.github.com/repos/yanlele/interview-question/issues/4/events",
    "html_url": "https://github.com/yanlele/interview-question/issues/4",
    "id": 1603317396,
    "node_id": "I_kwDOJCCH1M5fkK6U",
    "number": 4,
    "title": "水平垂直居中定位",
    "user": {
      "login": "yanlele",
      "id": 22188674,
      "node_id": "MDQ6VXNlcjIyMTg4Njc0",
      "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/yanlele",
      "html_url": "https://github.com/yanlele",
      "followers_url": "https://api.github.com/users/yanlele/followers",
      "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
      "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
      "organizations_url": "https://api.github.com/users/yanlele/orgs",
      "repos_url": "https://api.github.com/users/yanlele/repos",
      "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
      "received_events_url": "https://api.github.com/users/yanlele/received_events",
      "type": "User",
      "site_admin": false
    },
    "labels": [
      {
        "id": 5209172485,
        "node_id": "LA_kwDOJCCH1M8AAAABNn2qBQ",
        "url": "https://api.github.com/repos/yanlele/interview-question/labels/CSS",
        "name": "CSS",
        "color": "7F09CC",
        "default": false,
        "description": "CSS 相关类型的问题"
      }
    ],
    "state": "open",
    "locked": false,
    "assignee": null,
    "assignees": [],
    "milestone": {
      "url": "https://api.github.com/repos/yanlele/interview-question/milestones/1",
      "html_url": "https://github.com/yanlele/interview-question/milestone/1",
      "labels_url": "https://api.github.com/repos/yanlele/interview-question/milestones/1/labels",
      "id": 9118708,
      "node_id": "MI_kwDOJCCH1M4AiyP0",
      "number": 1,
      "title": "初",
      "description": "初级面试问题",
      "creator": {
        "login": "yanlele",
        "id": 22188674,
        "node_id": "MDQ6VXNlcjIyMTg4Njc0",
        "avatar_url": "https://avatars.githubusercontent.com/u/22188674?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/yanlele",
        "html_url": "https://github.com/yanlele",
        "followers_url": "https://api.github.com/users/yanlele/followers",
        "following_url": "https://api.github.com/users/yanlele/following{/other_user}",
        "gists_url": "https://api.github.com/users/yanlele/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/yanlele/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/yanlele/subscriptions",
        "organizations_url": "https://api.github.com/users/yanlele/orgs",
        "repos_url": "https://api.github.com/users/yanlele/repos",
        "events_url": "https://api.github.com/users/yanlele/events{/privacy}",
        "received_events_url": "https://api.github.com/users/yanlele/received_events",
        "type": "User",
        "site_admin": false
      },
      "open_issues": 10,
      "closed_issues": 0,
      "state": "open",
      "created_at": "2023-03-05T04:33:33Z",
      "updated_at": "2023-03-05T13:01:56Z",
      "due_on": null,
      "closed_at": null
    },
    "comments": 0,
    "created_at": "2023-02-28T15:45:15Z",
    "updated_at": "2023-03-05T05:05:10Z",
    "closed_at": null,
    "author_association": "OWNER",
    "active_lock_reason": null,
    "body": "# 水平垂直居中定位\r\n\r\n## 垂直居中的方案\r\n\r\n1、                  \r\n```\r\nline-height: 200px;\r\nvertical-align: middle;\r\n```\r\n\r\n\r\n2、CSS Table              \r\n```\r\n#parent {display: table;}\r\n#child {\r\ndisplay: table-cell;\r\nvertical-align: middle;\r\n}\r\n```\r\n\r\n3、Absolute Positioning and Negative Margin                      \r\n```\r\n#parent {position: relative;}\r\n#child {\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    height: 30%;\r\n    width: 50%;\r\n    margin: -15% 0 0 -25%;\r\n}\r\n```\r\n\r\n\r\n4、Absolute Positioning and Stretching\r\n```\r\n#parent {position: relative;}\r\n#child {\r\nposition: absolute;\r\n    top: 0;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    width: 50%;\r\n    height: 30%;\r\n    margin: auto;\r\n}\r\n```\r\n\r\n5、Equal Top and Bottom Padding                          \r\n```\r\n#parent {\r\n    padding: 5% 0;\r\n}\r\n#child {\r\n    padding: 10% 0;\r\n}\r\n```\r\n\r\n## 水平居中的方案\r\n\r\n1、要实现行内元素（<span>、<a>等）的水平居中：text-align:center;              \r\n\r\n2、要实现块状元素（display:block）的水平居中: margin:0 auto;\r\n\r\n3、多个水平排列的块状元素的水平居中:\r\n```\r\n#container{\r\n    text-align:center;\r\n}\r\n#center{\r\n    display:inline-block;\r\n}\r\n```\r\n\r\n4、flexbox\r\n```\r\n#container {\r\n    display: flex;\r\n}\r\n#container {\r\n    display: inline-flex;\r\n}\r\n```\r\n\r\n5、一直宽度水平居中:绝对定位与负边距实现。\r\n```\r\n#container{\r\n    position:relative;\r\n}\r\n\r\n#center{\r\n    width:100px;\r\n    height:100px;\r\n    position:absolute;\r\n    top:50%;\r\n    left:50%;\r\n    margin:-50px 0 0 -50px;\r\n}\r\n```\r\n\r\n6、绝对定位与margin：\r\n```\r\n#container{\r\n    position:relative;\r\n}\r\n#center{\r\n    position:absolute;\r\n    margin:auto;\r\n    top:0;\r\n    bottom:0;\r\n    left:0;\r\n    right:0;\r\n}\r\n```\r\n\r\n\r\n## 未知高度和宽度元素的水平垂直居中    \r\n1、当要被居中的元素是inline或者inline-block元素\r\n```\r\n #container{\r\n    display:table-cell;\r\n    text-align:center;\r\n    vertical-align:middle;\r\n}\r\n\r\n#center{\r\n\r\n}\r\n```\r\n\r\n\r\n2、利用Css3的transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中。\r\n```\r\n#container{\r\n    position:relative;\r\n}\r\n#center{\r\n    position: absolute;\r\n    top: 50%;\r\n    left: 50%;\r\n    transform: translate(-50%, -50%);\r\n}\r\n```\r\n\r\n3、flex\r\n```\r\n#container{\r\n    display:flex;\r\n    justify-content:center;\r\n    align-items: center;\r\n}\r\n\r\n#center{\r\n\r\n}\r\n```",
    "reactions": {
      "url": "https://api.github.com/repos/yanlele/interview-question/issues/4/reactions",
      "total_count": 0,
      "+1": 0,
      "-1": 0,
      "laugh": 0,
      "hooray": 0,
      "confused": 0,
      "heart": 0,
      "rocket": 0,
      "eyes": 0
    },
    "timeline_url": "https://api.github.com/repos/yanlele/interview-question/issues/4/timeline",
    "performed_via_github_app": null,
    "state_reason": null
  }
]
